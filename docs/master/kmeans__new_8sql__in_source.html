<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MADlib: kmeans_new.sql_in Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="../mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MADlib
   &#160;<span id="projectnumber">0.4.1</span>
   </div>
   <div id="projectbrief">User Documentation</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('kmeans__new_8sql__in.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">kmeans_new.sql_in</div>  </div>
</div>
<div class="contents">
<a href="kmeans__new_8sql__in.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ----------------------------------------------------------------------- */</span><span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * @file kmeans_new.sql_in</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * @brief Set of functions for k-means clustering.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * @sa For a brief introduction to k-means clustering, see the module</span>
<a name="l00008"></a>00008 <span class="comment"> *     description \ref grp_kmeans_new.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> */</span><span class="comment">/* ----------------------------------------------------------------------- */</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 m4_include(`SQLCommon.m4<span class="stringliteral">&#39;)</span>
<a name="l00013"></a>00013 <span class="stringliteral"></span><span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">/**</span>
<a name="l00015"></a>00015 <span class="comment">@addtogroup grp_kmeans_new</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">@about</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">Clustering refers to the problem of partitioning a set of objects according to</span>
<a name="l00020"></a>00020 <span class="comment">some problem-dependent measure of &lt;em&gt;similarity&lt;/em&gt;. In the k-means variant,</span>
<a name="l00021"></a>00021 <span class="comment">one is given \f$ n \f$ points \f$ x_1, \dots, x_n \in \mathbb R^d \f$, and the</span>
<a name="l00022"></a>00022 <span class="comment">goal is to position \f$ k \f$ centroids \f$ c_1, \dots, c_k \in \mathbb R^d \f$</span>
<a name="l00023"></a>00023 <span class="comment">so that the sum of \em distances between each point and its closest centroid is</span>
<a name="l00024"></a>00024 <span class="comment">minimized. Each centroid represents a cluster that consists of all points to</span>
<a name="l00025"></a>00025 <span class="comment">which this centroid is closest. Formally, we wish to minimize the following</span>
<a name="l00026"></a>00026 <span class="comment">objective function:</span>
<a name="l00027"></a>00027 <span class="comment">\f[</span>
<a name="l00028"></a>00028 <span class="comment">    (c_1, \dots, c_k) \mapsto \sum_{i=1}^n \min_{j=1}^k \operatorname{dist}(x_i, c_j)</span>
<a name="l00029"></a>00029 <span class="comment">\f]</span>
<a name="l00030"></a>00030 <span class="comment">In the most common case, \f$ \operatorname{dist} \f$ is the square of the</span>
<a name="l00031"></a>00031 <span class="comment">Euclidean distance.</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">This problem is computationally difficult (NP-hard), yet the</span>
<a name="l00034"></a>00034 <span class="comment">local-search heuristic proposed by Lloyd [4] performs reasonably well in</span>
<a name="l00035"></a>00035 <span class="comment">practice. In fact, it is so ubiquitous today that it is</span>
<a name="l00036"></a>00036 <span class="comment">often referred to as the &lt;em&gt;standard algorithm&lt;/em&gt; or even just the</span>
<a name="l00037"></a>00037 <span class="comment">&lt;em&gt;k-means algorithm&lt;/em&gt; [1]. It works as follows:</span>
<a name="l00038"></a>00038 <span class="comment"></span>
<a name="l00039"></a>00039 <span class="comment">-# Seed the \f$ k \f$ centroids (see below)</span>
<a name="l00040"></a>00040 <span class="comment">-# Repeat until convergence:</span>
<a name="l00041"></a>00041 <span class="comment"> -# Assign each point to its closest centroid</span>
<a name="l00042"></a>00042 <span class="comment"> -# Move each centroid to a position that minimizes the sum of distances in this</span>
<a name="l00043"></a>00043 <span class="comment">    cluster</span>
<a name="l00044"></a>00044 <span class="comment">-# Convergence is achieved when no points change their assignments during step</span>
<a name="l00045"></a>00045 <span class="comment">   2a.</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">Since the objective function decreases in every step, this algorithm is</span>
<a name="l00048"></a>00048 <span class="comment">guaranteed to converge to a local optimum.</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">@implementation</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">Data points and predefined centroids (if used) are expected to be stored row-wise,</span>
<a name="l00053"></a>00053 <span class="comment">in a column of type &lt;tt&gt;\ref grp_svec &quot;SVEC&quot;&lt;/tt&gt; (or any type convertible to</span>
<a name="l00054"></a>00054 <span class="comment">&lt;tt&gt;\ref grp_svec &quot;SVEC&quot;&lt;/tt&gt;, like &lt;tt&gt;FLOAT[]&lt;/tt&gt; or &lt;tt&gt;INTEGER[]&lt;/tt&gt;).</span>
<a name="l00055"></a>00055 <span class="comment">Data points with with non-finite values (NULL, NaN, infinity) in any component</span>
<a name="l00056"></a>00056 <span class="comment">will be skipped during analysis.</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">The following methods are available for the centroid seeding:</span>
<a name="l00059"></a>00059 <span class="comment"> - &lt;strong&gt;random selection&lt;/strong&gt;:</span>
<a name="l00060"></a>00060 <span class="comment">   Select \f$ k \f$ centroids randomly among the input points.</span>
<a name="l00061"></a>00061 <span class="comment"> - &lt;strong&gt;kmeans++&lt;/strong&gt; [2]:</span>
<a name="l00062"></a>00062 <span class="comment">   Start with a single centroid chosen randomly among the input points. Then</span>
<a name="l00063"></a>00063 <span class="comment">   iteratively choose new</span>
<a name="l00064"></a>00064 <span class="comment">   centroids from the input points until there is a total of \f$ k \f$</span>
<a name="l00065"></a>00065 <span class="comment">   centroids. The probability for picking a particular point is proportional to</span>
<a name="l00066"></a>00066 <span class="comment">   its minimum distance to any existing centroid.</span>
<a name="l00067"></a>00067 <span class="comment">   \n</span>
<a name="l00068"></a>00068 <span class="comment">   Intuitively, kmeans++ favors seedings where centroids are spread out over the</span>
<a name="l00069"></a>00069 <span class="comment">   whole range of the input points, while at the same time not being too</span>
<a name="l00070"></a>00070 <span class="comment">   susceptible to outliers [2].</span>
<a name="l00071"></a>00071 <span class="comment"> - &lt;strong&gt;user-specified set of initial centroids&lt;/strong&gt;:</span>
<a name="l00072"></a>00072 <span class="comment">   See below for a description of the expected format of the set of initial</span>
<a name="l00073"></a>00073 <span class="comment">   centroids.</span>
<a name="l00074"></a>00074 <span class="comment"></span>
<a name="l00075"></a>00075 <span class="comment">The following distance functions can be used (computation of barycenter/mean in parentheses):</span>
<a name="l00076"></a>00076 <span class="comment"> - &lt;strong&gt;1-norm/Manhattan&lt;/strong&gt; (element-wise mean)</span>
<a name="l00077"></a>00077 <span class="comment"> - &lt;strong&gt;2-norm/Euclidean&lt;/strong&gt; (element-wise mean)</span>
<a name="l00078"></a>00078 <span class="comment"> - &lt;strong&gt;cosine&lt;/strong&gt; (element-wise mean of normalized points)</span>
<a name="l00079"></a>00079 <span class="comment"> - &lt;strong&gt;tanimoto&lt;/strong&gt; (element-wise mean of normalized points)</span>
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">The algorithm stops when one of the following conditions is met:</span>
<a name="l00082"></a>00082 <span class="comment"> - The fraction of updated points is smaller than convergence threshold (default: 0.001).</span>
<a name="l00083"></a>00083 <span class="comment"> - The algorithm reached the maximum number of allowed iterations (default: 20).</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">A popular method to assess the quality of the clustering is the</span>
<a name="l00086"></a>00086 <span class="comment">&lt;em&gt;silhouette coefficient&lt;/em&gt;, a simplified version of which can be computed</span>
<a name="l00087"></a>00087 <span class="comment">optionally [3]. Since for large data sets this computation is expensive, it is</span>
<a name="l00088"></a>00088 <span class="comment">turned off by default (evaluate = False).</span>
<a name="l00089"></a>00089 <span class="comment"></span>
<a name="l00090"></a>00090 <span class="comment">@input</span>
<a name="l00091"></a>00091 <span class="comment">The &lt;strong&gt;source relation&lt;/strong&gt; is expected to be of the following form (or</span>
<a name="l00092"></a>00092 <span class="comment">to be implicitly convertible into the following form):</span>
<a name="l00093"></a>00093 <span class="comment">&lt;pre&gt;{TABLE|VIEW} &lt;em&gt;data_points&lt;/em&gt; (</span>
<a name="l00094"></a>00094 <span class="comment">    ...</span>
<a name="l00095"></a>00095 <span class="comment">    &lt;em&gt;point_id&lt;/em&gt; BIGINT,</span>
<a name="l00096"></a>00096 <span class="comment">    &lt;em&gt;point_coordinates&lt;/em&gt; FLOAT8[],</span>
<a name="l00097"></a>00097 <span class="comment">    ...</span>
<a name="l00098"></a>00098 <span class="comment">)&lt;/pre&gt;</span>
<a name="l00099"></a>00099 <span class="comment">where:</span>
<a name="l00100"></a>00100 <span class="comment"> - &lt;em&gt;point_id&lt;/em&gt; is the name of an optional column with a unique ID of the</span>
<a name="l00101"></a>00101 <span class="comment">   data point.</span>
<a name="l00102"></a>00102 <span class="comment"> - &lt;em&gt;point_coordinates&lt;/em&gt; is the name of a column with point coordinates.</span>
<a name="l00103"></a>00103 <span class="comment">   Types such as \c svec or &lt;tt&gt;INTEGER[]&lt;/tt&gt; are implicitly convertible to</span>
<a name="l00104"></a>00104 <span class="comment">   &lt;tt&gt;FLOAT8[]&lt;/tt&gt;.</span>
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">If kmeans is called with a set of initial centroids, the centroid relation is</span>
<a name="l00107"></a>00107 <span class="comment">expected to be of the following form:</span>
<a name="l00108"></a>00108 <span class="comment">&lt;pre&gt;{TABLE|VIEW} &lt;em&gt;initial_centroids&lt;/em&gt; (</span>
<a name="l00109"></a>00109 <span class="comment">    ...</span>
<a name="l00110"></a>00110 <span class="comment">    &lt;em&gt;centroid_coordinates&lt;/em&gt; DOUBLE PRECISION[],</span>
<a name="l00111"></a>00111 <span class="comment">    ...</span>
<a name="l00112"></a>00112 <span class="comment">)&lt;/pre&gt;</span>
<a name="l00113"></a>00113 <span class="comment">where:</span>
<a name="l00114"></a>00114 <span class="comment"> - &lt;em&gt;centroid_coordinates&lt;/em&gt; is the name of a column with coordinates</span>
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment">@warning This documentation needs an update!</span>
<a name="l00117"></a>00117 <span class="comment"></span>
<a name="l00118"></a>00118 <span class="comment">@usage</span>
<a name="l00119"></a>00119 <span class="comment">The k-means algorithm can be invoked in four possible ways:</span>
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment">- using &lt;em&gt;random&lt;/em&gt; centroid seeding method for a</span>
<a name="l00122"></a>00122 <span class="comment">provided \f$ k \f$:</span>
<a name="l00123"></a>00123 <span class="comment">&lt;pre&gt;SELECT * FROM \ref kmeans_random(</span>
<a name="l00124"></a>00124 <span class="comment">  &#39;&lt;em&gt;src_relation&lt;/em&gt;&#39;, &#39;&lt;em&gt;src_col_data&lt;/em&gt;&#39;, &#39;&lt;em&gt;src_col_id&lt;/em&gt;&#39;,</span>
<a name="l00125"></a>00125 <span class="comment">  &#39;&lt;em&gt;out_points&lt;/em&gt;&#39;, &#39;&lt;em&gt;out_centroids&lt;/em&gt;&#39;,</span>
<a name="l00126"></a>00126 <span class="comment">  &#39;&lt;em&gt;dist_metric&lt;/em&gt;&#39;,</span>
<a name="l00127"></a>00127 <span class="comment">  &lt;em&gt;max_iter&lt;/em&gt;, &lt;em&gt;conv_threshold&lt;/em&gt;,</span>
<a name="l00128"></a>00128 <span class="comment">  &lt;em&gt;evaluate&lt;/em&gt;, &lt;em&gt;verbose&lt;/em&gt;,</span>
<a name="l00129"></a>00129 <span class="comment">  &lt;em&gt;k&lt;/em&gt;</span>
<a name="l00130"></a>00130 <span class="comment">);&lt;/pre&gt;</span>
<a name="l00131"></a>00131 <span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">- using &lt;em&gt;kmeans++&lt;/em&gt; centroid seeding method for a</span>
<a name="l00133"></a>00133 <span class="comment">provided \f$ k \f$:</span>
<a name="l00134"></a>00134 <span class="comment">&lt;pre&gt;SELECT * FROM \ref kmeans_plusplus(</span>
<a name="l00135"></a>00135 <span class="comment">  &#39;&lt;em&gt;src_relation&lt;/em&gt;&#39;, &#39;&lt;em&gt;src_col_data&lt;/em&gt;&#39;, &#39;&lt;em&gt;src_col_id&lt;/em&gt;&#39;,</span>
<a name="l00136"></a>00136 <span class="comment">  &#39;&lt;em&gt;out_points&lt;/em&gt;&#39;, &#39;&lt;em&gt;out_centroids&lt;/em&gt;&#39;,</span>
<a name="l00137"></a>00137 <span class="comment">  &#39;&lt;em&gt;dist_metric&lt;/em&gt;&#39;,</span>
<a name="l00138"></a>00138 <span class="comment">  &lt;em&gt;max_iter&lt;/em&gt;, &lt;em&gt;conv_threshold&lt;/em&gt;,</span>
<a name="l00139"></a>00139 <span class="comment">  &lt;em&gt;evaluate&lt;/em&gt;, &lt;em&gt;verbose&lt;/em&gt;,</span>
<a name="l00140"></a>00140 <span class="comment">  &lt;em&gt;k&lt;/em&gt;, &lt;em&gt;sample_frac&lt;/em&gt;</span>
<a name="l00141"></a>00141 <span class="comment">);&lt;/pre&gt;</span>
<a name="l00142"></a>00142 <span class="comment"></span>
<a name="l00143"></a>00143 <span class="comment">- with a provided centroid set:</span>
<a name="l00144"></a>00144 <span class="comment">&lt;pre&gt;SELECT * FROM \ref kmeans_cset(</span>
<a name="l00145"></a>00145 <span class="comment">  &#39;&lt;em&gt;src_relation&lt;/em&gt;&#39;, &#39;&lt;em&gt;src_col_data&lt;/em&gt;&#39;, &#39;&lt;em&gt;src_col_id&lt;/em&gt;&#39;,</span>
<a name="l00146"></a>00146 <span class="comment">  &#39;&lt;em&gt;out_points&lt;/em&gt;&#39;, &#39;&lt;em&gt;out_centroids&lt;/em&gt;&#39;,</span>
<a name="l00147"></a>00147 <span class="comment">  &#39;&lt;em&gt;dist_metric&lt;/em&gt;&#39;,</span>
<a name="l00148"></a>00148 <span class="comment">  &lt;em&gt;max_iter&lt;/em&gt;, &lt;em&gt;conv_threshold&lt;/em&gt;,</span>
<a name="l00149"></a>00149 <span class="comment">  &lt;em&gt;evaluate&lt;/em&gt;, &lt;em&gt;verbose&lt;/em&gt;,</span>
<a name="l00150"></a>00150 <span class="comment">  &#39;&lt;em&gt;init_cset_rel&lt;/em&gt;&#39;, &#39;&lt;em&gt;init_cset_col&lt;/em&gt;&#39;</span>
<a name="l00151"></a>00151 <span class="comment">);&lt;/pre&gt;</span>
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">The output centroid set will be stored in the &lt;tt&gt;out_centroids&lt;/tt&gt; table</span>
<a name="l00154"></a>00154 <span class="comment">with the following structure:</span>
<a name="l00155"></a>00155 <span class="comment">&lt;pre&gt;</span>
<a name="l00156"></a>00156 <span class="comment"> cid |  coords</span>
<a name="l00157"></a>00157 <span class="comment">-----+-------------</span>
<a name="l00158"></a>00158 <span class="comment">        ...</span>
<a name="l00159"></a>00159 <span class="comment">&lt;/pre&gt;</span>
<a name="l00160"></a>00160 <span class="comment"></span>
<a name="l00161"></a>00161 <span class="comment">The cluster assignments for each data point will be stored in the</span>
<a name="l00162"></a>00162 <span class="comment">&lt;tt&gt;out_points&lt;/tt&gt; table with the following structure:</span>
<a name="l00163"></a>00163 <span class="comment">&lt;pre&gt;</span>
<a name="l00164"></a>00164 <span class="comment"> pid |  coords  | cid</span>
<a name="l00165"></a>00165 <span class="comment">-----+----------+-----</span>
<a name="l00166"></a>00166 <span class="comment">         ...</span>
<a name="l00167"></a>00167 <span class="comment">&lt;/pre&gt;</span>
<a name="l00168"></a>00168 <span class="comment"></span>
<a name="l00169"></a>00169 <span class="comment">@examp</span>
<a name="l00170"></a>00170 <span class="comment"></span>
<a name="l00171"></a>00171 <span class="comment">-#  Prepare some input data.</span>
<a name="l00172"></a>00172 <span class="comment">\code</span>
<a name="l00173"></a>00173 <span class="comment">sql&gt; SELECT * FROM public.km_sample LIMIT 5;</span>
<a name="l00174"></a>00174 <span class="comment">          coords</span>
<a name="l00175"></a>00175 <span class="comment">--------------------------</span>
<a name="l00176"></a>00176 <span class="comment"> {1,1}:{6.76976,39.89516}</span>
<a name="l00177"></a>00177 <span class="comment"> {1,1}:{6.92655,39.54273}</span>
<a name="l00178"></a>00178 <span class="comment"> {1,1}:{6.78933,39.71434}</span>
<a name="l00179"></a>00179 <span class="comment"> {1,1}:{7.24073,39.61291}</span>
<a name="l00180"></a>00180 <span class="comment"> {1,1}:{6.72292,39.05652}</span>
<a name="l00181"></a>00181 <span class="comment">(5 rows)</span>
<a name="l00182"></a>00182 <span class="comment">\endcode</span>
<a name="l00183"></a>00183 <span class="comment">-#  Run k-means clustering using kmeans++ for centroid seeding</span>
<a name="l00184"></a>00184 <span class="comment">(below example is executed in Verbose mode):</span>
<a name="l00185"></a>00185 <span class="comment">\code</span>
<a name="l00186"></a>00186 <span class="comment">sql&gt; SELECT * FROM madlib.kmeans_plusplus(</span>
<a name="l00187"></a>00187 <span class="comment">    &#39;km_sample&#39;, &#39;coords&#39;, null,</span>
<a name="l00188"></a>00188 <span class="comment">    &#39;km_p&#39;, &#39;km_c&#39;,</span>
<a name="l00189"></a>00189 <span class="comment">    &#39;l2norm&#39;,</span>
<a name="l00190"></a>00190 <span class="comment">    10, 0.001,</span>
<a name="l00191"></a>00191 <span class="comment">    True, True,</span>
<a name="l00192"></a>00192 <span class="comment">    10, null</span>
<a name="l00193"></a>00193 <span class="comment">);</span>
<a name="l00194"></a>00194 <span class="comment">INFO:  (&#39;Started k-means clustering with parameters:&#39;,)</span>
<a name="l00195"></a>00195 <span class="comment">INFO:  (&#39; * src_relation = public.km_sample&#39;,)</span>
<a name="l00196"></a>00196 <span class="comment">INFO:  (&#39; * src_col_data = coords&#39;,)</span>
<a name="l00197"></a>00197 <span class="comment">INFO:  (&#39; * src_col_id = None (will be auto-generated)&#39;,)</span>
<a name="l00198"></a>00198 <span class="comment">INFO:  (&#39; * init_method = kmeans++ (sample=0.01)&#39;,)</span>
<a name="l00199"></a>00199 <span class="comment">INFO:  (&#39; * initial k = 10&#39;,)</span>
<a name="l00200"></a>00200 <span class="comment">INFO:  (&#39; * dist_metric = l2norm&#39;,)</span>
<a name="l00201"></a>00201 <span class="comment">INFO:  (&#39; * evaluate = True (model coefficient evaluation)&#39;,)</span>
<a name="l00202"></a>00202 <span class="comment">INFO:  (&#39; * output_points = public.km_p&#39;,)</span>
<a name="l00203"></a>00203 <span class="comment">INFO:  (&#39; * output_centroids = public.km_c&#39;,)</span>
<a name="l00204"></a>00204 <span class="comment">INFO:  (&#39; * verbose = True&#39;,)</span>
<a name="l00205"></a>00205 <span class="comment">INFO:  (&#39;Input:&#39;,)</span>
<a name="l00206"></a>00206 <span class="comment">INFO:  (&#39;... analyzing data points&#39;,)</span>
<a name="l00207"></a>00207 <span class="comment">INFO:  (&#39; * points: 10000 (2 dimensions), kept 10000 after removing NULLs&#39;,)</span>
<a name="l00208"></a>00208 <span class="comment">INFO:  (&#39;... generating initial centroids&#39;,)</span>
<a name="l00209"></a>00209 <span class="comment">INFO:  (&#39; * centroids: 10 seeded using kmeans++ (0.351 sec)&#39;,)</span>
<a name="l00210"></a>00210 <span class="comment">INFO:  (&#39;Execution:&#39;,)</span>
<a name="l00211"></a>00211 <span class="comment">INFO:  (&#39;... Iteration 1: updated 10000 points (0.212 sec)&#39;,)</span>
<a name="l00212"></a>00212 <span class="comment">INFO:  (&#39;... Iteration 2: updated 136 points (0.399 sec)&#39;,)</span>
<a name="l00213"></a>00213 <span class="comment">INFO:  (&#39;... Iteration 3: updated 74 points (0.2 sec)&#39;,)</span>
<a name="l00214"></a>00214 <span class="comment">INFO:  (&#39;... Iteration 4: updated 58 points (0.28 sec)&#39;,)</span>
<a name="l00215"></a>00215 <span class="comment">INFO:  (&#39;... Iteration 5: updated 66 points (0.261 sec)&#39;,)</span>
<a name="l00216"></a>00216 <span class="comment">INFO:  (&#39;... Iteration 6: updated 51 points (0.248 sec)&#39;,)</span>
<a name="l00217"></a>00217 <span class="comment">INFO:  (&#39;... Iteration 7: updated 36 points (0.257 sec)&#39;,)</span>
<a name="l00218"></a>00218 <span class="comment">INFO:  (&#39;... Iteration 8: updated 23 points (0.255 sec)&#39;,)</span>
<a name="l00219"></a>00219 <span class="comment">INFO:  (&#39;... Iteration 9: updated 21 points (0.31 sec)&#39;,)</span>
<a name="l00220"></a>00220 <span class="comment">INFO:  (&#39;... Iteration 10: updated 13 points (0.25 sec)&#39;,)</span>
<a name="l00221"></a>00221 <span class="comment">INFO:  (&#39;Exit condition: reached maximum number of iterations = 10&#39;,)</span>
<a name="l00222"></a>00222 <span class="comment">INFO:  (&#39;Writing final output table: public.km_p...&#39;,)</span>
<a name="l00223"></a>00223 <span class="comment">INFO:  (&#39;... 0.033 sec&#39;,)</span>
<a name="l00224"></a>00224 <span class="comment">INFO:  (&#39;Calculating model cost function and simplified Silhouette coefficient...&#39;,)</span>
<a name="l00225"></a>00225 <span class="comment">INFO:  (&#39;... 0.121 sec&#39;,)</span>
<a name="l00226"></a>00226 <span class="comment">-[ RECORD 1 ]-+-----------------</span>
<a name="l00227"></a>00227 <span class="comment">src_relation  | km_sample</span>
<a name="l00228"></a>00228 <span class="comment">point_count   | 10000</span>
<a name="l00229"></a>00229 <span class="comment">init_method   | kmeans++</span>
<a name="l00230"></a>00230 <span class="comment">k             | 10</span>
<a name="l00231"></a>00231 <span class="comment">dist_metric   | l2norm</span>
<a name="l00232"></a>00232 <span class="comment">iterations    | 10</span>
<a name="l00233"></a>00233 <span class="comment">cost_func     | 36424.9019377</span>
<a name="l00234"></a>00234 <span class="comment">silhouette    | 0.710664950775</span>
<a name="l00235"></a>00235 <span class="comment">out_points    | km_p</span>
<a name="l00236"></a>00236 <span class="comment">out_centorids | km_c</span>
<a name="l00237"></a>00237 <span class="comment">\endcode</span>
<a name="l00238"></a>00238 <span class="comment"></span>
<a name="l00239"></a>00239 <span class="comment">@literature</span>
<a name="l00240"></a>00240 <span class="comment"></span>
<a name="l00241"></a>00241 <span class="comment">[1] Wikipedia, K-means Clustering,</span>
<a name="l00242"></a>00242 <span class="comment">    http://en.wikipedia.org/wiki/K-means_clustering</span>
<a name="l00243"></a>00243 <span class="comment"></span>
<a name="l00244"></a>00244 <span class="comment">[2] David Arthur, Sergei Vassilvitskii: k-means++: the advantages of careful</span>
<a name="l00245"></a>00245 <span class="comment">    seeding, Proceedings of the 18th Annual ACM-SIAM Symposium on Discrete</span>
<a name="l00246"></a>00246 <span class="comment">    Algorithms (SODA&#39;07), pp. 1027-1035,</span>
<a name="l00247"></a>00247 <span class="comment">    http://www.stanford.edu/~darthur/kMeansPlusPlus.pdf</span>
<a name="l00248"></a>00248 <span class="comment"></span>
<a name="l00249"></a>00249 <span class="comment">[3] E. R. Hruschka, L. N. C. Silva, R. J. G. B. Campello: Clustering</span>
<a name="l00250"></a>00250 <span class="comment">    Gene-Expression Data: A Hybrid Approach that Iterates Between k-Means and</span>
<a name="l00251"></a>00251 <span class="comment">    Evolutionary Search. In: Studies in Computational Intelligence - Hybrid</span>
<a name="l00252"></a>00252 <span class="comment">    Evolutionary Algorithms. pp. 313-335. Springer. 2007.</span>
<a name="l00253"></a>00253 <span class="comment"></span>
<a name="l00254"></a>00254 <span class="comment">[4] Lloyd, Stuart: Least squares quantization in PCM. Technical Note, Bell</span>
<a name="l00255"></a>00255 <span class="comment">    Laboratories. Published much later in: IEEE Transactions on Information</span>
<a name="l00256"></a>00256 <span class="comment">    Theory 28(2), pp. 128-137. 1982.</span>
<a name="l00257"></a>00257 <span class="comment"></span>
<a name="l00258"></a>00258 <span class="comment">@sa File kmeans_new.sql_in documenting the SQL functions.</span>
<a name="l00259"></a>00259 <span class="comment"></span>
<a name="l00260"></a>00260 <span class="comment">@internal</span>
<a name="l00261"></a>00261 <span class="comment">@sa namespace kmeans_new (documenting the implementation in Python)</span>
<a name="l00262"></a>00262 <span class="comment">@endinternal</span>
<a name="l00263"></a>00263 <span class="comment">*/</span>
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 /*
<a name="l00266"></a>00266  * @brief k-Means return type
<a name="l00267"></a>00267  *
<a name="l00268"></a>00268  * A composite value:
<a name="l00269"></a>00269  *  - &lt;tt&gt;centroids&lt;/tt&gt; - Matrix containing the new \f$ l \leq k \f$
<a name="l00270"></a>00270  *    repositioned centroids as columns. If this matrix has \f$ l &lt; k \f$
<a name="l00271"></a>00271  *    columns, one or more old centroids no longer were closest to any point.
<a name="l00272"></a>00272  *  - &lt;tt&gt;old_centroid_its&lt;/tt&gt; - The order of the centroids in
<a name="l00273"></a>00273  *    &lt;tt&gt;centroid&lt;/tt&gt; is not guaranteed to be consitent across iterations.
<a name="l00274"></a>00274  *    In particular, if a centroid is no longer closest to any point it can be
<a name="l00275"></a>00275  *    dropped and a new centroid is added afterwards. We therefore need to map
<a name="l00276"></a>00276  *    positions in &lt;tt&gt;centroids&lt;/tt&gt; to the respective positions in the
<a name="l00277"></a>00277  *    previous iteration.
<a name="l00278"></a>00278  *  - &lt;tt&gt;objective_fn&lt;/tt&gt; - Value of the objective function, i.e.,
<a name="l00279"></a>00279  *    \f$ \sum_{x \in P} \dist(x, C)^2 \f$ where
<a name="l00280"></a>00280  *    \f$ P \f$ is the set of points, \f$ C \f$ is the set of centroids, and
<a name="l00281"></a>00281  *    \f$ \dist(x, C) := \min_{c \in C} \operatorname{dist}(x, c) \f$.
<a name="l00282"></a>00282  *  - &lt;tt&gt;frac_reassigned&lt;/tt&gt; - Fraction of points that was assigned a
<a name="l00283"></a>00283  *    different centroid in the current iteration.
<a name="l00284"></a>00284  *  - &lt;tt&gt;num_iterations&lt;/tt&gt; - Number of iterations performed (so far).
<a name="l00285"></a>00285  */
<a name="l00286"></a>00286 CREATE TYPE MADLIB_SCHEMA.kmeans_new_result AS (
<a name="l00287"></a>00287     centroids DOUBLE PRECISION[][],
<a name="l00288"></a>00288     objective_fn DOUBLE PRECISION,
<a name="l00289"></a>00289     frac_reassigned DOUBLE PRECISION,
<a name="l00290"></a>00290     num_iterations INTEGER
<a name="l00291"></a>00291 );
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 /*
<a name="l00294"></a>00294  * @brief k-Means inter-iteration state type
<a name="l00295"></a>00295  *
<a name="l00296"></a>00296  * A composite value like \ref{kmeans_new_result}. Additional fields:
<a name="l00297"></a>00297  *  - &lt;tt&gt;old_centroid_its&lt;/tt&gt; - The order of the centroids in
<a name="l00298"></a>00298  *    &lt;tt&gt;centroid&lt;/tt&gt; is not guaranteed to be consitent across iterations.
<a name="l00299"></a>00299  *    In particular, if a centroid is no longer closest to any point it can be
<a name="l00300"></a>00300  *    dropped and a new centroid is added afterwards. We therefore need to map
<a name="l00301"></a>00301  *    positions in &lt;tt&gt;centroids&lt;/tt&gt; to the respective positions in the
<a name="l00302"></a>00302  *    previous iteration.
<a name="l00303"></a>00303  *  - &lt;tt&gt;num_iterations&lt;/tt&gt; - Number of iterations performed (so far).
<a name="l00304"></a>00304  */
<a name="l00305"></a>00305 CREATE TYPE MADLIB_SCHEMA.kmeans_new_state AS (
<a name="l00306"></a>00306     centroids DOUBLE PRECISION[][],
<a name="l00307"></a>00307     old_centroid_ids INTEGER[],
<a name="l00308"></a>00308     objective_fn DOUBLE PRECISION,
<a name="l00309"></a>00309     frac_reassigned DOUBLE PRECISION
<a name="l00310"></a>00310 );
<a name="l00311"></a>00311 <span class="comment"></span>
<a name="l00312"></a>00312 <span class="comment">/**</span>
<a name="l00313"></a>00313 <span class="comment"> * @internal</span>
<a name="l00314"></a>00314 <span class="comment"> * @brief Check if expr_point is valid type and return useful error msg</span>
<a name="l00315"></a>00315 <span class="comment"> */</span>
<a name="l00316"></a>00316 CREATE FUNCTION MADLIB_SCHEMA.kmeans_is_valid_input(
<a name="l00317"></a>00317     rel_source VARCHAR,
<a name="l00318"></a>00318     expr_point VARCHAR
<a name="l00319"></a>00319 ) RETURNS boolean AS $$ 
<a name="l00320"></a>00320 BEGIN 
<a name="l00321"></a>00321     EXECUTE &#39;SELECT <span class="stringliteral">&#39; || expr_point || &#39;</span>::FLOAT8[] FROM <span class="stringliteral">&#39; || textin(regclassout(rel_source)); </span>
<a name="l00322"></a>00322 <span class="stringliteral">    RETURN TRUE;</span>
<a name="l00323"></a>00323 <span class="stringliteral">EXCEPTION</span>
<a name="l00324"></a>00324 <span class="stringliteral">    WHEN invalid_schema_name THEN</span>
<a name="l00325"></a>00325 <span class="stringliteral">    RAISE EXCEPTION &#39;</span>Schema (%) does not exist.<span class="stringliteral">&#39;, split_part(rel_source, &#39;</span>.<span class="stringliteral">&#39;, 1);</span>
<a name="l00326"></a>00326 <span class="stringliteral">    WHEN undefined_table THEN</span>
<a name="l00327"></a>00327 <span class="stringliteral">    RAISE EXCEPTION &#39;</span>Source table does not exist.<span class="stringliteral">&#39;;</span>
<a name="l00328"></a>00328 <span class="stringliteral">    WHEN OTHERS THEN</span>
<a name="l00329"></a>00329 <span class="stringliteral">    RAISE EXCEPTION &#39;</span>Point coordinates (%) are not a valid type (SVEC, FLOAT[], or INTEGER[]) or <span class="keywordflow">do</span> not exist.<span class="stringliteral">&#39;, expr_point; </span>
<a name="l00330"></a>00330 <span class="stringliteral">END; </span>
<a name="l00331"></a>00331 <span class="stringliteral">$$ LANGUAGE plpgsql VOLATILE; </span>
<a name="l00332"></a>00332 <span class="stringliteral"></span><span class="comment"></span>
<a name="l00333"></a>00333 <span class="comment">/**</span>
<a name="l00334"></a>00334 <span class="comment"> * @internal</span>
<a name="l00335"></a>00335 <span class="comment"> * @brief Execute a SQL command where $1, ..., $4 are substituted with the</span>
<a name="l00336"></a>00336 <span class="comment">  *     given arguments.</span>
<a name="l00337"></a>00337 <span class="comment"> */</span>
<a name="l00338"></a>00338 CREATE FUNCTION MADLIB_SCHEMA.internal_execute_using_kmeans_args(
<a name="l00339"></a>00339     sql VARCHAR, DOUBLE PRECISION[][], REGPROC, INTEGER, DOUBLE PRECISION
<a name="l00340"></a>00340 ) RETURNS VOID
<a name="l00341"></a>00341 VOLATILE
<a name="l00342"></a>00342 CALLED ON NULL INPUT
<a name="l00343"></a>00343 LANGUAGE c
<a name="l00344"></a>00344 AS &#39;MODULE_PATHNAME<span class="stringliteral">&#39;, &#39;</span>exec_sql_using<span class="stringliteral">&#39;;</span>
<a name="l00345"></a>00345 <span class="stringliteral"></span>
<a name="l00346"></a>00346 <span class="stringliteral">CREATE FUNCTION MADLIB_SCHEMA.internal_compute_kmeans(</span>
<a name="l00347"></a>00347 <span class="stringliteral">    rel_args VARCHAR,</span>
<a name="l00348"></a>00348 <span class="stringliteral">    rel_state VARCHAR,</span>
<a name="l00349"></a>00349 <span class="stringliteral">    rel_source VARCHAR,</span>
<a name="l00350"></a>00350 <span class="stringliteral">    expr_point VARCHAR,</span>
<a name="l00351"></a>00351 <span class="stringliteral">    agg_centroid VARCHAR)</span>
<a name="l00352"></a>00352 <span class="stringliteral">RETURNS INTEGER</span>
<a name="l00353"></a>00353 <span class="stringliteral">VOLATILE</span>
<a name="l00354"></a>00354 <span class="stringliteral">LANGUAGE plpythonu</span>
<a name="l00355"></a>00355 <span class="stringliteral">AS $$PythonFunction(kmeans_new, kmeans_new, compute_kmeans)$$;</span>
<a name="l00356"></a>00356 <span class="stringliteral"></span><span class="comment"></span>
<a name="l00357"></a>00357 <span class="comment">/**</span>
<a name="l00358"></a>00358 <span class="comment"> * @brief Perform Lloyd&#39;s k-means local-search heuristic</span>
<a name="l00359"></a>00359 <span class="comment"> *</span>
<a name="l00360"></a>00360 <span class="comment"> * @param rel_source Name of the relation containing input points</span>
<a name="l00361"></a>00361 <span class="comment"> * @param expr_point Expression evaluating to point coordinates for each tuple</span>
<a name="l00362"></a>00362 <span class="comment"> * @param initial_centroids Matrix containing the initial centroids as columns</span>
<a name="l00363"></a>00363 <span class="comment"> * @param fn_dist Name of a function with signature</span>
<a name="l00364"></a>00364 <span class="comment"> *     &lt;tt&gt;DOUBLE PRECISION[] x DOUBLE PRECISION[] -&gt; DOUBLE PRECISION&lt;/tt&gt; that</span>
<a name="l00365"></a>00365 <span class="comment"> *     returns the distance between two points. The default is the</span>
<a name="l00366"></a>00366 <span class="comment"> *     \ref squared_dist_norm2(float8[],float8[]) &quot;squared Euclidean distance&quot;.</span>
<a name="l00367"></a>00367 <span class="comment"> * @param agg_centroid Name of an aggregate function with signature</span>
<a name="l00368"></a>00368 <span class="comment"> *     &lt;tt&gt;DOUBLE PRECISION[] -&gt; DOUBLE PRECISION[]&lt;/tt&gt; that, for each group</span>
<a name="l00369"></a>00369 <span class="comment"> *     of points, returns a centroid. In order for Lloyd&#39;s local-search</span>
<a name="l00370"></a>00370 <span class="comment"> *     heuristic to provably converge and to return a local minimum, this</span>
<a name="l00371"></a>00371 <span class="comment"> *     centroid should minimize the sum of distances between each point in the</span>
<a name="l00372"></a>00372 <span class="comment"> *     group and the centroid. The default is the</span>
<a name="l00373"></a>00373 <span class="comment"> *     \ref avg(float8[]) &quot;average (mean/barycenter in Euclidean space)&quot;,</span>
<a name="l00374"></a>00374 <span class="comment"> *     which satisfies this property if &lt;tt&gt;fn_dist = &#39;squared_dist_norm2&#39;&lt;/tt&gt;.</span>
<a name="l00375"></a>00375 <span class="comment"> * @param max_num_iterations Maximum number of iterations</span>
<a name="l00376"></a>00376 <span class="comment"> * @param min_frac_reassigned Fraction of reassigned points below which</span>
<a name="l00377"></a>00377 <span class="comment"> *     convergence is assumed and the algorithm terminates</span>
<a name="l00378"></a>00378 <span class="comment"> * @returns A composite value:</span>
<a name="l00379"></a>00379 <span class="comment"> *  - &lt;tt&gt;centroids&lt;/tt&gt; - Matrix with \f$ k \f$ centroids as columns.</span>
<a name="l00380"></a>00380 <span class="comment"> *  - &lt;tt&gt;frac_reassigned&lt;/tt&gt; - Fraction of points that were assigned a</span>
<a name="l00381"></a>00381 <span class="comment"> *    different centroid in the last iteration.</span>
<a name="l00382"></a>00382 <span class="comment"> *  - &lt;tt&gt;num_iterations&lt;/tt&gt; - The number of iterations before the</span>
<a name="l00383"></a>00383 <span class="comment"> *    algorithm terminated</span>
<a name="l00384"></a>00384 <span class="comment"> */</span>
<a name="l00385"></a>00385 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l00386"></a>00386     rel_source VARCHAR,
<a name="l00387"></a>00387     expr_point VARCHAR,
<a name="l00388"></a>00388     initial_centroids DOUBLE PRECISION[][],
<a name="l00389"></a>00389     fn_dist VARCHAR /*+ DEFAULT &#39;<a class="code" href="linalg_8sql__in.html#a00a08e69f27524f2096032214e15b668" title="Squared 2-norm of the difference between two vectors.">squared_dist_norm2</a><span class="stringliteral">&#39; */,</span>
<a name="l00390"></a>00390 <span class="stringliteral">    agg_centroid VARCHAR /*+ DEFAULT &#39;</span><a class="code" href="linalg_8sql__in.html#a1aa37f73fb1cd8d7d106aa518dd8c0b4" title="Compute the average of vectors.">avg</a><span class="stringliteral">&#39; */,</span>
<a name="l00391"></a>00391 <span class="stringliteral">    max_num_iterations INTEGER /*+ DEFAULT 20 */,</span>
<a name="l00392"></a>00392 <span class="stringliteral">    min_frac_reassigned DOUBLE PRECISION /*+ DEFAULT 0.001 */</span>
<a name="l00393"></a>00393 <span class="stringliteral">) RETURNS MADLIB_SCHEMA.kmeans_new_result AS $$</span>
<a name="l00394"></a>00394 <span class="stringliteral">DECLARE</span>
<a name="l00395"></a>00395 <span class="stringliteral">    theIteration INTEGER;</span>
<a name="l00396"></a>00396 <span class="stringliteral">    theResult MADLIB_SCHEMA.kmeans_new_result;</span>
<a name="l00397"></a>00397 <span class="stringliteral">    oldClientMinMessages VARCHAR;</span>
<a name="l00398"></a>00398 <span class="stringliteral">    class_rel_source REGCLASS;</span>
<a name="l00399"></a>00399 <span class="stringliteral">    proc_fn_dist REGPROCEDURE;</span>
<a name="l00400"></a>00400 <span class="stringliteral">    proc_agg_centroid REGPROCEDURE;</span>
<a name="l00401"></a>00401 <span class="stringliteral">    rel_filtered VARCHAR;</span>
<a name="l00402"></a>00402 <span class="stringliteral">    num_points INTEGER;</span>
<a name="l00403"></a>00403 <span class="stringliteral">    k INTEGER;</span>
<a name="l00404"></a>00404 <span class="stringliteral">    centroids FLOAT8[];</span>
<a name="l00405"></a>00405 <span class="stringliteral">BEGIN</span>
<a name="l00406"></a>00406 <span class="stringliteral">    IF (array_upper(initial_centroids,1) IS NULL) THEN</span>
<a name="l00407"></a><a class="code" href="kmeans__new_8sql__in.html#ab01b44e0003c3c6de2560ea7bf76fb4a">00407</a> <span class="stringliteral">    RAISE EXCEPTION &#39;</span>No valid initial centroids given.<span class="stringliteral">&#39;;</span>
<a name="l00408"></a>00408 <span class="stringliteral">    END IF;</span>
<a name="l00409"></a>00409 <span class="stringliteral"></span>
<a name="l00410"></a>00410 <span class="stringliteral">    centroids := ARRAY(SELECT unnest(initial_centroids));</span>
<a name="l00411"></a>00411 <span class="stringliteral">    IF (SELECT MADLIB_SCHEMA.svec_elsum(centroids)) &gt;= &#39;</span>Infinity<span class="stringliteral">&#39;::float THEN</span>
<a name="l00412"></a>00412 <span class="stringliteral">        RAISE EXCEPTION &#39;</span>At least one initial centroid has non-finite values.<span class="stringliteral">&#39;;</span>
<a name="l00413"></a>00413 <span class="stringliteral">    END IF;</span>
<a name="l00414"></a>00414 <span class="stringliteral"></span>
<a name="l00415"></a>00415 <span class="stringliteral">    PERFORM MADLIB_SCHEMA.kmeans_is_valid_input(rel_source, expr_point);</span>
<a name="l00416"></a>00416 <span class="stringliteral"> </span>
<a name="l00417"></a>00417 <span class="stringliteral">    rel_filtered = MADLIB_SCHEMA.__filter_input_relation(rel_source, expr_point);</span>
<a name="l00418"></a>00418 <span class="stringliteral">    class_rel_source := rel_filtered;</span>
<a name="l00419"></a>00419 <span class="stringliteral">    proc_fn_dist := fn_dist</span>
<a name="l00420"></a>00420 <span class="stringliteral">        || &#39;</span>(DOUBLE PRECISION[], DOUBLE PRECISION[])<span class="stringliteral">&#39;;</span>
<a name="l00421"></a>00421 <span class="stringliteral">    IF (SELECT prorettype != &#39;</span>DOUBLE PRECISION<span class="stringliteral">&#39;::regtype OR proisagg = TRUE</span>
<a name="l00422"></a>00422 <span class="stringliteral">        FROM pg_proc WHERE oid = proc_fn_dist) THEN</span>
<a name="l00423"></a>00423 <span class="stringliteral">        RAISE EXCEPTION &#39;</span>Distance <span class="keyword">function</span> has wrong signature or is not a simple <span class="keyword">function</span>.<span class="stringliteral">&#39;;</span>
<a name="l00424"></a>00424 <span class="stringliteral">    END IF;</span>
<a name="l00425"></a>00425 <span class="stringliteral">    proc_agg_centroid := agg_centroid || &#39;</span>(DOUBLE PRECISION[])<span class="stringliteral">&#39;;</span>
<a name="l00426"></a>00426 <span class="stringliteral">    IF (SELECT prorettype != &#39;</span>DOUBLE PRECISION[]<span class="stringliteral">&#39;::regtype OR proisagg = FALSE</span>
<a name="l00427"></a>00427 <span class="stringliteral">        FROM pg_proc WHERE oid = proc_agg_centroid) THEN</span>
<a name="l00428"></a>00428 <span class="stringliteral">        RAISE EXCEPTION &#39;</span>Mean aggregate has wrong signature or is not an aggregate.<span class="stringliteral">&#39;;</span>
<a name="l00429"></a>00429 <span class="stringliteral">    END IF;</span>
<a name="l00430"></a>00430 <span class="stringliteral">    IF (min_frac_reassigned &lt; 0) OR (min_frac_reassigned &gt; 1) THEN</span>
<a name="l00431"></a>00431 <span class="stringliteral">        RAISE EXCEPTION &#39;</span>Convergence threshold is not a valid value (must be a fraction between 0 and 1).<span class="stringliteral">&#39;;</span>
<a name="l00432"></a>00432 <span class="stringliteral">    END IF;</span>
<a name="l00433"></a>00433 <span class="stringliteral">    IF (max_num_iterations &lt; 0) THEN</span>
<a name="l00434"></a>00434 <span class="stringliteral">        RAISE EXCEPTION &#39;</span>Number of iterations must be a non-negative integer.<span class="stringliteral">&#39;;</span>
<a name="l00435"></a>00435 <span class="stringliteral">    END IF;</span>
<a name="l00436"></a>00436 <span class="stringliteral">  </span>
<a name="l00437"></a>00437 <span class="stringliteral">    -- Extra parameter check added so that ERROR output is more user-readable (doesn&#39;</span>t include Python traceback) 
<a name="l00438"></a>00438     k := array_upper(initial_centroids,1);
<a name="l00439"></a>00439     IF (k &lt;= 0) THEN
<a name="l00440"></a>00440         RAISE EXCEPTION &#39;Number of clusters k must be a positive integer.&#39;;
<a name="l00441"></a>00441     END IF;
<a name="l00442"></a>00442     IF (k &gt; 32767) THEN
<a name="l00443"></a>00443     RAISE EXCEPTION &#39;Number of clusters k must be &lt;= 32767 (for results to be returned in a reasonable amount of time).&#39;;
<a name="l00444"></a>00444     END IF;
<a name="l00445"></a>00445     EXECUTE $sql$ SELECT count(*) FROM $sql$ || textin(regclassout(class_rel_source)) INTO num_points ;
<a name="l00446"></a>00446     IF (num_points &lt; k) THEN
<a name="l00447"></a>00447     RAISE EXCEPTION &#39;Number of centroids is greater than number of points.&#39;;
<a name="l00448"></a>00448     END IF;
<a name="l00449"></a>00449  
<a name="l00450"></a>00450     -- We first setup the argument table. Rationale: We want to avoid all data
<a name="l00451"></a>00451     -- conversion between native types and Python code. Instead, we use Python
<a name="l00452"></a>00452     -- as a pure driver layer.
<a name="l00453"></a>00453     PERFORM MADLIB_SCHEMA.<a class="code" href="utilities_8sql__in.html#a56501b6f9fabe65d7a6a6beb70a0e000" title="Create the temporary schema if it does not exist yet.">create_schema_pg_temp</a>();
<a name="l00454"></a>00454     oldClientMinMessages :=
<a name="l00455"></a>00455         (SELECT setting FROM pg_settings WHERE name = &#39;client_min_messages&#39;);
<a name="l00456"></a>00456     EXECUTE &#39;SET client_min_messages TO warning&#39;;
<a name="l00457"></a>00457    
<a name="l00458"></a>00458     -- Unfortunately, the EXECUTE USING syntax is only available starting
<a name="l00459"></a>00459     -- PostgreSQL 8.4:
<a name="l00460"></a>00460     -- http:<span class="comment">//www.postgresql.org/docs/8.4/static/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN</span>
<a name="l00461"></a>00461     -- We therefore have to emulate.
<a name="l00462"></a>00462     PERFORM MADLIB_SCHEMA.internal_execute_using_kmeans_args($sql$
<a name="l00463"></a>00463         DROP TABLE IF EXISTS pg_temp._madlib_kmeans_args;
<a name="l00464"></a>00464         CREATE TABLE pg_temp._madlib_kmeans_args AS
<a name="l00465"></a>00465         SELECT
<a name="l00466"></a>00466             $1 AS initial_centroids, array_upper($1, 1) AS k,
<a name="l00467"></a>00467             $2 AS fn_dist, $3 AS max_num_iterations,
<a name="l00468"></a>00468             $4 AS min_frac_reassigned;
<a name="l00469"></a>00469         $sql$,
<a name="l00470"></a>00470         initial_centroids, proc_fn_dist, max_num_iterations,
<a name="l00471"></a>00471         min_frac_reassigned);
<a name="l00472"></a>00472     EXECUTE &#39;SET client_min_messages TO &#39; || oldClientMinMessages;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474     -- Perform acutal computation.
<a name="l00475"></a>00475     -- Unfortunately, Greenplum and PostgreSQL &lt;= 8.2 do not have conversion
<a name="l00476"></a>00476     -- operators from regclass to varchar/text.
<a name="l00477"></a>00477     theIteration := MADLIB_SCHEMA.internal_compute_kmeans(&#39;_madlib_kmeans_args&#39;,
<a name="l00478"></a>00478             &#39;_madlib_kmeans_state&#39;,
<a name="l00479"></a>00479             textin(regclassout(class_rel_source)), expr_point,
<a name="l00480"></a>00480             textin(regprocout(proc_agg_centroid)));
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     -- Retrieve result from state table and return it
<a name="l00483"></a>00483     EXECUTE
<a name="l00484"></a>00484         $sql$
<a name="l00485"></a>00485         SELECT (_state).centroids, (_state).objective_fn,
<a name="l00486"></a>00486             (_state).frac_reassigned, NULL
<a name="l00487"></a>00487         FROM _madlib_kmeans_state
<a name="l00488"></a>00488         WHERE _iteration = $sql$ || theIteration || $sql$
<a name="l00489"></a>00489         $sql$
<a name="l00490"></a>00490         INTO theResult;
<a name="l00491"></a>00491     -- The number of iterations are not updated in the C++ code. We do it here.
<a name="l00492"></a>00492     IF NOT (theResult IS NULL) THEN
<a name="l00493"></a>00493         theResult.num_iterations = theIteration;
<a name="l00494"></a>00494     END IF;
<a name="l00495"></a>00495     RETURN theResult;
<a name="l00496"></a>00496 END;
<a name="l00497"></a>00497 $$ LANGUAGE plpgsql VOLATILE;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#ab01b44e0003c3c6de2560ea7bf76fb4a" title="Perform Lloyd&#39;s k-means local-search heuristic.">kmeans</a>(
<a name="l00500"></a>00500     rel_source VARCHAR,
<a name="l00501"></a>00501     expr_point VARCHAR,
<a name="l00502"></a>00502     initial_centroids DOUBLE PRECISION[][],
<a name="l00503"></a>00503     fn_dist VARCHAR,
<a name="l00504"></a>00504     agg_centroid VARCHAR,
<a name="l00505"></a>00505     max_num_iterations INTEGER
<a name="l00506"></a>00506 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00507"></a>00507 VOLATILE
<a name="l00508"></a>00508 STRICT
<a name="l00509"></a>00509 LANGUAGE sql AS $$
<a name="l00510"></a>00510     SELECT MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#ab01b44e0003c3c6de2560ea7bf76fb4a" title="Perform Lloyd&#39;s k-means local-search heuristic.">kmeans</a>($1, $2, $3, $4, $5, $6, 0.001)
<a name="l00511"></a>00511 $$;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l00514"></a>00514     rel_source VARCHAR,
<a name="l00515"></a>00515     expr_point VARCHAR,
<a name="l00516"></a>00516     initial_centroids DOUBLE PRECISION[][],
<a name="l00517"></a>00517     fn_dist VARCHAR,
<a name="l00518"></a>00518     agg_centroid VARCHAR
<a name="l00519"></a>00519 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00520"></a>00520 VOLATILE
<a name="l00521"></a>00521 STRICT
<a name="l00522"></a>00522 LANGUAGE sql AS $$
<a name="l00523"></a>00523     SELECT MADLIB_SCHEMA.kmeans($1, $2, $3, $4, $5, 20, 0.001)
<a name="l00524"></a>00524 $$;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l00527"></a>00527     rel_source VARCHAR,
<a name="l00528"></a>00528     expr_point VARCHAR,
<a name="l00529"></a>00529     initial_centroids DOUBLE PRECISION[][],
<a name="l00530"></a>00530     fn_dist VARCHAR
<a name="l00531"></a>00531 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00532"></a>00532 VOLATILE
<a name="l00533"></a>00533 STRICT
<a name="l00534"></a>00534 LANGUAGE sql AS $$
<a name="l00535"></a>00535     SELECT MADLIB_SCHEMA.kmeans($1, $2, $3, $4, &#39;MADLIB_SCHEMA.<a class="code" href="linalg_8sql__in.html#a1aa37f73fb1cd8d7d106aa518dd8c0b4" title="Compute the average of vectors.">avg</a>&#39;, 20,
<a name="l00536"></a>00536         0.001)
<a name="l00537"></a>00537 $$;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l00540"></a>00540     rel_source VARCHAR,
<a name="l00541"></a>00541     expr_point VARCHAR,
<a name="l00542"></a>00542     initial_centroids DOUBLE PRECISION[][]
<a name="l00543"></a>00543 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00544"></a>00544 VOLATILE
<a name="l00545"></a>00545 STRICT
<a name="l00546"></a>00546 LANGUAGE sql AS $$
<a name="l00547"></a>00547     SELECT MADLIB_SCHEMA.kmeans($1, $2, $3,
<a name="l00548"></a>00548         &#39;MADLIB_SCHEMA.<a class="code" href="linalg_8sql__in.html#a00a08e69f27524f2096032214e15b668" title="Squared 2-norm of the difference between two vectors.">squared_dist_norm2</a>&#39;, &#39;MADLIB_SCHEMA.avg&#39;, 20, 0.001)
<a name="l00549"></a>00549 $$;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 CREATE FUNCTION MADLIB_SCHEMA.internal_execute_using_kmeanspp_seeding_args(
<a name="l00552"></a>00552     sql VARCHAR, INTEGER, REGPROC, DOUBLE PRECISION[][]
<a name="l00553"></a>00553 ) RETURNS VOID
<a name="l00554"></a>00554 VOLATILE
<a name="l00555"></a>00555 CALLED ON NULL INPUT
<a name="l00556"></a>00556 LANGUAGE c
<a name="l00557"></a>00557 AS &#39;MODULE_PATHNAME&#39;, &#39;exec_sql_using&#39;;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 CREATE FUNCTION MADLIB_SCHEMA.internal_compute_kmeanspp_seeding(
<a name="l00560"></a>00560     rel_args VARCHAR,
<a name="l00561"></a>00561     rel_state VARCHAR,
<a name="l00562"></a>00562     rel_source VARCHAR,
<a name="l00563"></a>00563     expr_point VARCHAR)
<a name="l00564"></a>00564 RETURNS INTEGER
<a name="l00565"></a>00565 AS $$PythonFunction(kmeans_new, kmeans_new, compute_kmeanspp_seeding)$$
<a name="l00566"></a>00566 LANGUAGE plpythonu VOLATILE;
<a name="l00567"></a>00567 <span class="comment"></span>
<a name="l00568"></a>00568 <span class="comment">/**</span>
<a name="l00569"></a>00569 <span class="comment"> * @brief k-Means++ Seeding</span>
<a name="l00570"></a>00570 <span class="comment"> *</span>
<a name="l00571"></a>00571 <span class="comment"> * @param rel_source Name of the relation containing input points</span>
<a name="l00572"></a>00572 <span class="comment"> * @param expr_point Expression evaluating to point coordinates for each tuple</span>
<a name="l00573"></a>00573 <span class="comment"> * @param k Number of centroids</span>
<a name="l00574"></a>00574 <span class="comment"> * @param fn_dist Name of a function with signature</span>
<a name="l00575"></a>00575 <span class="comment"> *     &lt;tt&gt;DOUBLE PRECISION[] x DOUBLE PRECISION[] -&gt; DOUBLE PRECISION&lt;/tt&gt; that</span>
<a name="l00576"></a>00576 <span class="comment"> *     returns the distance between two points</span>
<a name="l00577"></a>00577 <span class="comment"> * @param initial_centroids A matrix containing up to \f$ k \f$ columns as</span>
<a name="l00578"></a>00578 <span class="comment"> *     columns. kmeanspp_seeding() proceeds exactly as if these centroids had</span>
<a name="l00579"></a>00579 <span class="comment"> *     already been generated in previous iterations. This parameter may be</span>
<a name="l00580"></a>00580 <span class="comment"> *     NULL in which all \f$ k \f$ centroids will be generated.</span>
<a name="l00581"></a>00581 <span class="comment"> * @returns A matrix containing \f$ k \f$ centroids as columns</span>
<a name="l00582"></a>00582 <span class="comment"> */</span>
<a name="l00583"></a>00583 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#af0d5172211c83d4de4d70a84555aa68e" title="k-Means++ Seeding">kmeanspp_seeding</a>(
<a name="l00584"></a>00584     rel_source VARCHAR,
<a name="l00585"></a>00585     expr_point VARCHAR,
<a name="l00586"></a>00586     k INTEGER,
<a name="l00587"></a>00587     fn_dist VARCHAR <span class="comment">/*+ DEFAULT &#39;squared_dist_norm2&#39; */</span>,
<a name="l00588"></a>00588     initial_centroids DOUBLE PRECISION[][] <span class="comment">/*+ DEFAULT NULL */</span>
<a name="l00589"></a>00589 ) RETURNS DOUBLE PRECISION[][] AS $$
<a name="l00590"></a>00590 DECLARE
<a name="l00591"></a>00591     theIteration INTEGER;
<a name="l00592"></a>00592     theResult DOUBLE PRECISION[][];
<a name="l00593"></a>00593     oldClientMinMessages VARCHAR;
<a name="l00594"></a>00594     class_rel_source REGCLASS;
<a name="l00595"></a>00595     proc_fn_dist REGPROCEDURE;
<a name="l00596"></a>00596     num_points INTEGER;
<a name="l00597"></a>00597     num_centroids INTEGER;
<a name="l00598"></a>00598     rel_filtered VARCHAR;
<a name="l00599"></a>00599 BEGIN
<a name="l00600"></a>00600     PERFORM MADLIB_SCHEMA.kmeans_is_valid_input(rel_source, expr_point);    
<a name="l00601"></a>00601     rel_filtered = MADLIB_SCHEMA.__filter_input_relation(rel_source, expr_point);
<a name="l00602"></a>00602     class_rel_source := rel_filtered;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     IF (initial_centroids IS NOT NULL) THEN
<a name="l00605"></a><a class="code" href="kmeans__new_8sql__in.html#af0d5172211c83d4de4d70a84555aa68e">00605</a>     num_centroids := array_upper(initial_centroids,1);
<a name="l00606"></a>00606     ELSE
<a name="l00607"></a>00607     num_centroids := k;
<a name="l00608"></a>00608     END IF;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610     proc_fn_dist := fn_dist
<a name="l00611"></a>00611         || &#39;(DOUBLE PRECISION[], DOUBLE PRECISION[])&#39;;
<a name="l00612"></a>00612     IF (SELECT prorettype != &#39;DOUBLE PRECISION&#39;::regtype OR proisagg = TRUE
<a name="l00613"></a>00613         FROM pg_proc WHERE oid = proc_fn_dist) THEN
<a name="l00614"></a>00614         RAISE EXCEPTION &#39;Distance function has wrong signature or is not a simple function.&#39;;
<a name="l00615"></a>00615     END IF;
<a name="l00616"></a>00616     IF (k &lt;= 0) THEN
<a name="l00617"></a>00617         RAISE EXCEPTION &#39;Number of clusters k must be a positive integer.&#39;;
<a name="l00618"></a>00618     END IF;
<a name="l00619"></a>00619     IF (k &gt; 32767) THEN
<a name="l00620"></a>00620     RAISE EXCEPTION &#39;Number of clusters k must be &lt;= 32767 (for results to be returned in a reasonable amount of time).&#39;;
<a name="l00621"></a>00621     END IF;
<a name="l00622"></a>00622     EXECUTE $sql$ SELECT count(*) FROM $sql$ || textin(regclassout(class_rel_source)) INTO num_points ;
<a name="l00623"></a>00623     IF (num_points &lt; k OR num_points &lt; num_centroids) THEN
<a name="l00624"></a>00624     RAISE EXCEPTION &#39;Number of centroids is greater than number of points.&#39;;
<a name="l00625"></a>00625     END IF;
<a name="l00626"></a>00626     IF (k &lt; num_centroids) THEN
<a name="l00627"></a>00627     RAISE WARNING &#39;Number of clusters k is less than number of supplied initial centroids. Number of final clusters will equal number of supplied initial centroids.&#39;;
<a name="l00628"></a>00628     END IF;
<a name="l00629"></a>00629     
<a name="l00630"></a>00630     -- We first setup the argument table. Rationale: We want to avoid all data
<a name="l00631"></a>00631     -- conversion between native types and Python code. Instead, we use Python
<a name="l00632"></a>00632     -- as a pure driver layer.
<a name="l00633"></a>00633     oldClientMinMessages :=
<a name="l00634"></a>00634         (SELECT setting FROM pg_settings WHERE name = &#39;client_min_messages&#39;);
<a name="l00635"></a>00635     EXECUTE &#39;SET client_min_messages TO warning&#39;;
<a name="l00636"></a>00636     PERFORM MADLIB_SCHEMA.create_schema_pg_temp();
<a name="l00637"></a>00637     -- Unfortunately, the EXECUTE USING syntax is only available starting
<a name="l00638"></a>00638     -- PostgreSQL 8.4:
<a name="l00639"></a>00639     -- http:<span class="comment">//www.postgresql.org/docs/8.4/static/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN</span>
<a name="l00640"></a>00640     -- We therefore have to emulate.
<a name="l00641"></a>00641     PERFORM MADLIB_SCHEMA.internal_execute_using_kmeanspp_seeding_args($sql$
<a name="l00642"></a>00642         DROP TABLE IF EXISTS pg_temp._madlib_kmeanspp_args;
<a name="l00643"></a>00643         CREATE TEMPORARY TABLE _madlib_kmeanspp_args AS
<a name="l00644"></a>00644         SELECT $1 AS k, $2 AS fn_dist, $3 AS initial_centroids;
<a name="l00645"></a>00645         $sql$,
<a name="l00646"></a>00646         k, proc_fn_dist, initial_centroids);
<a name="l00647"></a>00647     EXECUTE &#39;SET client_min_messages TO &#39; || oldClientMinMessages;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     -- Perform acutal computation.
<a name="l00650"></a>00650     -- Unfortunately, Greenplum and PostgreSQL &lt;= 8.2 do not have conversion
<a name="l00651"></a>00651     -- operators from regclass to varchar/text.
<a name="l00652"></a>00652     theIteration := (
<a name="l00653"></a>00653         SELECT MADLIB_SCHEMA.internal_compute_kmeanspp_seeding(
<a name="l00654"></a>00654             &#39;_madlib_kmeanspp_args&#39;, &#39;_madlib_kmeanspp_state&#39;,
<a name="l00655"></a>00655             textin(regclassout(class_rel_source)), expr_point)
<a name="l00656"></a>00656     );
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     -- Retrieve result from state table and return it
<a name="l00659"></a>00659     EXECUTE
<a name="l00660"></a>00660         $sql$
<a name="l00661"></a>00661         SELECT _state FROM _madlib_kmeanspp_state
<a name="l00662"></a>00662         WHERE _iteration = $sql$ || theIteration || $sql$
<a name="l00663"></a>00663         $sql$
<a name="l00664"></a>00664         INTO theResult;
<a name="l00665"></a>00665     RETURN theResult;
<a name="l00666"></a>00666 END;
<a name="l00667"></a>00667 $$ LANGUAGE plpgsql VOLATILE;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#af0d5172211c83d4de4d70a84555aa68e" title="k-Means++ Seeding">kmeanspp_seeding</a>(
<a name="l00670"></a>00670     rel_source VARCHAR,
<a name="l00671"></a>00671     expr_point VARCHAR,
<a name="l00672"></a>00672     k INTEGER,
<a name="l00673"></a>00673     fn_dist VARCHAR
<a name="l00674"></a>00674 ) RETURNS DOUBLE PRECISION[][]
<a name="l00675"></a>00675 LANGUAGE sql AS $$
<a name="l00676"></a>00676     SELECT MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#af0d5172211c83d4de4d70a84555aa68e" title="k-Means++ Seeding">kmeanspp_seeding</a>($1, $2, $3, $4, NULL)
<a name="l00677"></a>00677 $$;
<a name="l00678"></a>00678 
<a name="l00679"></a>00679 CREATE FUNCTION MADLIB_SCHEMA.kmeanspp_seeding(
<a name="l00680"></a>00680     rel_source VARCHAR,
<a name="l00681"></a>00681     expr_point VARCHAR,
<a name="l00682"></a>00682     k INTEGER
<a name="l00683"></a>00683 ) RETURNS DOUBLE PRECISION[][]
<a name="l00684"></a>00684 LANGUAGE sql AS $$
<a name="l00685"></a>00685     SELECT MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3,
<a name="l00686"></a>00686         &#39;MADLIB_SCHEMA.squared_dist_norm2&#39;, NULL)
<a name="l00687"></a>00687 $$;
<a name="l00688"></a>00688 <span class="comment"></span>
<a name="l00689"></a>00689 <span class="comment">/**</span>
<a name="l00690"></a>00690 <span class="comment"> * @brief Run k-Means++.</span>
<a name="l00691"></a>00691 <span class="comment"> *</span>
<a name="l00692"></a>00692 <span class="comment"> * This is a shortcut for running k-means++. It is equivalent to</span>
<a name="l00693"></a>00693 <span class="comment"> * &lt;pre&gt;SELECT \ref kmeans(</span>
<a name="l00694"></a>00694 <span class="comment">    rel_source,</span>
<a name="l00695"></a>00695 <span class="comment">    expr_point,</span>
<a name="l00696"></a>00696 <span class="comment">    \ref kmeanspp_seeding(</span>
<a name="l00697"></a>00697 <span class="comment">        rel_source,</span>
<a name="l00698"></a>00698 <span class="comment">        expr_point,</span>
<a name="l00699"></a>00699 <span class="comment">        k,</span>
<a name="l00700"></a>00700 <span class="comment">        fn_dist</span>
<a name="l00701"></a>00701 <span class="comment">    ),</span>
<a name="l00702"></a>00702 <span class="comment">    fn_dist,</span>
<a name="l00703"></a>00703 <span class="comment">    agg_centroid,</span>
<a name="l00704"></a>00704 <span class="comment">    max_num_iterations,</span>
<a name="l00705"></a>00705 <span class="comment">    min_frac_reassigned</span>
<a name="l00706"></a>00706 <span class="comment">)&lt;/pre&gt;</span>
<a name="l00707"></a>00707 <span class="comment"> */</span>
<a name="l00708"></a>00708 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#ac31b4fbed669ca0fd60548eb179c5521" title="Run k-Means++.">kmeanspp</a>(
<a name="l00709"></a>00709     rel_source VARCHAR,
<a name="l00710"></a>00710     expr_point VARCHAR,
<a name="l00711"></a>00711     k INTEGER,
<a name="l00712"></a>00712     fn_dist VARCHAR <span class="comment">/*+ DEFAULT &#39;squared_dist_norm2&#39; */</span>,
<a name="l00713"></a>00713     agg_centroid VARCHAR <span class="comment">/*+ DEFAULT &#39;avg&#39; */</span>,
<a name="l00714"></a>00714     max_num_iterations INTEGER <span class="comment">/*+ DEFAULT 20 */</span>,
<a name="l00715"></a>00715     min_frac_reassigned DOUBLE PRECISION <span class="comment">/*+ DEFAULT 0.001 */</span>
<a name="l00716"></a>00716 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00717"></a>00717 VOLATILE
<a name="l00718"></a>00718 STRICT
<a name="l00719"></a>00719 LANGUAGE plpgsql
<a name="l00720"></a>00720 AS $$
<a name="l00721"></a>00721 DECLARE
<a name="l00722"></a>00722     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l00723"></a>00723 BEGIN
<a name="l00724"></a>00724     ret = MADLIB_SCHEMA.kmeans(
<a name="l00725"></a>00725         $1, $2, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4),
<a name="l00726"></a>00726         $4, $5, $6, $7);
<a name="l00727"></a>00727     RETURN ret;
<a name="l00728"></a>00728 END
<a name="l00729"></a>00729 $$;
<a name="l00730"></a><a class="code" href="kmeans__new_8sql__in.html#ac31b4fbed669ca0fd60548eb179c5521">00730</a> 
<a name="l00731"></a>00731 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#ac31b4fbed669ca0fd60548eb179c5521" title="Run k-Means++.">kmeanspp</a>(
<a name="l00732"></a>00732     rel_source VARCHAR,
<a name="l00733"></a>00733     expr_point VARCHAR,
<a name="l00734"></a>00734     k INTEGER,
<a name="l00735"></a>00735     fn_dist VARCHAR,
<a name="l00736"></a>00736     agg_centroid VARCHAR,
<a name="l00737"></a>00737     max_num_iterations INTEGER
<a name="l00738"></a>00738 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00739"></a>00739 VOLATILE
<a name="l00740"></a>00740 STRICT
<a name="l00741"></a>00741 LANGUAGE plpgsql
<a name="l00742"></a>00742 AS $$
<a name="l00743"></a>00743 DECLARE
<a name="l00744"></a>00744     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l00745"></a>00745 BEGIN
<a name="l00746"></a>00746     ret = MADLIB_SCHEMA.kmeans(
<a name="l00747"></a>00747         $1, $2, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4),
<a name="l00748"></a>00748         $4, $5, $6, 0.001);
<a name="l00749"></a>00749     RETURN ret;
<a name="l00750"></a>00750 END
<a name="l00751"></a>00751 $$;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#ac31b4fbed669ca0fd60548eb179c5521" title="Run k-Means++.">kmeanspp</a>(
<a name="l00754"></a>00754     rel_source VARCHAR,
<a name="l00755"></a>00755     expr_point VARCHAR,
<a name="l00756"></a>00756     k INTEGER,
<a name="l00757"></a>00757     fn_dist VARCHAR,
<a name="l00758"></a>00758     agg_centroid VARCHAR
<a name="l00759"></a>00759 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00760"></a>00760 VOLATILE
<a name="l00761"></a>00761 STRICT
<a name="l00762"></a>00762 LANGUAGE plpgsql
<a name="l00763"></a>00763 AS $$
<a name="l00764"></a>00764 DECLARE
<a name="l00765"></a>00765     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l00766"></a>00766 BEGIN
<a name="l00767"></a>00767     ret = MADLIB_SCHEMA.kmeans(
<a name="l00768"></a>00768         $1, $2, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4),
<a name="l00769"></a>00769         $4, $5, 20, 0.001);
<a name="l00770"></a>00770     RETURN ret;
<a name="l00771"></a>00771 END
<a name="l00772"></a>00772 $$;
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#ac31b4fbed669ca0fd60548eb179c5521" title="Run k-Means++.">kmeanspp</a>(
<a name="l00775"></a>00775     rel_source VARCHAR,
<a name="l00776"></a>00776     expr_point VARCHAR,
<a name="l00777"></a>00777     k INTEGER,
<a name="l00778"></a>00778     fn_dist VARCHAR
<a name="l00779"></a>00779 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00780"></a>00780 VOLATILE
<a name="l00781"></a>00781 STRICT
<a name="l00782"></a>00782 LANGUAGE plpgsql
<a name="l00783"></a>00783 AS $$
<a name="l00784"></a>00784 DECLARE
<a name="l00785"></a>00785     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l00786"></a>00786 BEGIN
<a name="l00787"></a>00787     ret = MADLIB_SCHEMA.kmeans(
<a name="l00788"></a>00788         $1, $2, MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, $4),
<a name="l00789"></a>00789         $4, &#39;MADLIB_SCHEMA.avg&#39;, 20, 0.001);
<a name="l00790"></a>00790     RETURN ret;
<a name="l00791"></a>00791 END
<a name="l00792"></a>00792 $$;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#ac31b4fbed669ca0fd60548eb179c5521" title="Run k-Means++.">kmeanspp</a>(
<a name="l00795"></a>00795     rel_source VARCHAR,
<a name="l00796"></a>00796     expr_point VARCHAR,
<a name="l00797"></a>00797     k INTEGER
<a name="l00798"></a>00798 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00799"></a>00799 VOLATILE
<a name="l00800"></a>00800 STRICT
<a name="l00801"></a>00801 LANGUAGE plpgsql
<a name="l00802"></a>00802 AS $$
<a name="l00803"></a>00803 DECLARE
<a name="l00804"></a>00804     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l00805"></a>00805 BEGIN
<a name="l00806"></a>00806     ret = MADLIB_SCHEMA.kmeans(
<a name="l00807"></a>00807         $1, $2, 
<a name="l00808"></a>00808         MADLIB_SCHEMA.kmeanspp_seeding($1, $2, $3, 
<a name="l00809"></a>00809             &#39;MADLIB_SCHEMA.squared_dist_norm2&#39;),
<a name="l00810"></a>00810         &#39;MADLIB_SCHEMA.squared_dist_norm2&#39;, &#39;MADLIB_SCHEMA.avg&#39;, 20, 0.001);
<a name="l00811"></a>00811     RETURN ret;
<a name="l00812"></a>00812 END
<a name="l00813"></a>00813 $$;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815 CREATE FUNCTION MADLIB_SCHEMA.internal_execute_using_kmeans_random_seeding_args(
<a name="l00816"></a>00816     sql VARCHAR, INTEGER, DOUBLE PRECISION[][]
<a name="l00817"></a>00817 ) RETURNS VOID
<a name="l00818"></a>00818 VOLATILE
<a name="l00819"></a>00819 CALLED ON NULL INPUT
<a name="l00820"></a>00820 LANGUAGE c
<a name="l00821"></a>00821 AS &#39;MODULE_PATHNAME&#39;, &#39;exec_sql_using&#39;;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823 CREATE FUNCTION MADLIB_SCHEMA.internal_compute_kmeans_random_seeding(
<a name="l00824"></a>00824     rel_args VARCHAR,
<a name="l00825"></a>00825     rel_state VARCHAR,
<a name="l00826"></a>00826     rel_source VARCHAR,
<a name="l00827"></a>00827     expr_point VARCHAR)
<a name="l00828"></a>00828 RETURNS INTEGER
<a name="l00829"></a>00829 AS $$PythonFunction(kmeans_new, kmeans_new, compute_kmeans_random_seeding)$$
<a name="l00830"></a>00830 LANGUAGE plpythonu VOLATILE;
<a name="l00831"></a>00831 <span class="comment"></span>
<a name="l00832"></a>00832 <span class="comment">/**</span>
<a name="l00833"></a>00833 <span class="comment"> * @brief k-Means Random Seeding</span>
<a name="l00834"></a>00834 <span class="comment"> *</span>
<a name="l00835"></a>00835 <span class="comment"> * @param rel_source Name of the relation containing input points</span>
<a name="l00836"></a>00836 <span class="comment"> * @param expr_point Expression evaluating to point coordinates for each tuple</span>
<a name="l00837"></a>00837 <span class="comment"> * @param k Number of centroids</span>
<a name="l00838"></a>00838 <span class="comment"> * @param initial_centroids A matrix containing up to \f$ k \f$ columns as</span>
<a name="l00839"></a>00839 <span class="comment"> *     columns. kmeanspp_seeding() proceeds exactly as if these centroids had</span>
<a name="l00840"></a>00840 <span class="comment"> *     already been generated in previous iterations. This parameter may be</span>
<a name="l00841"></a>00841 <span class="comment"> *     NULL in which all \f$ k \f$ centroids will be generated.</span>
<a name="l00842"></a>00842 <span class="comment"> * @returns A matrix containing \f$ k \f$ centroids as columns</span>
<a name="l00843"></a>00843 <span class="comment"> */</span>
<a name="l00844"></a>00844 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#a01e02736e6d156240b15f7d6dae092c3" title="k-Means Random Seeding">kmeans_random_seeding</a>(
<a name="l00845"></a>00845     rel_source VARCHAR,
<a name="l00846"></a>00846     expr_point VARCHAR,
<a name="l00847"></a>00847     k INTEGER,
<a name="l00848"></a>00848     initial_centroids DOUBLE PRECISION[][] <span class="comment">/*+ DEFAULT NULL */</span>
<a name="l00849"></a>00849 ) RETURNS DOUBLE PRECISION[][] AS $$
<a name="l00850"></a>00850 DECLARE
<a name="l00851"></a>00851     theIteration INTEGER;
<a name="l00852"></a>00852     theResult DOUBLE PRECISION[][];
<a name="l00853"></a>00853     oldClientMinMessages VARCHAR;
<a name="l00854"></a>00854     class_rel_source REGCLASS;
<a name="l00855"></a>00855     proc_fn_dist REGPROCEDURE;
<a name="l00856"></a>00856     num_points INTEGER;
<a name="l00857"></a>00857     num_centroids INTEGER;
<a name="l00858"></a>00858     rel_filtered VARCHAR;
<a name="l00859"></a>00859 BEGIN
<a name="l00860"></a>00860     PERFORM MADLIB_SCHEMA.kmeans_is_valid_input(rel_source, expr_point);
<a name="l00861"></a>00861     rel_filtered = MADLIB_SCHEMA.__filter_input_relation(rel_source, expr_point);
<a name="l00862"></a>00862     class_rel_source := rel_filtered;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     IF (initial_centroids IS NOT NULL) THEN
<a name="l00865"></a>00865     num_centroids := array_upper(initial_centroids,1);
<a name="l00866"></a><a class="code" href="kmeans__new_8sql__in.html#a01e02736e6d156240b15f7d6dae092c3">00866</a>     ELSE
<a name="l00867"></a>00867     num_centroids := k;
<a name="l00868"></a>00868     END IF;
<a name="l00869"></a>00869 
<a name="l00870"></a>00870     IF (k &lt;= 0) THEN
<a name="l00871"></a>00871         RAISE EXCEPTION &#39;Number of clusters k must be a positive integer.&#39;;
<a name="l00872"></a>00872     END IF;
<a name="l00873"></a>00873     IF (k &gt; 32767) THEN
<a name="l00874"></a>00874     RAISE EXCEPTION &#39;Number of clusters k must be &lt;= 32767 (for results to be returned in a reasonable amount of time).&#39;;
<a name="l00875"></a>00875     END IF;
<a name="l00876"></a>00876     EXECUTE $sql$ SELECT count(*) FROM $sql$ || textin(regclassout(class_rel_source)) INTO num_points;
<a name="l00877"></a>00877     IF (num_points &lt; k  OR num_points &lt; num_centroids) THEN
<a name="l00878"></a>00878     RAISE EXCEPTION &#39;Number of centroids is greater than number of points.&#39;;
<a name="l00879"></a>00879     END IF;
<a name="l00880"></a>00880     IF (k &lt; num_centroids) THEN
<a name="l00881"></a>00881     RAISE WARNING &#39;Number of clusters k is less than number of supplied initial centroids. Number of final clusters will equal number of supplied initial centroids.&#39;;
<a name="l00882"></a>00882     END IF;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     -- We first setup the argument table. Rationale: We want to avoid all data
<a name="l00885"></a>00885     -- conversion between native types and Python code. Instead, we use Python
<a name="l00886"></a>00886     -- as a pure driver layer.
<a name="l00887"></a>00887     oldClientMinMessages :=
<a name="l00888"></a>00888         (SELECT setting FROM pg_settings WHERE name = &#39;client_min_messages&#39;);
<a name="l00889"></a>00889     EXECUTE &#39;SET client_min_messages TO warning&#39;;
<a name="l00890"></a>00890     PERFORM MADLIB_SCHEMA.create_schema_pg_temp();
<a name="l00891"></a>00891     -- Unfortunately, the EXECUTE USING syntax is only available starting
<a name="l00892"></a>00892     -- PostgreSQL 8.4:
<a name="l00893"></a>00893     -- http:<span class="comment">//www.postgresql.org/docs/8.4/static/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN</span>
<a name="l00894"></a>00894     -- We therefore have to emulate.
<a name="l00895"></a>00895     PERFORM MADLIB_SCHEMA.internal_execute_using_kmeans_random_seeding_args($sql$
<a name="l00896"></a>00896         DROP TABLE IF EXISTS pg_temp._madlib_kmeans_random_args;
<a name="l00897"></a>00897         CREATE TEMPORARY TABLE _madlib_kmeans_random_args AS
<a name="l00898"></a>00898         SELECT $1 AS k, $2 AS initial_centroids;
<a name="l00899"></a>00899         $sql$,
<a name="l00900"></a>00900         k, initial_centroids);
<a name="l00901"></a>00901     EXECUTE &#39;SET client_min_messages TO &#39; || oldClientMinMessages;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903     -- Perform acutal computation.
<a name="l00904"></a>00904     -- Unfortunately, Greenplum and PostgreSQL &lt;= 8.2 do not have conversion
<a name="l00905"></a>00905     -- operators from regclass to varchar/text.
<a name="l00906"></a>00906     theIteration := (
<a name="l00907"></a>00907         SELECT MADLIB_SCHEMA.internal_compute_kmeans_random_seeding(
<a name="l00908"></a>00908             &#39;_madlib_kmeans_random_args&#39;, &#39;_madlib_kmeans_random_state&#39;,
<a name="l00909"></a>00909             textin(regclassout(class_rel_source)), expr_point)
<a name="l00910"></a>00910     );
<a name="l00911"></a>00911 
<a name="l00912"></a>00912     -- Retrieve result from state table and return it
<a name="l00913"></a>00913     EXECUTE
<a name="l00914"></a>00914         $sql$
<a name="l00915"></a>00915         SELECT _state FROM _madlib_kmeans_random_state
<a name="l00916"></a>00916         WHERE _iteration = $sql$ || theIteration || $sql$
<a name="l00917"></a>00917         $sql$
<a name="l00918"></a>00918         INTO theResult;
<a name="l00919"></a>00919     RETURN theResult;
<a name="l00920"></a>00920 END;
<a name="l00921"></a>00921 $$ LANGUAGE plpgsql VOLATILE;
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#a01e02736e6d156240b15f7d6dae092c3" title="k-Means Random Seeding">kmeans_random_seeding</a>(
<a name="l00924"></a>00924     rel_source VARCHAR,
<a name="l00925"></a>00925     expr_point VARCHAR,
<a name="l00926"></a>00926     k INTEGER
<a name="l00927"></a>00927 ) RETURNS DOUBLE PRECISION[][]
<a name="l00928"></a>00928 LANGUAGE sql AS $$
<a name="l00929"></a>00929     SELECT MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#a01e02736e6d156240b15f7d6dae092c3" title="k-Means Random Seeding">kmeans_random_seeding</a>($1, $2, $3, NULL)
<a name="l00930"></a>00930 $$;
<a name="l00931"></a>00931 <span class="comment"></span>
<a name="l00932"></a>00932 <span class="comment">/**</span>
<a name="l00933"></a>00933 <span class="comment"> * @brief Run k-Means with random seeding.</span>
<a name="l00934"></a>00934 <span class="comment"> *</span>
<a name="l00935"></a>00935 <span class="comment"> * This is a shortcut for running k-means with random seeding. It is equivalent</span>
<a name="l00936"></a>00936 <span class="comment"> * to</span>
<a name="l00937"></a>00937 <span class="comment"> * &lt;pre&gt;SELECT \ref kmeans(</span>
<a name="l00938"></a>00938 <span class="comment">    rel_source,</span>
<a name="l00939"></a>00939 <span class="comment">    expr_point,</span>
<a name="l00940"></a>00940 <span class="comment">    \ref kmeans_random_seeding(</span>
<a name="l00941"></a>00941 <span class="comment">        rel_source,</span>
<a name="l00942"></a>00942 <span class="comment">        expr_point,</span>
<a name="l00943"></a>00943 <span class="comment">        k</span>
<a name="l00944"></a>00944 <span class="comment">    ),</span>
<a name="l00945"></a>00945 <span class="comment">    fn_dist,</span>
<a name="l00946"></a>00946 <span class="comment">    agg_centroid,</span>
<a name="l00947"></a>00947 <span class="comment">    max_num_iterations,</span>
<a name="l00948"></a>00948 <span class="comment">    min_frac_reassigned</span>
<a name="l00949"></a>00949 <span class="comment">)&lt;/pre&gt;</span>
<a name="l00950"></a>00950 <span class="comment"> */</span>
<a name="l00951"></a>00951 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans_8sql__in.html#acf6865386460a74f74a2f91bd90e20f8" title="Computes k-means clustering using random centroid seeding.">kmeans_random</a>(
<a name="l00952"></a>00952     rel_source VARCHAR,
<a name="l00953"></a>00953     expr_point VARCHAR,
<a name="l00954"></a>00954     k INTEGER,
<a name="l00955"></a>00955     fn_dist VARCHAR <span class="comment">/*+ DEFAULT &#39;squared_dist_norm2&#39; */</span>,
<a name="l00956"></a>00956     agg_centroid VARCHAR <span class="comment">/*+ DEFAULT &#39;avg&#39; */</span>,
<a name="l00957"></a>00957     max_num_iterations INTEGER <span class="comment">/*+ DEFAULT 20 */</span>,
<a name="l00958"></a>00958     min_frac_reassigned DOUBLE PRECISION <span class="comment">/*+ DEFAULT 0.001 */</span>
<a name="l00959"></a>00959 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00960"></a>00960 VOLATILE
<a name="l00961"></a>00961 STRICT
<a name="l00962"></a>00962 LANGUAGE plpgsql
<a name="l00963"></a>00963 AS $$
<a name="l00964"></a>00964 DECLARE
<a name="l00965"></a>00965     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l00966"></a>00966 BEGIN
<a name="l00967"></a>00967     ret = MADLIB_SCHEMA.kmeans(
<a name="l00968"></a>00968         $1, $2, MADLIB_SCHEMA.kmeans_random_seeding($1, $2, $3),
<a name="l00969"></a>00969         $4, $5, $6, $7);
<a name="l00970"></a>00970     RETURN ret;
<a name="l00971"></a>00971 END
<a name="l00972"></a>00972 $$;
<a name="l00973"></a><a class="code" href="kmeans__new_8sql__in.html#a1e6c9981a205829baa571eca46cca1b2">00973</a> 
<a name="l00974"></a>00974 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans_8sql__in.html#acf6865386460a74f74a2f91bd90e20f8" title="Computes k-means clustering using random centroid seeding.">kmeans_random</a>(
<a name="l00975"></a>00975     rel_source VARCHAR,
<a name="l00976"></a>00976     expr_point VARCHAR,
<a name="l00977"></a>00977     k INTEGER,
<a name="l00978"></a>00978     fn_dist VARCHAR,
<a name="l00979"></a>00979     agg_centroid VARCHAR,
<a name="l00980"></a>00980     max_num_iterations INTEGER
<a name="l00981"></a>00981 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l00982"></a>00982 VOLATILE
<a name="l00983"></a>00983 STRICT
<a name="l00984"></a>00984 LANGUAGE plpgsql
<a name="l00985"></a>00985 AS $$
<a name="l00986"></a>00986 DECLARE
<a name="l00987"></a>00987     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l00988"></a>00988 BEGIN
<a name="l00989"></a>00989     ret = MADLIB_SCHEMA.kmeans(
<a name="l00990"></a>00990         $1, $2, MADLIB_SCHEMA.kmeans_random_seeding($1, $2, $3),
<a name="l00991"></a>00991         $4, $5, $6, 0.001);
<a name="l00992"></a>00992     RETURN ret;
<a name="l00993"></a>00993 END
<a name="l00994"></a>00994 $$;
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans_8sql__in.html#acf6865386460a74f74a2f91bd90e20f8" title="Computes k-means clustering using random centroid seeding.">kmeans_random</a>(
<a name="l00997"></a>00997     rel_source VARCHAR,
<a name="l00998"></a>00998     expr_point VARCHAR,
<a name="l00999"></a>00999     k INTEGER,
<a name="l01000"></a>01000     fn_dist VARCHAR,
<a name="l01001"></a>01001     agg_centroid VARCHAR
<a name="l01002"></a>01002 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01003"></a>01003 VOLATILE
<a name="l01004"></a>01004 STRICT
<a name="l01005"></a>01005 LANGUAGE plpgsql
<a name="l01006"></a>01006 AS $$
<a name="l01007"></a>01007 DECLARE
<a name="l01008"></a>01008     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l01009"></a>01009 BEGIN
<a name="l01010"></a>01010     ret = MADLIB_SCHEMA.kmeans(
<a name="l01011"></a>01011         $1, $2, MADLIB_SCHEMA.kmeans_random_seeding($1, $2, $3),
<a name="l01012"></a>01012         $4, $5, 20, 0.001);
<a name="l01013"></a>01013     RETURN ret;
<a name="l01014"></a>01014 END
<a name="l01015"></a>01015 $$;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans_8sql__in.html#acf6865386460a74f74a2f91bd90e20f8" title="Computes k-means clustering using random centroid seeding.">kmeans_random</a>(
<a name="l01018"></a>01018     rel_source VARCHAR,
<a name="l01019"></a>01019     expr_point VARCHAR,
<a name="l01020"></a>01020     k INTEGER,
<a name="l01021"></a>01021     fn_dist VARCHAR
<a name="l01022"></a>01022 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01023"></a>01023 VOLATILE
<a name="l01024"></a>01024 STRICT
<a name="l01025"></a>01025 LANGUAGE plpgsql
<a name="l01026"></a>01026 AS $$
<a name="l01027"></a>01027 DECLARE
<a name="l01028"></a>01028     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l01029"></a>01029 BEGIN
<a name="l01030"></a>01030     ret = MADLIB_SCHEMA.kmeans(
<a name="l01031"></a>01031         $1, $2, 
<a name="l01032"></a>01032         MADLIB_SCHEMA.kmeans_random_seeding($1, $2, $3),
<a name="l01033"></a>01033         $4, &#39;MADLIB_SCHEMA.avg&#39;, 20, 0.001);
<a name="l01034"></a>01034     RETURN ret;
<a name="l01035"></a>01035 END
<a name="l01036"></a>01036 $$;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans_8sql__in.html#acf6865386460a74f74a2f91bd90e20f8" title="Computes k-means clustering using random centroid seeding.">kmeans_random</a>(
<a name="l01039"></a>01039     rel_source VARCHAR,
<a name="l01040"></a>01040     expr_point VARCHAR,
<a name="l01041"></a>01041     k INTEGER
<a name="l01042"></a>01042 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01043"></a>01043 VOLATILE
<a name="l01044"></a>01044 STRICT
<a name="l01045"></a>01045 LANGUAGE plpgsql
<a name="l01046"></a>01046 AS $$
<a name="l01047"></a>01047 DECLARE
<a name="l01048"></a>01048     ret MADLIB_SCHEMA.kmeans_new_result;
<a name="l01049"></a>01049 BEGIN
<a name="l01050"></a>01050     ret = MADLIB_SCHEMA.kmeans(
<a name="l01051"></a>01051         $1, $2, 
<a name="l01052"></a>01052         MADLIB_SCHEMA.kmeans_random_seeding($1, $2, $3),
<a name="l01053"></a>01053         &#39;MADLIB_SCHEMA.squared_dist_norm2&#39;, &#39;MADLIB_SCHEMA.avg&#39;, 20, 0.001);
<a name="l01054"></a>01054     RETURN ret;
<a name="l01055"></a>01055 END
<a name="l01056"></a>01056 $$;
<a name="l01057"></a>01057 <span class="comment"></span>
<a name="l01058"></a>01058 <span class="comment">/**</span>
<a name="l01059"></a>01059 <span class="comment"> * @internal</span>
<a name="l01060"></a>01060 <span class="comment"> * @brief Execute a SQL command where $1, ..., $6 are substituted with the</span>
<a name="l01061"></a>01061 <span class="comment"> *     given arguments.</span>
<a name="l01062"></a>01062 <span class="comment"> */</span>
<a name="l01063"></a>01063 CREATE FUNCTION MADLIB_SCHEMA.internal_execute_using_kmeans_args(
<a name="l01064"></a>01064     sql VARCHAR, rel_source VARCHAR, expr_point VARCHAR,
<a name="l01065"></a>01065     fn_dist VARCHAR, agg_centroid VARCHAR, max_num_iterations INTEGER,
<a name="l01066"></a>01066     min_frac_reassigned DOUBLE PRECISION
<a name="l01067"></a>01067 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01068"></a>01068 VOLATILE
<a name="l01069"></a>01069 CALLED ON NULL INPUT
<a name="l01070"></a>01070 LANGUAGE c
<a name="l01071"></a>01071 AS &#39;MODULE_PATHNAME&#39;, &#39;exec_sql_using&#39;;
<a name="l01072"></a>01072 <span class="comment"></span>
<a name="l01073"></a>01073 <span class="comment">/**</span>
<a name="l01074"></a>01074 <span class="comment"> * @internal</span>
<a name="l01075"></a>01075 <span class="comment"> * @brief Filter out the invalid data points in the original input relation</span>
<a name="l01076"></a>01076 <span class="comment"> */</span>
<a name="l01077"></a>01077 CREATE FUNCTION MADLIB_SCHEMA.__filter_input_relation(
<a name="l01078"></a>01078     rel_source VARCHAR, expr_point VARCHAR) 
<a name="l01079"></a>01079 RETURNS VARCHAR
<a name="l01080"></a>01080 AS $$
<a name="l01081"></a>01081 DECLARE
<a name="l01082"></a>01082     oldClientMinMessages VARCHAR;
<a name="l01083"></a>01083     rel_source_filtered VARCHAR;
<a name="l01084"></a>01084 BEGIN
<a name="l01085"></a>01085     IF (SELECT position(&#39;.&#39; in rel_source)) &gt; 0 THEN
<a name="l01086"></a>01086         rel_source_filtered := &#39;_madlib_&#39; || split_part(rel_source, &#39;.&#39;, 2) || &#39;_filtered&#39;;
<a name="l01087"></a>01087     ELSE
<a name="l01088"></a>01088     rel_source_filtered := &#39;_madlib_&#39; || rel_source || &#39;_filtered&#39;;
<a name="l01089"></a>01089     END IF;
<a name="l01090"></a>01090 
<a name="l01091"></a>01091     oldClientMinMessages :=
<a name="l01092"></a>01092         (SELECT setting FROM pg_settings WHERE name = &#39;client_min_messages&#39;);
<a name="l01093"></a>01093     EXECUTE &#39;SET client_min_messages TO warning&#39;;
<a name="l01094"></a>01094     EXECUTE &#39;DROP VIEW IF EXISTS _madlib_&#39;||rel_source_filtered||&#39;_filtered&#39;;
<a name="l01095"></a>01095     EXECUTE &#39;DROP VIEW IF EXISTS &#39;||rel_source_filtered;
<a name="l01096"></a>01096     EXECUTE &#39;CREATE TEMP VIEW &#39;||rel_source_filtered||&#39;
<a name="l01097"></a>01097              AS SELECT * FROM &#39;||rel_source||&#39; 
<a name="l01098"></a>01098                     WHERE abs( 
<a name="l01099"></a>01099                               coalesce(
<a name="l01100"></a>01100                                  MADLIB_SCHEMA.<a class="code" href="svec_8sql__in.html#a00a7b3260b9fde9b55061e6bf58a028a">svec_elsum</a>(&#39;||expr_point||&#39;), 
<a name="l01101"></a>01101                                  &#39;&#39;Infinity&#39;&#39;::FLOAT8
<a name="l01102"></a>01102                               )
<a name="l01103"></a>01103                              ) &lt; &#39;&#39;Infinity&#39;&#39;::FLOAT8&#39;; 
<a name="l01104"></a>01104     EXECUTE &#39;SET client_min_messages TO &#39; || oldClientMinMessages;
<a name="l01105"></a>01105     RETURN rel_source_filtered;
<a name="l01106"></a>01106 END
<a name="l01107"></a>01107 $$
<a name="l01108"></a>01108 VOLATILE STRICT
<a name="l01109"></a>01109 LANGUAGE PLPGSQL;
<a name="l01110"></a>01110 <span class="comment"></span>
<a name="l01111"></a>01111 <span class="comment">/**</span>
<a name="l01112"></a>01112 <span class="comment"> * @brief Perform Lloyd&#39;s k-means local-search heuristic, but with initial</span>
<a name="l01113"></a>01113 <span class="comment"> *     centroids stored in a table</span>
<a name="l01114"></a>01114 <span class="comment"> *</span>
<a name="l01115"></a>01115 <span class="comment"> * This is a shortcut for running k-means with initial centroids stored in a</span>
<a name="l01116"></a>01116 <span class="comment"> * table (as opposed to an array of centroids). It is equivalent</span>
<a name="l01117"></a>01117 <span class="comment"> * to</span>
<a name="l01118"></a>01118 <span class="comment"> * &lt;pre&gt;SELECT \ref kmeans(</span>
<a name="l01119"></a>01119 <span class="comment">    rel_source,</span>
<a name="l01120"></a>01120 <span class="comment">    expr_point,</span>
<a name="l01121"></a>01121 <span class="comment">    (SELECT \ref matrix_agg($expr_centroid) FROM $rel_initial_centroids),</span>
<a name="l01122"></a>01122 <span class="comment">    fn_dist,</span>
<a name="l01123"></a>01123 <span class="comment">    agg_centroid,</span>
<a name="l01124"></a>01124 <span class="comment">    max_num_iterations,</span>
<a name="l01125"></a>01125 <span class="comment">    min_frac_reassigned</span>
<a name="l01126"></a>01126 <span class="comment">)&lt;/pre&gt;</span>
<a name="l01127"></a>01127 <span class="comment"> * where &lt;tt&gt;$expr_centroid&lt;/tt&gt; and &lt;tt&gt;$rel_initial_centroids&lt;/tt&gt; denote</span>
<a name="l01128"></a>01128 <span class="comment"> * textual substituions.</span>
<a name="l01129"></a>01129 <span class="comment"> */</span>
<a name="l01130"></a>01130 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l01131"></a>01131     rel_source VARCHAR,
<a name="l01132"></a>01132     expr_point VARCHAR,
<a name="l01133"></a>01133     rel_initial_centroids VARCHAR,
<a name="l01134"></a>01134     expr_centroid VARCHAR,
<a name="l01135"></a>01135     fn_dist VARCHAR <span class="comment">/*+ DEFAULT &#39;squared_dist_norm2&#39; */</span>,
<a name="l01136"></a>01136     agg_centroid VARCHAR <span class="comment">/*+ DEFAULT &#39;avg&#39; */</span>,
<a name="l01137"></a>01137     max_num_iterations INTEGER <span class="comment">/*+ DEFAULT 20 */</span>,
<a name="l01138"></a>01138     min_frac_reassigned DOUBLE PRECISION <span class="comment">/*+ DEFAULT 0.001 */</span>
<a name="l01139"></a>01139 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01140"></a>01140 VOLATILE
<a name="l01141"></a>01141 STRICT
<a name="l01142"></a>01142 LANGUAGE plpgsql
<a name="l01143"></a>01143 AS $$
<a name="l01144"></a>01144 DECLARE
<a name="l01145"></a>01145     class_rel_initial_centroids REGCLASS;
<a name="l01146"></a>01146     theResult MADLIB_SCHEMA.kmeans_new_result;
<a name="l01147"></a>01147 BEGIN
<a name="l01148"></a>01148     PERFORM MADLIB_SCHEMA.kmeans_is_valid_input(rel_source, expr_point);
<a name="l01149"></a>01149     class_rel_initial_centroids := rel_initial_centroids;
<a name="l01150"></a>01150     SELECT * FROM MADLIB_SCHEMA.internal_execute_using_kmeans_args($sql$
<a name="l01151"></a>01151         SELECT MADLIB_SCHEMA.kmeans(
<a name="l01152"></a><a class="code" href="kmeans__new_8sql__in.html#a80a0fe40873f833f76f26deac8a87464">01152</a>             $1, $2,
<a name="l01153"></a>01153             (
<a name="l01154"></a>01154                 SELECT MADLIB_SCHEMA.<a class="code" href="linalg_8sql__in.html#a9c439706f35d6cac89f151d553a5f111" title="Combine vectors to a matrix.">matrix_agg</a>(($sql$ || expr_centroid || $sql$)::FLOAT8[])
<a name="l01155"></a>01155                 FROM $sql$ || textin(regclassout(class_rel_initial_centroids))
<a name="l01156"></a>01156                     || $sql$
<a name="l01157"></a>01157             ),
<a name="l01158"></a>01158             $3, $4, $5, $6)
<a name="l01159"></a>01159             $sql$,
<a name="l01160"></a>01160         rel_source, expr_point,
<a name="l01161"></a>01161         fn_dist, agg_centroid, max_num_iterations, min_frac_reassigned)
<a name="l01162"></a>01162         INTO theResult;
<a name="l01163"></a>01163     RETURN theResult;
<a name="l01164"></a>01164 END;
<a name="l01165"></a>01165 $$;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l01168"></a>01168     rel_source VARCHAR,
<a name="l01169"></a>01169     expr_point VARCHAR,
<a name="l01170"></a>01170     rel_initial_centroids VARCHAR,
<a name="l01171"></a>01171     expr_centroid VARCHAR,
<a name="l01172"></a>01172     fn_dist VARCHAR,
<a name="l01173"></a>01173     agg_centroid VARCHAR,
<a name="l01174"></a>01174     max_num_iterations INTEGER
<a name="l01175"></a>01175 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01176"></a>01176 VOLATILE
<a name="l01177"></a>01177 STRICT
<a name="l01178"></a>01178 LANGUAGE sql AS $$
<a name="l01179"></a>01179     SELECT MADLIB_SCHEMA.kmeans(
<a name="l01180"></a>01180         $1, $2,
<a name="l01181"></a>01181         $3, $4, $5, $6, $7, 0.001)
<a name="l01182"></a>01182 $$;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l01185"></a>01185     rel_source VARCHAR,
<a name="l01186"></a>01186     expr_point VARCHAR,
<a name="l01187"></a>01187     rel_initial_centroids VARCHAR,
<a name="l01188"></a>01188     expr_centroid VARCHAR,
<a name="l01189"></a>01189     fn_dist VARCHAR,
<a name="l01190"></a>01190     agg_centroid VARCHAR
<a name="l01191"></a>01191 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01192"></a>01192 VOLATILE
<a name="l01193"></a>01193 STRICT
<a name="l01194"></a>01194 LANGUAGE sql AS $$
<a name="l01195"></a>01195     SELECT MADLIB_SCHEMA.kmeans(
<a name="l01196"></a>01196         $1, $2,
<a name="l01197"></a>01197         $3, $4, $5, $6, 20, 0.001)
<a name="l01198"></a>01198 $$;
<a name="l01199"></a>01199 
<a name="l01200"></a>01200 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l01201"></a>01201     rel_source VARCHAR,
<a name="l01202"></a>01202     expr_point VARCHAR,
<a name="l01203"></a>01203     rel_initial_centroids VARCHAR,
<a name="l01204"></a>01204     expr_centroid VARCHAR,
<a name="l01205"></a>01205     fn_dist VARCHAR
<a name="l01206"></a>01206 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01207"></a>01207 VOLATILE
<a name="l01208"></a>01208 STRICT
<a name="l01209"></a>01209 LANGUAGE sql AS $$
<a name="l01210"></a>01210     SELECT MADLIB_SCHEMA.kmeans(
<a name="l01211"></a>01211         $1, $2,
<a name="l01212"></a>01212         $3, $4, $5, &#39;MADLIB_SCHEMA.avg&#39;, 20, 0.001)
<a name="l01213"></a>01213 $$;
<a name="l01214"></a>01214 
<a name="l01215"></a>01215 CREATE FUNCTION MADLIB_SCHEMA.kmeans(
<a name="l01216"></a>01216     rel_source VARCHAR,
<a name="l01217"></a>01217     expr_point VARCHAR,
<a name="l01218"></a>01218     rel_initial_centroids VARCHAR,
<a name="l01219"></a>01219     expr_centroid VARCHAR
<a name="l01220"></a>01220 ) RETURNS MADLIB_SCHEMA.kmeans_new_result
<a name="l01221"></a>01221 VOLATILE
<a name="l01222"></a>01222 STRICT
<a name="l01223"></a>01223 LANGUAGE sql AS $$
<a name="l01224"></a>01224     SELECT MADLIB_SCHEMA.kmeans(
<a name="l01225"></a>01225         $1, $2,
<a name="l01226"></a>01226         $3, $4,
<a name="l01227"></a>01227         &#39;MADLIB_SCHEMA.squared_dist_norm2&#39;, &#39;MADLIB_SCHEMA.avg&#39;, 20, 0.001)
<a name="l01228"></a>01228 $$;
<a name="l01229"></a>01229 
<a name="l01230"></a>01230 <span class="comment"></span>
<a name="l01231"></a>01231 <span class="comment">/**</span>
<a name="l01232"></a>01232 <span class="comment"> * @internal</span>
<a name="l01233"></a>01233 <span class="comment"> * @brief Execute a SQL command where $1, ..., $3 are substituted with the</span>
<a name="l01234"></a>01234 <span class="comment"> *     given arguments.</span>
<a name="l01235"></a>01235 <span class="comment"> */</span>
<a name="l01236"></a>01236 CREATE FUNCTION MADLIB_SCHEMA.internal_execute_using_silhouette_args(
<a name="l01237"></a>01237     sql VARCHAR, centroids DOUBLE PRECISION[][], fn_dist REGPROC
<a name="l01238"></a>01238 ) RETURNS DOUBLE PRECISION
<a name="l01239"></a>01239 STABLE
<a name="l01240"></a>01240 CALLED ON NULL INPUT
<a name="l01241"></a>01241 LANGUAGE c
<a name="l01242"></a>01242 AS &#39;MODULE_PATHNAME&#39;, &#39;exec_sql_using&#39;;
<a name="l01243"></a>01243 <span class="comment"></span>
<a name="l01244"></a>01244 <span class="comment">/**</span>
<a name="l01245"></a>01245 <span class="comment"> * @brief Compute a simplified version of the silhouette coefficient</span>
<a name="l01246"></a>01246 <span class="comment"> *</span>
<a name="l01247"></a>01247 <span class="comment"> * @param rel_source Name of the relation containing input points</span>
<a name="l01248"></a>01248 <span class="comment"> * @param expr_point Expression evaluating to point coordinates \f$ x_i \f$ for</span>
<a name="l01249"></a>01249 <span class="comment"> *     each tuple</span>
<a name="l01250"></a>01250 <span class="comment"> * @param centroids Matrix \f$ M = (\vec{m_0} \dots \vec{m_{k-1}})</span>
<a name="l01251"></a>01251 <span class="comment"> *     \in \mathbb{R}^{d \times k} \f$ with \f$ k \f$ columns, where column</span>
<a name="l01252"></a>01252 <span class="comment"> *     \f$ i \f$ contains the position of centroid \f$ i \f$.</span>
<a name="l01253"></a>01253 <span class="comment"> * @param fn_dist Name of a function with signature</span>
<a name="l01254"></a>01254 <span class="comment"> *     &lt;tt&gt;DOUBLE PRECISION[] x DOUBLE PRECISION[] -&gt; DOUBLE PRECISION&lt;/tt&gt; that</span>
<a name="l01255"></a>01255 <span class="comment"> *     returns the distance between two points</span>
<a name="l01256"></a>01256 <span class="comment"> * @return For each point \f$ x_i \f$, let</span>
<a name="l01257"></a>01257 <span class="comment"> *     \f$ d_1( x_i ) \f$ and \f$ d_2( x_i ) \f$ be the distance to the closest</span>
<a name="l01258"></a>01258 <span class="comment"> *     and 2nd-closest centroid, respectively. If there is more than one</span>
<a name="l01259"></a>01259 <span class="comment"> *     closest centroids then \f$ d_1( x_i ) = d_2( x_i )\f$.</span>
<a name="l01260"></a>01260 <span class="comment"> *     The return value is the average, over all points \f$ x_i \f$, of</span>
<a name="l01261"></a>01261 <span class="comment"> *     \f[</span>
<a name="l01262"></a>01262 <span class="comment"> *         \frac{d_2( x_i ) - d_1(x_i)}{d_2(x_i)},</span>
<a name="l01263"></a>01263 <span class="comment"> *     \f]</span>
<a name="l01264"></a>01264 <span class="comment"> *     where 0/0 is interpreted as 0.</span>
<a name="l01265"></a>01265 <span class="comment"> *     Clearly, the simplified silhouette coefficient assumes values in</span>
<a name="l01266"></a>01266 <span class="comment"> *     \f$ [0,1] \f$.</span>
<a name="l01267"></a>01267 <span class="comment"> */</span>
<a name="l01268"></a>01268 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#a71e7675758c99acbe7785819b6a85a8f" title="Compute a simplified version of the silhouette coefficient.">simple_silhouette</a>(
<a name="l01269"></a>01269     rel_source VARCHAR,
<a name="l01270"></a>01270     expr_point VARCHAR,
<a name="l01271"></a>01271     centroids DOUBLE PRECISION[][],
<a name="l01272"></a>01272     fn_dist VARCHAR <span class="comment">/*+ DEFAULT &#39;dist_norm2&#39; */</span>
<a name="l01273"></a>01273 ) RETURNS DOUBLE PRECISION
<a name="l01274"></a>01274 STABLE
<a name="l01275"></a>01275 STRICT
<a name="l01276"></a>01276 LANGUAGE plpgsql
<a name="l01277"></a>01277 AS $$
<a name="l01278"></a>01278 DECLARE
<a name="l01279"></a>01279     class_rel_source REGCLASS;
<a name="l01280"></a>01280     proc_fn_dist REGPROCEDURE;
<a name="l01281"></a>01281     rel_filtered VARCHAR;
<a name="l01282"></a>01282 BEGIN
<a name="l01283"></a>01283     IF (array_upper(centroids,1) IS NULL) THEN
<a name="l01284"></a>01284     RAISE EXCEPTION &#39;No valid centroids given.&#39;;
<a name="l01285"></a>01285     END IF;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287     PERFORM MADLIB_SCHEMA.kmeans_is_valid_input(rel_source, expr_point);
<a name="l01288"></a>01288     rel_filtered = MADLIB_SCHEMA.__filter_input_relation(rel_source, expr_point);
<a name="l01289"></a>01289     class_rel_source := rel_filtered;
<a name="l01290"></a><a class="code" href="kmeans__new_8sql__in.html#a71e7675758c99acbe7785819b6a85a8f">01290</a>     proc_fn_dist := fn_dist
<a name="l01291"></a>01291         || &#39;(DOUBLE PRECISION[], DOUBLE PRECISION[])&#39;;
<a name="l01292"></a>01292     IF (SELECT prorettype != &#39;DOUBLE PRECISION&#39;::regtype OR proisagg = TRUE
<a name="l01293"></a>01293         FROM pg_proc WHERE oid = proc_fn_dist) THEN
<a name="l01294"></a>01294         RAISE EXCEPTION &#39;Distance function has wrong signature or is not a simple function.&#39;;
<a name="l01295"></a>01295     END IF;
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     RETURN MADLIB_SCHEMA.internal_execute_using_silhouette_args($sql$
<a name="l01298"></a>01298         SELECT
<a name="l01299"></a>01299             avg(CASE
<a name="l01300"></a>01300                     WHEN distances[2] = 0 THEN 0
<a name="l01301"></a>01301                     ELSE (distances[2] - distances[1]) / distances[2]
<a name="l01302"></a>01302                 END)
<a name="l01303"></a>01303         FROM (
<a name="l01304"></a>01304             SELECT
<a name="l01305"></a>01305                 (MADLIB_SCHEMA.<a class="code" href="linalg_8sql__in.html#ad3e16fc5435474b96b182ba20905461e" title="Given matrix  and vector  compute the columns of  that are closest to .">closest_columns</a>(
<a name="l01306"></a>01306                     $1,
<a name="l01307"></a>01307                     ($sql$ || expr_point || $sql$)::FLOAT8[],
<a name="l01308"></a>01308                     2::INTEGER,
<a name="l01309"></a>01309                     $2
<a name="l01310"></a>01310                 )).distances
<a name="l01311"></a>01311             FROM
<a name="l01312"></a>01312                 $sql$ || textin(regclassout(class_rel_source)) || $sql$
<a name="l01313"></a>01313         ) AS two_shortest_distances
<a name="l01314"></a>01314         $sql$,
<a name="l01315"></a>01315         centroids, proc_fn_dist);
<a name="l01316"></a>01316 END;
<a name="l01317"></a>01317 $$;
<a name="l01318"></a>01318 
<a name="l01319"></a>01319 CREATE FUNCTION MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#a71e7675758c99acbe7785819b6a85a8f" title="Compute a simplified version of the silhouette coefficient.">simple_silhouette</a>(
<a name="l01320"></a>01320     rel_source VARCHAR,
<a name="l01321"></a>01321     expr_point VARCHAR,
<a name="l01322"></a>01322     centroids DOUBLE PRECISION[][]
<a name="l01323"></a>01323 ) RETURNS DOUBLE PRECISION
<a name="l01324"></a>01324 STABLE
<a name="l01325"></a>01325 STRICT
<a name="l01326"></a>01326 LANGUAGE sql
<a name="l01327"></a>01327 AS $$
<a name="l01328"></a>01328     SELECT MADLIB_SCHEMA.<a class="code" href="kmeans__new_8sql__in.html#a71e7675758c99acbe7785819b6a85a8f" title="Compute a simplified version of the silhouette coefficient.">simple_silhouette</a>($1, $2, $3,
<a name="l01329"></a>01329         &#39;MADLIB_SCHEMA.<a class="code" href="linalg_8sql__in.html#aa58e51526edea6ea98db30b6f250adb4" title="2-norm of the difference between two vectors">dist_norm2</a>&#39;)
<a name="l01330"></a>01330 $$;
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="kmeans__new_8sql__in.html">kmeans_new.sql_in</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Wed Oct 31 2012 14:34:02 for MADlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
