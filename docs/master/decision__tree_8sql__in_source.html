<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MADlib: decision_tree.sql_in Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script src="../mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MADlib
   &#160;<span id="projectnumber">0.3</span>
   </div>
   <div id="projectbrief">User Documentation</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('decision__tree_8sql__in.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">decision_tree.sql_in</div>  </div>
</div>
<div class="contents">
<a href="decision__tree_8sql__in.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ----------------------------------------------------------------------- */</span><span class="comment">/** </span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * @file decision_tree.sql_in</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * @brief decision tree APIs and main controller written in PL/PGSQL</span>
<a name="l00006"></a>00006 <span class="comment"> * @date Dec. 22 2011</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * @sa For a brief introduction to decision trees, see the</span>
<a name="l00009"></a>00009 <span class="comment"> *     module description \ref grp_dectree.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> */</span><span class="comment">/* ----------------------------------------------------------------------- */</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 m4_include(`SQLCommon.m4<span class="stringliteral">&#39;)</span>
<a name="l00014"></a>00014 <span class="stringliteral"></span>
<a name="l00015"></a>00015 <span class="stringliteral">/* Own macro definitions */</span>
<a name="l00016"></a>00016 <span class="stringliteral">m4_ifelse(</span>
<a name="l00017"></a>00017 <span class="stringliteral">    m4_eval(</span>
<a name="l00018"></a>00018 <span class="stringliteral">        m4_ifdef(`__GREENPLUM__&#39;</span>, 1, 0) &amp;&amp;
<a name="l00019"></a>00019         __DBMS_VERSION_MAJOR__ * 100 + __DBMS_VERSION_MINOR__ &lt; 401
<a name="l00020"></a>00020     ), 1,
<a name="l00021"></a>00021     `m4_define(`__GREENPLUM_PRE_4_1__<span class="charliteral">&#39;)&#39;</span>
<a name="l00022"></a>00022 )
<a name="l00023"></a>00023 m4_ifelse(
<a name="l00024"></a>00024     m4_eval(
<a name="l00025"></a>00025         m4_ifdef(`__POSTGRESQL__<span class="stringliteral">&#39;, 1, 0) &amp;&amp;</span>
<a name="l00026"></a>00026 <span class="stringliteral">        __DBMS_VERSION_MAJOR__ &lt; 9</span>
<a name="l00027"></a>00027 <span class="stringliteral">    ), 1,</span>
<a name="l00028"></a>00028 <span class="stringliteral">    `m4_define(`__POSTGRESQL_PRE_9_0__&#39;</span>)<span class="stringliteral">&#39;</span>
<a name="l00029"></a>00029 <span class="stringliteral">)</span>
<a name="l00030"></a>00030 <span class="stringliteral"></span><span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">/**</span>
<a name="l00032"></a>00032 <span class="comment">@addtogroup grp_dectree</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">@about</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">This module provides an implementation of the C4.5 implementation to grow decision trees.</span>
<a name="l00037"></a>00037 <span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">The implementation supports:</span>
<a name="l00039"></a>00039 <span class="comment">- Tree Growth</span>
<a name="l00040"></a>00040 <span class="comment">- Multiple split critera, including:</span>
<a name="l00041"></a>00041 <span class="comment">  - Information Gain, also known as Kullback-Leibeler divergence:</span>
<a name="l00042"></a>00042 <span class="comment">  - Gini Coefficient:</span>
<a name="l00043"></a>00043 <span class="comment">  - Gain Ratio</span>
<a name="l00044"></a>00044 <span class="comment">- Tree Pruning</span>
<a name="l00045"></a>00045 <span class="comment">- Tree Scoring</span>
<a name="l00046"></a>00046 <span class="comment">- Tree Display</span>
<a name="l00047"></a>00047 <span class="comment">- Continuous and Discrete features</span>
<a name="l00048"></a>00048 <span class="comment">- Null handling</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">@input</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">The &lt;b&gt;training data&lt;/b&gt; is expected to be of </span>
<a name="l00053"></a>00053 <span class="comment">the following form:</span>
<a name="l00054"></a>00054 <span class="comment">&lt;pre&gt;{TABLE|VIEW} &lt;em&gt;trainingSource&lt;/em&gt; (</span>
<a name="l00055"></a>00055 <span class="comment">    ...</span>
<a name="l00056"></a>00056 <span class="comment">    &lt;em&gt;id&lt;/em&gt; INTEGER,</span>
<a name="l00057"></a>00057 <span class="comment">    &lt;em&gt;feature1&lt;/em&gt; ANYTYPE,</span>
<a name="l00058"></a>00058 <span class="comment">    &lt;em&gt;feature2&lt;/em&gt; ANYTYPE,</span>
<a name="l00059"></a>00059 <span class="comment">    &lt;em&gt;feature3&lt;/em&gt; ANYTYPE,</span>
<a name="l00060"></a>00060 <span class="comment">    ....................</span>
<a name="l00061"></a>00061 <span class="comment">    &lt;em&gt;featureN&lt;/em&gt; ANYTYPE,</span>
<a name="l00062"></a>00062 <span class="comment">    &lt;em&gt;class&lt;/em&gt; INTEGER,</span>
<a name="l00063"></a>00063 <span class="comment">    ...</span>
<a name="l00064"></a>00064 <span class="comment">)&lt;/pre&gt;</span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">The &lt;b&gt;data to classify&lt;/b&gt; is expected to be </span>
<a name="l00067"></a>00067 <span class="comment">of the following form:</span>
<a name="l00068"></a>00068 <span class="comment">&lt;pre&gt;{TABLE|VIEW} &lt;em&gt;classifySource&lt;/em&gt; (</span>
<a name="l00069"></a>00069 <span class="comment">    ...</span>
<a name="l00070"></a>00070 <span class="comment">    &lt;em&gt;id&lt;/em&gt; INTEGER,</span>
<a name="l00071"></a>00071 <span class="comment">    &lt;em&gt;feature1&lt;/em&gt; ANYTYPE,</span>
<a name="l00072"></a>00072 <span class="comment">    &lt;em&gt;feature2&lt;/em&gt; ANYTYPE,</span>
<a name="l00073"></a>00073 <span class="comment">    &lt;em&gt;feature3&lt;/em&gt; ANYTYPE,</span>
<a name="l00074"></a>00074 <span class="comment">    ....................</span>
<a name="l00075"></a>00075 <span class="comment">    &lt;em&gt;featureN&lt;/em&gt; ANYTYPE,</span>
<a name="l00076"></a>00076 <span class="comment">    ...</span>
<a name="l00077"></a>00077 <span class="comment">)&lt;/pre&gt;</span>
<a name="l00078"></a>00078 <span class="comment"></span>
<a name="l00079"></a>00079 <span class="comment">@usage</span>
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">- Run the training algorithm on the source data:</span>
<a name="l00082"></a>00082 <span class="comment">  &lt;pre&gt;SELECT * FROM \ref c45_train(</span>
<a name="l00083"></a>00083 <span class="comment">    &#39;&lt;em&gt;split_criterion_name&lt;/em&gt;&#39;,</span>
<a name="l00084"></a>00084 <span class="comment">    &#39;&lt;em&gt;training_table_name&lt;/em&gt;&#39;, </span>
<a name="l00085"></a>00085 <span class="comment">    &#39;&lt;em&gt;result_tree_table_name&lt;/em&gt;&#39;, </span>
<a name="l00086"></a>00086 <span class="comment">    &#39;&lt;em&gt;validation_table_name&lt;/em&gt;&#39;,</span>
<a name="l00087"></a>00087 <span class="comment">    &#39;&lt;em&gt;continuous_feature_names&lt;/em&gt;&#39;,</span>
<a name="l00088"></a>00088 <span class="comment">    &#39;&lt;em&gt;feature_col_names&lt;/em&gt;&#39;,</span>
<a name="l00089"></a>00089 <span class="comment">    &#39;&lt;em&gt;id_col_name&lt;/em&gt;&#39;, </span>
<a name="l00090"></a>00090 <span class="comment">    &#39;&lt;em&gt;class_col_name&lt;/em&gt;&#39;,</span>
<a name="l00091"></a>00091 <span class="comment">    &#39;&lt;em&gt;confidence_level&lt;/em&gt;&#39;,</span>
<a name="l00092"></a>00092 <span class="comment">    &#39;&lt;em&gt;how2handle_missing_value&lt;/em&gt;&#39;</span>
<a name="l00093"></a>00093 <span class="comment">    &#39;&lt;em&gt;max_num_iter&lt;/em&gt;&#39;,</span>
<a name="l00094"></a>00094 <span class="comment">    &#39;&lt;em&gt;max_tree_depth&lt;/em&gt;&#39;,</span>
<a name="l00095"></a>00095 <span class="comment">    &#39;&lt;em&gt;min_percent_mode&lt;/em&gt;&#39;,</span>
<a name="l00096"></a>00096 <span class="comment">    &#39;&lt;em&gt;min_percent_split&lt;/em&gt;&#39;</span>
<a name="l00097"></a>00097 <span class="comment">    &#39;&lt;em&gt;verbosity&lt;/em&gt;&#39;);</span>
<a name="l00098"></a>00098 <span class="comment">  &lt;/pre&gt;</span>
<a name="l00099"></a>00099 <span class="comment">  This will create the decision tree output table storing an abstract object</span>
<a name="l00100"></a>00100 <span class="comment">  (representing the model) used for further classification. Column names:</span>
<a name="l00101"></a>00101 <span class="comment">  &lt;pre&gt;    </span>
<a name="l00102"></a>00102 <span class="comment"> id | tree_location | feature |    probability    |    ebp_coeff     | maxclass |    split_gain     | live | cat_size | parent_id |     jump      | is_feature_cont | split_value </span>
<a name="l00103"></a>00103 <span class="comment">----+---------------+---------+-------------+-----------+----------+------------+------+----------+-----------+------+-----------------+-------------</span>
<a name="l00104"></a>00104 <span class="comment">                                                     ...&lt;/pre&gt;    </span>
<a name="l00105"></a>00105 <span class="comment">    </span>
<a name="l00106"></a>00106 <span class="comment">- Run the classification function using the learned model: </span>
<a name="l00107"></a>00107 <span class="comment">  &lt;pre&gt;SELECT * FROM \ref c45_classify(</span>
<a name="l00108"></a>00108 <span class="comment">    &#39;&lt;em&gt;tree_table_name&lt;/em&gt;&#39;, </span>
<a name="l00109"></a>00109 <span class="comment">    &#39;&lt;em&gt;classification_table_name&lt;/em&gt;&#39;, </span>
<a name="l00110"></a>00110 <span class="comment">    &#39;&lt;em&gt;result_table_name&lt;/em&gt;&#39;);&lt;/pre&gt;</span>
<a name="l00111"></a>00111 <span class="comment">  This will create the result_table with the </span>
<a name="l00112"></a>00112 <span class="comment">  classification results. </span>
<a name="l00113"></a>00113 <span class="comment">  &lt;pre&gt; &lt;/pre&gt; </span>
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">- Run the scorinf function to score the learned model against a validation data set:</span>
<a name="l00116"></a>00116 <span class="comment">  &lt;pre&gt;SELECT * FROM \ref c45_score(</span>
<a name="l00117"></a>00117 <span class="comment">    &#39;&lt;em&gt;tree_table_name&lt;/em&gt;&#39;,</span>
<a name="l00118"></a>00118 <span class="comment">    &#39;&lt;em&gt;validation_table_name&lt;/em&gt;&#39;,</span>
<a name="l00119"></a>00119 <span class="comment">    &#39;&lt;em&gt;verbosity&lt;/em&gt;&#39;);&lt;/pre&gt;</span>
<a name="l00120"></a>00120 <span class="comment">  This will give a ratio of correctly classified items in the validation set.</span>
<a name="l00121"></a>00121 <span class="comment">  &lt;pre&gt; &lt;/pre&gt;</span>
<a name="l00122"></a>00122 <span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment">- Run the display tree function using the learned model: </span>
<a name="l00124"></a>00124 <span class="comment">  &lt;pre&gt;SELECT * FROM \ref c45_display(</span>
<a name="l00125"></a>00125 <span class="comment">    &#39;&lt;em&gt;tree_table_name&lt;/em&gt;&#39;);&lt;/pre&gt;</span>
<a name="l00126"></a>00126 <span class="comment">  This will display the trained tree in human readable format. </span>
<a name="l00127"></a>00127 <span class="comment">  &lt;pre&gt; &lt;/pre&gt; </span>
<a name="l00128"></a>00128 <span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">- Run the clean tree function as below: </span>
<a name="l00130"></a>00130 <span class="comment">  &lt;pre&gt;SELECT * FROM \ref c45_clean(</span>
<a name="l00131"></a>00131 <span class="comment">    &#39;&lt;em&gt;tree_table_name&lt;/em&gt;&#39;);&lt;/pre&gt;</span>
<a name="l00132"></a>00132 <span class="comment">  This will clean up the learned model and all metadata.</span>
<a name="l00133"></a>00133 <span class="comment">  &lt;pre&gt; &lt;/pre&gt; </span>
<a name="l00134"></a>00134 <span class="comment"></span>
<a name="l00135"></a>00135 <span class="comment">@examp</span>
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment">-# Prepare an input table/view, e.g.:</span>
<a name="l00138"></a>00138 <span class="comment">\verbatim</span>
<a name="l00139"></a>00139 <span class="comment">sql&gt; select * from golf_data order by id;</span>
<a name="l00140"></a>00140 <span class="comment"> id | outlook  | temperature | humidity | windy  |    class     </span>
<a name="l00141"></a>00141 <span class="comment">----+----------+-------------+----------+--------+--------------</span>
<a name="l00142"></a>00142 <span class="comment">  1 | sunny    |          85 |       85 |  false |  Do not Play</span>
<a name="l00143"></a>00143 <span class="comment">  2 | sunny    |          80 |       90 |  true  |  Do not Play</span>
<a name="l00144"></a>00144 <span class="comment">  3 | overcast |          83 |       78 |  false |  Play</span>
<a name="l00145"></a>00145 <span class="comment">  4 | rain     |          70 |       96 |  false |  Play</span>
<a name="l00146"></a>00146 <span class="comment">  5 | rain     |          68 |       80 |  false |  Play</span>
<a name="l00147"></a>00147 <span class="comment">  6 | rain     |          65 |       70 |  true  |  Do not Play</span>
<a name="l00148"></a>00148 <span class="comment">  7 | overcast |          64 |       65 |  true  |  Play</span>
<a name="l00149"></a>00149 <span class="comment">  8 | sunny    |          72 |       95 |  false |  Do not Play</span>
<a name="l00150"></a>00150 <span class="comment">  9 | sunny    |          69 |       70 |  false |  Play</span>
<a name="l00151"></a>00151 <span class="comment"> 10 | rain     |          75 |       80 |  false |  Play</span>
<a name="l00152"></a>00152 <span class="comment"> 11 | sunny    |          75 |       70 |  true  |  Play</span>
<a name="l00153"></a>00153 <span class="comment"> 12 | overcast |          72 |       90 |  true  |  Play</span>
<a name="l00154"></a>00154 <span class="comment"> 13 | overcast |          81 |       75 |  false |  Play</span>
<a name="l00155"></a>00155 <span class="comment"> 14 | rain     |          71 |       80 |  true  |  Do not Play</span>
<a name="l00156"></a>00156 <span class="comment">(14 rows)</span>
<a name="l00157"></a>00157 <span class="comment"></span>
<a name="l00158"></a>00158 <span class="comment">\endverbatim</span>
<a name="l00159"></a>00159 <span class="comment">-# Train the decision tree model, e.g.:</span>
<a name="l00160"></a>00160 <span class="comment">\verbatim</span>
<a name="l00161"></a>00161 <span class="comment">sql&gt; SELECT * FROM madlib.c45_clean(&#39;trained_tree_infogain&#39;);</span>
<a name="l00162"></a>00162 <span class="comment">sql&gt; SELECT * FROM MADLIB.c45_train(</span>
<a name="l00163"></a>00163 <span class="comment">       &#39;infogain&#39;,                       -- split criterion_name</span>
<a name="l00164"></a>00164 <span class="comment">       &#39;golf_data&#39;,                      -- input table name</span>
<a name="l00165"></a>00165 <span class="comment">       &#39;trained_tree_infogain&#39;,          -- result tree name</span>
<a name="l00166"></a>00166 <span class="comment">       null,                             -- validation table name</span>
<a name="l00167"></a>00167 <span class="comment">       &#39;temperature,humidity&#39;,           -- continuous feature names</span>
<a name="l00168"></a>00168 <span class="comment">       &#39;outlook,temperature,humidity,windy&#39;, -- feature column names</span>
<a name="l00169"></a>00169 <span class="comment">       &#39;id&#39;,                             -- id column name</span>
<a name="l00170"></a>00170 <span class="comment">       &#39;class&#39;,                          -- class column name</span>
<a name="l00171"></a>00171 <span class="comment">       100,                              -- confidence level</span>
<a name="l00172"></a>00172 <span class="comment">       &#39;explicit&#39;,                       -- missing value preparation</span>
<a name="l00173"></a>00173 <span class="comment">       100,                              -- max iterations</span>
<a name="l00174"></a>00174 <span class="comment">       5,                                -- max tree depth</span>
<a name="l00175"></a>00175 <span class="comment">       0.001,                            -- min percent mode</span>
<a name="l00176"></a>00176 <span class="comment">       0.001,                            -- min percent split</span>
<a name="l00177"></a>00177 <span class="comment">       0);                               -- verbosity</span>
<a name="l00178"></a>00178 <span class="comment"> training_set_size | tree_nodes | tree_depth |    cost_time    | split_criterion </span>
<a name="l00179"></a>00179 <span class="comment">-------------------+------------+------------+-----------------+-----------------</span>
<a name="l00180"></a>00180 <span class="comment">                14 |          8 |          3 | 00:00:00.871805 | infogain</span>
<a name="l00181"></a>00181 <span class="comment">(1 row)</span>
<a name="l00182"></a>00182 <span class="comment">\endverbatim</span>
<a name="l00183"></a>00183 <span class="comment">-# Check few rows from the tree model table:</span>
<a name="l00184"></a>00184 <span class="comment">\verbatim</span>
<a name="l00185"></a>00185 <span class="comment">sql&gt; select * from trained_tree_infogain order by id;</span>
<a name="l00186"></a>00186 <span class="comment"> id | tree_location | feature |    probability    |    ebp_coeff     | maxclass |    split_gain     | live | cat_size | parent_id |     jump      | is_feature_cont | split_value </span>
<a name="l00187"></a>00187 <span class="comment">----+---------------+---------+-------------------+-----------+----------+-------------------+------+----------+-----------+---------------+-----------------+-------------</span>
<a name="l00188"></a>00188 <span class="comment">  1 | {0}           |       3 | 0.642857142857143 |         1 |        2 | 0.171033941880327 |    0 |       14 |         0 | [2:4]={2,3,4} | f               |            </span>
<a name="l00189"></a>00189 <span class="comment">  2 | {0,1}         |       4 |                 1 |         1 |        2 |                 0 |    0 |        4 |         1 |               | f               |            </span>
<a name="l00190"></a>00190 <span class="comment">  3 | {0,2}         |       4 |               0.6 |         1 |        2 | 0.673011667009257 |    0 |        5 |         1 | [2:3]={5,6}   | f               |            </span>
<a name="l00191"></a>00191 <span class="comment">  4 | {0,3}         |       2 |               0.6 |         1 |        1 | 0.673011667009257 |    0 |        5 |         1 | [2:3]={7,8}   | t               |          70</span>
<a name="l00192"></a>00192 <span class="comment">  5 | {0,2,1}       |       4 |                 1 |         1 |        2 |                 0 |    0 |        3 |         3 |               | f               |            </span>
<a name="l00193"></a>00193 <span class="comment">  6 | {0,2,2}       |       4 |                 1 |         1 |        1 |                 0 |    0 |        2 |         3 |               | f               |            </span>
<a name="l00194"></a>00194 <span class="comment">  7 | {0,3,1}       |       4 |                 1 |         1 |        2 |                 0 |    0 |        2 |         4 |               | f               |            </span>
<a name="l00195"></a>00195 <span class="comment">  8 | {0,3,2}       |       4 |                 1 |         1 |        1 |                 0 |    0 |        3 |         4 |               | f               |            </span>
<a name="l00196"></a>00196 <span class="comment">(8 rows)</span>
<a name="l00197"></a>00197 <span class="comment"></span>
<a name="l00198"></a>00198 <span class="comment">\endverbatim</span>
<a name="l00199"></a>00199 <span class="comment">-# To display the tree with human readable format:</span>
<a name="l00200"></a>00200 <span class="comment">\verbatim</span>
<a name="l00201"></a>00201 <span class="comment">sql&gt; select madlib.c45_display(&#39;trained_tree_infogain&#39;);</span>
<a name="l00202"></a>00202 <span class="comment">                                      c45_display                                      </span>
<a name="l00203"></a>00203 <span class="comment">---------------------------------------------------------------------------------------</span>
<a name="l00204"></a>00204 <span class="comment">     Root Node  : class(  Play)   num_elements(14)  predict_prob(0.642857142857143)          </span>
<a name="l00205"></a>00205 <span class="comment">         outlook:  = overcast : class( Play)   num_elements(4)  predict_prob(1)        </span>
<a name="l00206"></a>00206 <span class="comment">         outlook:  = rain : class( Play)   num_elements(5)  predict_prob(0.6)          </span>
<a name="l00207"></a>00207 <span class="comment">             windy:  =  false : class( Play)   num_elements(3)  predict_prob(1)        </span>
<a name="l00208"></a>00208 <span class="comment">             windy:  = true  : class(  Do not Play)   num_elements(2)  predict_prob(1)       </span>
<a name="l00209"></a>00209 <span class="comment">         outlook:  =  sunny      : class(  Do not Play)   num_elements(5)  predict_prob(0.6) </span>
<a name="l00210"></a>00210 <span class="comment">             humidity:  &lt;= 70 : class( Play)   num_elements(2)  predict_prob(1)      </span>
<a name="l00211"></a>00211 <span class="comment">             humidity:  &gt; 70  : class(  Do not Play)   num_elements(3)  predict_prob(1)      </span>
<a name="l00212"></a>00212 <span class="comment">(1 row)</span>
<a name="l00213"></a>00213 <span class="comment"></span>
<a name="l00214"></a>00214 <span class="comment">\endverbatim</span>
<a name="l00215"></a>00215 <span class="comment">-# To classify data with the learned model:</span>
<a name="l00216"></a>00216 <span class="comment">\verbatim</span>
<a name="l00217"></a>00217 <span class="comment">sql&gt; select * from madlib.c45_classify</span>
<a name="l00218"></a>00218 <span class="comment">         &#39;trained_tree_infogain&#39;,  -- name of the trained model</span>
<a name="l00219"></a>00219 <span class="comment">         &#39;golf_data&#39;,              -- name of the table containing data to classify</span>
<a name="l00220"></a>00220 <span class="comment">         &#39;classification_result&#39;); -- name of the output table</span>
<a name="l00221"></a>00221 <span class="comment"> input_set_size |    cost_time    </span>
<a name="l00222"></a>00222 <span class="comment">----------------+-----------------</span>
<a name="l00223"></a>00223 <span class="comment">             14 | 00:00:00.247713</span>
<a name="l00224"></a>00224 <span class="comment">(1 row)</span>
<a name="l00225"></a>00225 <span class="comment">\endverbatim</span>
<a name="l00226"></a>00226 <span class="comment">-# Check classification results: </span>
<a name="l00227"></a>00227 <span class="comment">\verbatim</span>
<a name="l00228"></a>00228 <span class="comment">sql&gt; select t.id,t.outlook,t.temperature,t.humidity,t.windy,c.class from</span>
<a name="l00229"></a>00229 <span class="comment">    madlib.classification_result c,golf_data t where t.id=c.id order by id;</span>
<a name="l00230"></a>00230 <span class="comment"> id | outlook  | temperature | humidity | windy  | class </span>
<a name="l00231"></a>00231 <span class="comment">----+------------+-------------+----------+-------+-------</span>
<a name="l00232"></a>00232 <span class="comment">  1 |  sunny     |          85 |       85 | f     |     1</span>
<a name="l00233"></a>00233 <span class="comment">  2 |  sunny     |          80 |       90 | t     |     1</span>
<a name="l00234"></a>00234 <span class="comment">  3 |  overcast  |          83 |       78 | f     |     2</span>
<a name="l00235"></a>00235 <span class="comment">  4 |  rain      |          70 |       96 | f     |     2</span>
<a name="l00236"></a>00236 <span class="comment">  5 |  rain      |          68 |       80 | f     |     2</span>
<a name="l00237"></a>00237 <span class="comment">  6 |  rain      |          65 |       70 | t     |     1</span>
<a name="l00238"></a>00238 <span class="comment">  7 |  overcast  |          64 |       65 | t     |     2</span>
<a name="l00239"></a>00239 <span class="comment">  8 |  sunny     |          72 |       95 | f     |     1</span>
<a name="l00240"></a>00240 <span class="comment">  9 |  sunny     |          69 |       70 | f     |     2</span>
<a name="l00241"></a>00241 <span class="comment"> 10 |  rain      |          75 |       80 | f     |     2</span>
<a name="l00242"></a>00242 <span class="comment"> 11 |  sunny     |          75 |       70 | t     |     2</span>
<a name="l00243"></a>00243 <span class="comment"> 12 |  overcast  |          72 |       90 | t     |     2</span>
<a name="l00244"></a>00244 <span class="comment"> 13 |  overcast  |          81 |       75 | f     |     2</span>
<a name="l00245"></a>00245 <span class="comment"> 14 |  rain      |          71 |       80 | t     |     1</span>
<a name="l00246"></a>00246 <span class="comment">(14 rows)</span>
<a name="l00247"></a>00247 <span class="comment">(notes: The class value of 2 refers to &#39;do not play&#39;. The class value of 1</span>
<a name="l00248"></a>00248 <span class="comment">refers to &#39;Play&#39;. We plan to add a view to translate the numeric value to original</span>
<a name="l00249"></a>00249 <span class="comment">value soon.</span>
<a name="l00250"></a>00250 <span class="comment">\endverbatim</span>
<a name="l00251"></a>00251 <span class="comment"></span>
<a name="l00252"></a>00252 <span class="comment">-# Score the data against a validation set:</span>
<a name="l00253"></a>00253 <span class="comment">\verbatim</span>
<a name="l00254"></a>00254 <span class="comment">sql&gt; select * from madlib.c45_score(</span>
<a name="l00255"></a>00255 <span class="comment">        &#39;trained_tree_infogain&#39;,</span>
<a name="l00256"></a>00256 <span class="comment">        &#39;golf_data_validation&#39;,</span>
<a name="l00257"></a>00257 <span class="comment">        false);</span>
<a name="l00258"></a>00258 <span class="comment"> c45_score </span>
<a name="l00259"></a>00259 <span class="comment">-----------</span>
<a name="l00260"></a>00260 <span class="comment">      0.98</span>
<a name="l00261"></a>00261 <span class="comment">(1 row)</span>
<a name="l00262"></a>00262 <span class="comment">\endverbatim</span>
<a name="l00263"></a>00263 <span class="comment"></span>
<a name="l00264"></a>00264 <span class="comment"></span>
<a name="l00265"></a>00265 <span class="comment">-# clean up the tree and metadata: </span>
<a name="l00266"></a>00266 <span class="comment">\verbatim</span>
<a name="l00267"></a>00267 <span class="comment">testdb=# select madlib.c45_clean(&#39;trained_tree_infogain&#39;);</span>
<a name="l00268"></a>00268 <span class="comment"> c45_clean </span>
<a name="l00269"></a>00269 <span class="comment">-----------</span>
<a name="l00270"></a>00270 <span class="comment"> </span>
<a name="l00271"></a>00271 <span class="comment">(1 row)</span>
<a name="l00272"></a>00272 <span class="comment">\endverbatim</span>
<a name="l00273"></a>00273 <span class="comment"></span>
<a name="l00274"></a>00274 <span class="comment">@literature</span>
<a name="l00275"></a>00275 <span class="comment"></span>
<a name="l00276"></a>00276 <span class="comment">[1] http://en.wikipedia.org/wiki/C4.5_algorithm</span>
<a name="l00277"></a>00277 <span class="comment"></span>
<a name="l00278"></a>00278 <span class="comment">@sa File decision_tree.sql_in documenting the SQL functions.</span>
<a name="l00279"></a>00279 <span class="comment">*/</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 /*
<a name="l00282"></a>00282  * This structure is used to store the result for the function of c45_train.
<a name="l00283"></a>00283  *      training_set_size: It means how many records there exists in 
<a name="l00284"></a>00284  *                         the training set.
<a name="l00285"></a>00285  *      tree_nodes:        It is the number of total tree nodes.
<a name="l00286"></a>00286  *      tree_depth:        It is the depth of the trained tree.
<a name="l00287"></a>00287  *      cost_time:         It is the time consumed during training the tree.
<a name="l00288"></a>00288  *      split_criterion:   It is the split criterion used to train the tree.
<a name="l00289"></a>00289  */
<a name="l00290"></a>00290 DROP TYPE IF EXISTS MADLIB_SCHEMA.c45_train_result;
<a name="l00291"></a>00291 CREATE TYPE MADLIB_SCHEMA.c45_train_result AS 
<a name="l00292"></a>00292     (   
<a name="l00293"></a>00293     training_set_size        BIGINT,   
<a name="l00294"></a>00294     tree_nodes               BIGINT,
<a name="l00295"></a>00295     tree_depth               INT,
<a name="l00296"></a>00296     cost_time                INTERVAL,
<a name="l00297"></a>00297     split_criterion          TEXT
<a name="l00298"></a>00298     );
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 /*
<a name="l00301"></a>00301  * This structure is used to store the result for the function of c45_classify.
<a name="l00302"></a>00302  *      input_set_size:    It means how many records there exists in 
<a name="l00303"></a>00303  *                         the classification set.
<a name="l00304"></a>00304  *      cost_time:         It is the time consumed during classifying the tree.
<a name="l00305"></a>00305  */
<a name="l00306"></a>00306 DROP TYPE IF EXISTS MADLIB_SCHEMA.c45_classify_result;
<a name="l00307"></a>00307 CREATE TYPE MADLIB_SCHEMA.c45_classify_result AS 
<a name="l00308"></a>00308     (   
<a name="l00309"></a>00309     input_set_size        BIGINT,   
<a name="l00310"></a>00310     cost_time             INTERVAL
<a name="l00311"></a>00311     );
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__scv_aggr_sfunc
<a name="l00314"></a>00314     (
<a name="l00315"></a>00315     result              FLOAT8[],
<a name="l00316"></a>00316     split_criterion     INT,
<a name="l00317"></a>00317     feature_value       FLOAT8,
<a name="l00318"></a>00318     class               FLOAT8,
<a name="l00319"></a>00319     is_cont             boolean,
<a name="l00320"></a>00320     le                  FLOAT8,
<a name="l00321"></a>00321     gt                  FLOAT8,
<a name="l00322"></a>00322     true_total_count    FLOAT8
<a name="l00323"></a>00323     )CASCADE;
<a name="l00324"></a>00324 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__scv_aggr_sfunc
<a name="l00325"></a>00325     (
<a name="l00326"></a>00326     result              FLOAT8[],
<a name="l00327"></a>00327     split_criterion     INT,
<a name="l00328"></a>00328     feature_value       FLOAT8,
<a name="l00329"></a>00329     class               FLOAT8,
<a name="l00330"></a>00330     is_cont             boolean,
<a name="l00331"></a>00331     le                  FLOAT8,
<a name="l00332"></a>00332     gt                  FLOAT8,
<a name="l00333"></a>00333     true_total_count    FLOAT8
<a name="l00334"></a>00334     ) 
<a name="l00335"></a>00335 RETURNS FLOAT8[]  
<a name="l00336"></a>00336 AS &#39;MODULE_PATHNAME<span class="stringliteral">&#39;, &#39;</span>scv_aggr_sfunc<span class="stringliteral">&#39;</span>
<a name="l00337"></a>00337 <span class="stringliteral">LANGUAGE C IMMUTABLE;</span>
<a name="l00338"></a>00338 <span class="stringliteral"></span>
<a name="l00339"></a>00339 <span class="stringliteral">DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__scv_aggr_prefunc</span>
<a name="l00340"></a>00340 <span class="stringliteral">    (</span>
<a name="l00341"></a>00341 <span class="stringliteral">    FLOAT8[], </span>
<a name="l00342"></a>00342 <span class="stringliteral">    FLOAT8[]</span>
<a name="l00343"></a>00343 <span class="stringliteral">    ) CASCADE;</span>
<a name="l00344"></a>00344 <span class="stringliteral">CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__scv_aggr_prefunc</span>
<a name="l00345"></a>00345 <span class="stringliteral">    (</span>
<a name="l00346"></a>00346 <span class="stringliteral">    sfunc1_result     FLOAT8[],</span>
<a name="l00347"></a>00347 <span class="stringliteral">    sfunc2_result     FLOAT8[]</span>
<a name="l00348"></a>00348 <span class="stringliteral">    ) </span>
<a name="l00349"></a>00349 <span class="stringliteral">RETURNS FLOAT8[]</span>
<a name="l00350"></a>00350 <span class="stringliteral">AS &#39;</span>MODULE_PATHNAME<span class="stringliteral">&#39;, &#39;</span>scv_aggr_prefunc<span class="stringliteral">&#39;</span>
<a name="l00351"></a>00351 <span class="stringliteral">LANGUAGE C STRICT IMMUTABLE;</span>
<a name="l00352"></a>00352 <span class="stringliteral"></span>
<a name="l00353"></a>00353 <span class="stringliteral">DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__scv_aggr_ffunc</span>
<a name="l00354"></a>00354 <span class="stringliteral">    (</span>
<a name="l00355"></a>00355 <span class="stringliteral">    FLOAT8[]</span>
<a name="l00356"></a>00356 <span class="stringliteral">    ) CASCADE;</span>
<a name="l00357"></a>00357 <span class="stringliteral">CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__scv_aggr_ffunc</span>
<a name="l00358"></a>00358 <span class="stringliteral">    (</span>
<a name="l00359"></a>00359 <span class="stringliteral">    internal_result     FLOAT8[]</span>
<a name="l00360"></a>00360 <span class="stringliteral">    ) </span>
<a name="l00361"></a>00361 <span class="stringliteral">RETURNS FLOAT8[]</span>
<a name="l00362"></a>00362 <span class="stringliteral">AS &#39;</span>MODULE_PATHNAME<span class="stringliteral">&#39;, &#39;</span>scv_aggr_ffunc<span class="stringliteral">&#39;</span>
<a name="l00363"></a>00363 <span class="stringliteral">LANGUAGE C STRICT IMMUTABLE;</span>
<a name="l00364"></a>00364 <span class="stringliteral"></span>
<a name="l00365"></a>00365 <span class="stringliteral">DROP TYPE IF EXISTS MADLIB_SCHEMA.__scv_aggr_result CASCADE;</span>
<a name="l00366"></a>00366 <span class="stringliteral">CREATE TYPE MADLIB_SCHEMA.__scv_aggr_result AS</span>
<a name="l00367"></a>00367 <span class="stringliteral">    (</span>
<a name="l00368"></a>00368 <span class="stringliteral">    info_impurity       FLOAT8,</span>
<a name="l00369"></a>00369 <span class="stringliteral">    class_prob          FLOAT8,</span>
<a name="l00370"></a>00370 <span class="stringliteral">    class_id            INT,</span>
<a name="l00371"></a>00371 <span class="stringliteral">    total_size          FLOAT8,</span>
<a name="l00372"></a>00372 <span class="stringliteral">    is_cont             BOOLEAN</span>
<a name="l00373"></a>00373 <span class="stringliteral">    );</span>
<a name="l00374"></a>00374 <span class="stringliteral"></span>
<a name="l00375"></a>00375 <span class="stringliteral">DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.__scv_aggr</span>
<a name="l00376"></a>00376 <span class="stringliteral">    (</span>
<a name="l00377"></a>00377 <span class="stringliteral">    INT,</span>
<a name="l00378"></a>00378 <span class="stringliteral">    FLOAT8,</span>
<a name="l00379"></a>00379 <span class="stringliteral">    FLOAT8,</span>
<a name="l00380"></a>00380 <span class="stringliteral">    boolean,</span>
<a name="l00381"></a>00381 <span class="stringliteral">    FLOAT8,</span>
<a name="l00382"></a>00382 <span class="stringliteral">    FLOAT8,</span>
<a name="l00383"></a>00383 <span class="stringliteral">    FLOAT8</span>
<a name="l00384"></a>00384 <span class="stringliteral">    ) CASCADE;</span>
<a name="l00385"></a>00385 <span class="stringliteral">CREATE</span>
<a name="l00386"></a>00386 <span class="stringliteral">m4_ifdef(`__GREENPLUM__&#39;</span>, m4_ifdef(`__HAS_ORDERED_AGGREGATES__<span class="stringliteral">&#39;, `ORDERED&#39;</span>))
<a name="l00387"></a>00387 AGGREGATE MADLIB_SCHEMA.__scv_aggr
<a name="l00388"></a>00388     (
<a name="l00389"></a>00389     INT,
<a name="l00390"></a>00390     FLOAT8,
<a name="l00391"></a>00391     FLOAT8,
<a name="l00392"></a>00392     <span class="keywordtype">boolean</span>,
<a name="l00393"></a>00393     FLOAT8,
<a name="l00394"></a>00394     FLOAT8,
<a name="l00395"></a>00395     FLOAT8
<a name="l00396"></a>00396     ) 
<a name="l00397"></a>00397 (
<a name="l00398"></a>00398   SFUNC=MADLIB_SCHEMA.__scv_aggr_sfunc,
<a name="l00399"></a>00399   m4_ifdef(`__GREENPLUM__<span class="stringliteral">&#39;, m4_ifdef(`__HAS_ORDERED_AGGREGATES__&#39;</span>, `<span class="stringliteral">&#39;, ``prefunc=MADLIB_SCHEMA.__scv_aggr_prefunc,&#39;</span><span class="stringliteral">&#39;))</span>
<a name="l00400"></a>00400 <span class="stringliteral">  FINALFUNC=MADLIB_SCHEMA.__scv_aggr_ffunc,</span>
<a name="l00401"></a>00401 <span class="stringliteral">  STYPE=FLOAT8[],</span>
<a name="l00402"></a>00402 <span class="stringliteral">  initcond = &#39;</span>{0,0,0,0,0,0,0,0,0,0,0,0,0,0}<span class="stringliteral">&#39;</span>
<a name="l00403"></a>00403 <span class="stringliteral">);</span>
<a name="l00404"></a>00404 <span class="stringliteral"></span>
<a name="l00405"></a>00405 <span class="stringliteral">DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__scv_aggr_wrapper</span>
<a name="l00406"></a>00406 <span class="stringliteral">    (</span>
<a name="l00407"></a>00407 <span class="stringliteral">    internal_result FLOAT8[]</span>
<a name="l00408"></a>00408 <span class="stringliteral">    ) CASCADE;</span>
<a name="l00409"></a>00409 <span class="stringliteral">CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__scv_aggr_wrapper(</span>
<a name="l00410"></a>00410 <span class="stringliteral">    internal_result FLOAT8[]</span>
<a name="l00411"></a>00411 <span class="stringliteral">    )</span>
<a name="l00412"></a>00412 <span class="stringliteral">RETURNS MADLIB_SCHEMA.__scv_aggr_result AS $$</span>
<a name="l00413"></a>00413 <span class="stringliteral">DECLARE</span>
<a name="l00414"></a>00414 <span class="stringliteral">    result              MADLIB_SCHEMA.__scv_aggr_result;</span>
<a name="l00415"></a>00415 <span class="stringliteral">    split_criterion     INT;</span>
<a name="l00416"></a>00416 <span class="stringliteral">    calc_pre_split      INT;</span>
<a name="l00417"></a>00417 <span class="stringliteral">    is_cont             INT;</span>
<a name="l00418"></a>00418 <span class="stringliteral">BEGIN</span>
<a name="l00419"></a>00419 <span class="stringliteral">    split_criterion = internal_result[4];</span>
<a name="l00420"></a>00420 <span class="stringliteral">    is_cont = internal_result[8];</span>
<a name="l00421"></a>00421 <span class="stringliteral"></span>
<a name="l00422"></a>00422 <span class="stringliteral">    IF ( split_criterion = 1 ) THEN</span>
<a name="l00423"></a>00423 <span class="stringliteral">        result.info_impurity = internal_result[5];</span>
<a name="l00424"></a>00424 <span class="stringliteral">    ELSIF( split_criterion = 2 ) THEN</span>
<a name="l00425"></a>00425 <span class="stringliteral">        result.info_impurity = internal_result[6];</span>
<a name="l00426"></a>00426 <span class="stringliteral">    ELSE</span>
<a name="l00427"></a>00427 <span class="stringliteral">        result.info_impurity = internal_result[7];</span>
<a name="l00428"></a>00428 <span class="stringliteral">    END IF;</span>
<a name="l00429"></a>00429 <span class="stringliteral">    </span>
<a name="l00430"></a>00430 <span class="stringliteral">    result.class_id   = internal_result[9];</span>
<a name="l00431"></a>00431 <span class="stringliteral">    result.class_prob = internal_result[10];</span>
<a name="l00432"></a>00432 <span class="stringliteral">    result.total_size = internal_result[11];</span>
<a name="l00433"></a>00433 <span class="stringliteral">    </span>
<a name="l00434"></a>00434 <span class="stringliteral">    IF ((NOT result.total_size&gt;0) OR</span>
<a name="l00435"></a>00435 <span class="stringliteral">            result.class_prob&lt;0 OR </span>
<a name="l00436"></a>00436 <span class="stringliteral">            result.class_prob&gt;1) THEN</span>
<a name="l00437"></a>00437 <span class="stringliteral">        RAISE EXCEPTION &#39;</span>total_size is %,class_prob is %<span class="stringliteral">&#39;, </span>
<a name="l00438"></a>00438 <span class="stringliteral">            result.total_size,result.class_prob;</span>
<a name="l00439"></a>00439 <span class="stringliteral">    END IF;</span>
<a name="l00440"></a>00440 <span class="stringliteral"></span>
<a name="l00441"></a>00441 <span class="stringliteral">    IF (is_cont&gt;0) THEN</span>
<a name="l00442"></a>00442 <span class="stringliteral">        result.is_cont = &#39;</span>t<span class="stringliteral">&#39;;</span>
<a name="l00443"></a>00443 <span class="stringliteral">    ELSE</span>
<a name="l00444"></a>00444 <span class="stringliteral">        result.is_cont = &#39;</span>f<span class="stringliteral">&#39;;</span>
<a name="l00445"></a>00445 <span class="stringliteral">    END IF;</span>
<a name="l00446"></a>00446 <span class="stringliteral">    RETURN result;</span>
<a name="l00447"></a>00447 <span class="stringliteral">END </span>
<a name="l00448"></a>00448 <span class="stringliteral">$$ LANGUAGE PLPGSQL;</span>
<a name="l00449"></a>00449 <span class="stringliteral"></span>
<a name="l00450"></a>00450 <span class="stringliteral"></span>
<a name="l00451"></a>00451 <span class="stringliteral">/*</span>
<a name="l00452"></a>00452 <span class="stringliteral"> * Attribute info type</span>
<a name="l00453"></a>00453 <span class="stringliteral"> * Parameters:</span>
<a name="l00454"></a>00454 <span class="stringliteral"> *      fid:    feature index</span>
<a name="l00455"></a>00455 <span class="stringliteral"> *      fval:   feature value</span>
<a name="l00456"></a>00456 <span class="stringliteral"> *      is_cont: is continuous feature or not</span>
<a name="l00457"></a>00457 <span class="stringliteral"> */</span>
<a name="l00458"></a>00458 <span class="stringliteral">DROP TYPE IF EXISTS MADLIB_SCHEMA.__attr_info;</span>
<a name="l00459"></a>00459 <span class="stringliteral">CREATE TYPE MADLIB_SCHEMA.__attr_info AS</span>
<a name="l00460"></a>00460 <span class="stringliteral">    (</span>
<a name="l00461"></a>00461 <span class="stringliteral">    fid     INT,</span>
<a name="l00462"></a>00462 <span class="stringliteral">    fval    FLOAT8,</span>
<a name="l00463"></a>00463 <span class="stringliteral">    is_cont  BOOLEAN</span>
<a name="l00464"></a>00464 <span class="stringliteral">    );</span>
<a name="l00465"></a>00465 <span class="stringliteral"></span>
<a name="l00466"></a>00466 <span class="stringliteral">/*</span>
<a name="l00467"></a>00467 <span class="stringliteral"> * Customized coalesce function</span>
<a name="l00468"></a>00468 <span class="stringliteral"> * Parameters:</span>
<a name="l00469"></a>00469 <span class="stringliteral"> *      lhs:    the first attribute info type</span>
<a name="l00470"></a>00470 <span class="stringliteral"> *      rhs:    the second attribute info type</span>
<a name="l00471"></a>00471 <span class="stringliteral"> */</span>
<a name="l00472"></a>00472 <span class="stringliteral">DROP FUNCTION IF EXISTS MADLIB_SCHEMA__tfc</span>
<a name="l00473"></a>00473 <span class="stringliteral">    (</span>
<a name="l00474"></a>00474 <span class="stringliteral">    lhs     MADLIB_SCHEMA.__attr_info,</span>
<a name="l00475"></a>00475 <span class="stringliteral">    rhs     MADLIB_SCHEMA.__attr_info</span>
<a name="l00476"></a>00476 <span class="stringliteral">    ) CASCADE;</span>
<a name="l00477"></a>00477 <span class="stringliteral">CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__tfc</span>
<a name="l00478"></a>00478 <span class="stringliteral">    (</span>
<a name="l00479"></a>00479 <span class="stringliteral">    lhs     MADLIB_SCHEMA.__attr_info,</span>
<a name="l00480"></a>00480 <span class="stringliteral">    rhs     MADLIB_SCHEMA.__attr_info</span>
<a name="l00481"></a>00481 <span class="stringliteral">    )  </span>
<a name="l00482"></a>00482 <span class="stringliteral">RETURNS MADLIB_SCHEMA.__attr_info AS $$</span>
<a name="l00483"></a>00483 <span class="stringliteral">DECLARE</span>
<a name="l00484"></a>00484 <span class="stringliteral">BEGIN</span>
<a name="l00485"></a>00485 <span class="stringliteral">    IF (lhs.fval IS NULL) THEN</span>
<a name="l00486"></a>00486 <span class="stringliteral">        RETURN rhs;</span>
<a name="l00487"></a>00487 <span class="stringliteral">    END IF;</span>
<a name="l00488"></a>00488 <span class="stringliteral">    </span>
<a name="l00489"></a>00489 <span class="stringliteral">    RETURN lhs;</span>
<a name="l00490"></a>00490 <span class="stringliteral">END</span>
<a name="l00491"></a>00491 <span class="stringliteral">$$ LANGUAGE PLPGSQL;</span>
<a name="l00492"></a>00492 <span class="stringliteral"></span>
<a name="l00493"></a>00493 <span class="stringliteral"></span>
<a name="l00494"></a>00494 <span class="stringliteral">/*</span>
<a name="l00495"></a>00495 <span class="stringliteral"> * generate the training instances for current leaf nodes</span>
<a name="l00496"></a>00496 <span class="stringliteral"> * Parameters:</span>
<a name="l00497"></a>00497 <span class="stringliteral"> *      cycle                   If the cycle is 1, then we will add the (), (assigned_nid), (class, assigned_nid) into the grouping sets</span>
<a name="l00498"></a>00498 <span class="stringliteral"> *      feature_stmt            The feature statement, used to construct the grouping set statement</span>
<a name="l00499"></a>00499 <span class="stringliteral"> *      bracket_stmt            The bracket statement, used to construct the grouping set statement</span>
<a name="l00500"></a>00500 <span class="stringliteral"> *      group_stmt              The group stmt statement, used to construct the grouping set statement</span>
<a name="l00501"></a>00501 <span class="stringliteral"> *      input_table_name:       The name of the original table containing all the records in training set.</span>
<a name="l00502"></a>00502 <span class="stringliteral"> *      selection_table_name:   It has two columns: id and assigned_nid. The id column is the same with that in input table.</span>
<a name="l00503"></a>00503 <span class="stringliteral"> *                              Each record will be assigned to a node.</span>
<a name="l00504"></a>00504 <span class="stringliteral"> *      verbosity               ture if print the debug info  </span>
<a name="l00505"></a>00505 <span class="stringliteral"> */</span>
<a name="l00506"></a>00506 <span class="stringliteral">DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__execute_grouping_stmt</span>
<a name="l00507"></a>00507 <span class="stringliteral">    (</span>
<a name="l00508"></a>00508 <span class="stringliteral">    cycle                INT,</span>
<a name="l00509"></a>00509 <span class="stringliteral">    feature_stmt         TEXT,</span>
<a name="l00510"></a>00510 <span class="stringliteral">    bracket_stmt         TEXT,</span>
<a name="l00511"></a>00511 <span class="stringliteral">    group_stmt           TEXT,    </span>
<a name="l00512"></a>00512 <span class="stringliteral">    input_table_name     TEXT, </span>
<a name="l00513"></a>00513 <span class="stringliteral">    selection_table_name TEXT,</span>
<a name="l00514"></a>00514 <span class="stringliteral">    group_table_name     TEXT,</span>
<a name="l00515"></a>00515 <span class="stringliteral">    verbosity            INT</span>
<a name="l00516"></a>00516 <span class="stringliteral">    ) CASCADE;</span>
<a name="l00517"></a>00517 <span class="stringliteral">CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__execute_grouping_stmt</span>
<a name="l00518"></a>00518 <span class="stringliteral">    (</span>
<a name="l00519"></a>00519 <span class="stringliteral">    cycle                INT,</span>
<a name="l00520"></a>00520 <span class="stringliteral">    feature_stmt         TEXT,</span>
<a name="l00521"></a>00521 <span class="stringliteral">    bracket_stmt         TEXT,</span>
<a name="l00522"></a>00522 <span class="stringliteral">    group_stmt           TEXT,    </span>
<a name="l00523"></a>00523 <span class="stringliteral">    input_table_name     TEXT, </span>
<a name="l00524"></a>00524 <span class="stringliteral">    selection_table_name TEXT,</span>
<a name="l00525"></a>00525 <span class="stringliteral">    group_table_name     TEXT,</span>
<a name="l00526"></a>00526 <span class="stringliteral">    verbosity            INT</span>
<a name="l00527"></a>00527 <span class="stringliteral">    )</span>
<a name="l00528"></a>00528 <span class="stringliteral">RETURNS void AS $$</span>
<a name="l00529"></a>00529 <span class="stringliteral">DECLARE</span>
<a name="l00530"></a>00530 <span class="stringliteral">    group_result_stmt   TEXT := &#39;</span><span class="stringliteral">&#39;;</span>
<a name="l00531"></a>00531 <span class="stringliteral">    curstmt             TEXT;</span>
<a name="l00532"></a>00532 <span class="stringliteral">BEGIN</span>
<a name="l00533"></a>00533 <span class="stringliteral">    -- Due to the limitation of grouping sets (currently, the number of grouping sets  </span>
<a name="l00534"></a>00534 <span class="stringliteral">    -- components can not exceed 70) we will use &#39;</span>UNION ALL<span class="stringliteral">&#39; to combine all the columns&#39;</span> 
<a name="l00535"></a>00535     -- result together. Once the limitation is removed, we should only use one 
<a name="l00536"></a>00536     -- SQL statement to <span class="keyword">get</span> the grouping sets result. 
<a name="l00537"></a>00537     IF (cycle = 1) THEN
<a name="l00538"></a>00538         SELECT MADLIB_SCHEMA.__format
<a name="l00539"></a>00539             (
<a name="l00540"></a>00540             &#39;(SELECT ((%, null%)::MADLIB_SCHEMA.__attr_info).*, class, COUNT(*), assigned_nid
<a name="l00541"></a>00541             FROM 
<a name="l00542"></a>00542                 (SELECT t1.*, assigned_nid FROM % t1 LEFT JOIN % t2 ON t1.<span class="keywordtype">id</span> = t2.<span class="keywordtype">id</span>) s
<a name="l00543"></a>00543             WHERE assigned_nid IS NOT NULL 
<a name="l00544"></a>00544             GROUP BY GROUPING SETS(assigned_nid, (class, assigned_nid),%))&#39;,
<a name="l00545"></a>00545             ARRAY[
<a name="l00546"></a>00546             feature_stmt,
<a name="l00547"></a>00547             bracket_stmt,
<a name="l00548"></a>00548             input_table_name,
<a name="l00549"></a>00549             selection_table_name,
<a name="l00550"></a>00550             group_stmt
<a name="l00551"></a>00551             ]
<a name="l00552"></a>00552         ) INTO group_result_stmt;    
<a name="l00553"></a>00553     ELSE
<a name="l00554"></a>00554         SELECT MADLIB_SCHEMA.__format
<a name="l00555"></a>00555             (
<a name="l00556"></a>00556             &#39;(SELECT ((%, null%)::MADLIB_SCHEMA.__attr_info).*, class, COUNT(*), assigned_nid
<a name="l00557"></a>00557             FROM 
<a name="l00558"></a>00558                 (SELECT t1.*, assigned_nid FROM % t1, % t2 WHERE t1.<span class="keywordtype">id</span> = t2.<span class="keywordtype">id</span>) s
<a name="l00559"></a>00559             WHERE assigned_nid IS NOT NULL 
<a name="l00560"></a>00560             GROUP BY GROUPING SETS(%))&#39;,
<a name="l00561"></a>00561             ARRAY[
<a name="l00562"></a>00562             feature_stmt,
<a name="l00563"></a>00563             bracket_stmt,
<a name="l00564"></a>00564             input_table_name,
<a name="l00565"></a>00565             selection_table_name,
<a name="l00566"></a>00566             group_stmt
<a name="l00567"></a>00567             ]
<a name="l00568"></a>00568         ) INTO group_result_stmt;    
<a name="l00569"></a>00569     END IF;        
<a name="l00570"></a>00570     
<a name="l00571"></a>00571     IF(verbosity &gt; 0) THEN
<a name="l00572"></a>00572         RAISE INFO &#39;group stmt:%&#39;, group_result_stmt;
<a name="l00573"></a>00573     END IF;
<a name="l00574"></a>00574         
<a name="l00575"></a>00575     SELECT MADLIB_SCHEMA.__format
<a name="l00576"></a>00576         (
<a name="l00577"></a>00577             &#39;INSERT INTO % %&#39;,
<a name="l00578"></a>00578             ARRAY[
<a name="l00579"></a>00579             group_table_name,
<a name="l00580"></a>00580             group_result_stmt
<a name="l00581"></a>00581             ]
<a name="l00582"></a>00582         ) INTO curstmt;
<a name="l00583"></a>00583     
<a name="l00584"></a>00584     IF(verbosity &gt; 0) THEN
<a name="l00585"></a>00585         RAISE INFO &#39;Inser into auxiliary table stmt: %&#39;, curstmt;
<a name="l00586"></a>00586     END IF;
<a name="l00587"></a>00587             
<a name="l00588"></a>00588     EXECUTE curstmt;
<a name="l00589"></a>00589         
<a name="l00590"></a>00590 END
<a name="l00591"></a>00591 $$ LANGUAGE PLPGSQL;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 <span class="comment">/*</span>
<a name="l00594"></a>00594 <span class="comment"> * generate the training instances for current leaf nodes by grouping sets for greenplumn</span>
<a name="l00595"></a>00595 <span class="comment"> * Parameters:</span>
<a name="l00596"></a>00596 <span class="comment"> *      instance_table_name:    The output table name, which contains all the training set for current leaf nodes.</span>
<a name="l00597"></a>00597 <span class="comment"> *      class_table_name:       Name of class table</span>
<a name="l00598"></a>00598 <span class="comment"> *      group_table_name        The name of table containing grouping data info</span>
<a name="l00599"></a>00599 <span class="comment"> *      verbosity               ture if print the debug info  </span>
<a name="l00600"></a>00600 <span class="comment"> */</span>
<a name="l00601"></a>00601 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_training_instance
<a name="l00602"></a>00602     (
<a name="l00603"></a>00603     instance_table_name   TEXT,
<a name="l00604"></a>00604     class_table_name      TEXT,
<a name="l00605"></a>00605     group_table_name      TEXT,
<a name="l00606"></a>00606     verbosity             INT
<a name="l00607"></a>00607     );
<a name="l00608"></a>00608 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_training_instance
<a name="l00609"></a>00609     (
<a name="l00610"></a>00610     instance_table_name   TEXT,
<a name="l00611"></a>00611     class_table_name      TEXT,
<a name="l00612"></a>00612     group_table_name      TEXT,
<a name="l00613"></a>00613     verbosity             INT
<a name="l00614"></a>00614     )
<a name="l00615"></a>00615 RETURNS <span class="keywordtype">void</span> AS $$
<a name="l00616"></a>00616 DECLARE
<a name="l00617"></a>00617     curstmt             TEXT := &#39;&#39;;
<a name="l00618"></a>00618     window_func_stmt    TEXT := &#39;&#39;;
<a name="l00619"></a>00619 BEGIN
<a name="l00620"></a>00620 m4_changequote(`&gt;&gt;&gt;&#39;, `&lt;&lt;&lt;&#39;)
<a name="l00621"></a>00621 m4_ifdef(&gt;&gt;&gt;__POSTGRESQL_PRE_9_0__&lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l00622"></a>00622     -- old db <a class="code" href="utilities_8sql__in.html#a9ce7ffa76acc8a0638e9bc48be99f36a" title="Return MADlib build information.">version</a> does not support starting from 1 following/curr row.
<a name="l00623"></a>00623     window_func_stmt = 
<a name="l00624"></a>00624             &#39;CASE WHEN (is_cont) THEN 
<a name="l00625"></a>00625                     sum(count) OVER 
<a name="l00626"></a>00626                         (
<a name="l00627"></a>00627                         PARTITION BY assigned_nid,class,fid ORDER BY fval 
<a name="l00628"></a>00628                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
<a name="l00629"></a>00629                         ) 
<a name="l00630"></a>00630                     ELSE 
<a name="l00631"></a>00631                         count 
<a name="l00632"></a>00632                     END AS le, 
<a name="l00633"></a>00633             CASE WHEN (is_cont) THEN
<a name="l00634"></a>00634             -- Any operation with NULL returns NULL.
<a name="l00635"></a>00635             -- We need convert NULL to 0 before minus operation.
<a name="l00636"></a>00636                     coalesce(
<a name="l00637"></a>00637                       sum(count) OVER
<a name="l00638"></a>00638                         ( 
<a name="l00639"></a>00639                         PARTITION BY assigned_nid,class,fid ORDER BY fval 
<a name="l00640"></a>00640                         ROWS BETWEEN UNBOUNDED PRECEDING AND  UNBOUNDED FOLLOWING),
<a name="l00641"></a>00641                       0)
<a name="l00642"></a>00642                     -
<a name="l00643"></a>00643                     coalesce(
<a name="l00644"></a>00644                       sum(count) OVER 
<a name="l00645"></a>00645                         (
<a name="l00646"></a>00646                         PARTITION BY assigned_nid,class,fid ORDER BY fval 
<a name="l00647"></a>00647                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
<a name="l00648"></a>00648                         ),
<a name="l00649"></a>00649                       0)
<a name="l00650"></a>00650                     ELSE 
<a name="l00651"></a>00651                         NULL 
<a name="l00652"></a>00652                     END AS gt,&#39;;
<a name="l00653"></a>00653 &lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l00654"></a>00654     window_func_stmt = 
<a name="l00655"></a>00655             &#39;CASE WHEN (is_cont) THEN 
<a name="l00656"></a>00656                     sum(count) OVER 
<a name="l00657"></a>00657                         (
<a name="l00658"></a>00658                         PARTITION BY assigned_nid,class,fid ORDER BY fval 
<a name="l00659"></a>00659                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
<a name="l00660"></a>00660                         ) 
<a name="l00661"></a>00661                     ELSE 
<a name="l00662"></a>00662                         count 
<a name="l00663"></a>00663                     END AS le, 
<a name="l00664"></a>00664             CASE WHEN (is_cont) THEN 
<a name="l00665"></a>00665                     sum(count) OVER
<a name="l00666"></a>00666                         ( 
<a name="l00667"></a>00667                         PARTITION BY assigned_nid,class,fid ORDER BY fval 
<a name="l00668"></a>00668                         ROWS BETWEEN 1 FOLLOWING AND  UNBOUNDED FOLLOWING) 
<a name="l00669"></a>00669                     ELSE 
<a name="l00670"></a>00670                         NULL 
<a name="l00671"></a>00671                     END AS gt,&#39;;
<a name="l00672"></a>00672 &lt;&lt;&lt;)
<a name="l00673"></a>00673 m4_changequote(&gt;&gt;&gt;`&lt;&lt;&lt;, &gt;&gt;&gt;&#39;&lt;&lt;&lt;)
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     SELECT MADLIB_SCHEMA.__format
<a name="l00676"></a>00676         (
<a name="l00677"></a>00677             &#39;INSERT INTO %(fid, fval, class, is_cont, split_value, le, gt, assigned_nid)  
<a name="l00678"></a>00678             SELECT fid, fval, class, is_cont,
<a name="l00679"></a>00679                 CASE WHEN (is_cont) THEN 
<a name="l00680"></a>00680                         fval::float8 
<a name="l00681"></a>00681                     ELSE 
<a name="l00682"></a>00682                         NULL 
<a name="l00683"></a>00683                     END AS split_value, 
<a name="l00684"></a>00684                 %
<a name="l00685"></a>00685                 assigned_nid
<a name="l00686"></a>00686             FROM (
<a name="l00687"></a>00687                 SELECT DISTINCT n1.fid, n1.fval, n1.is_cont, n1.class, n2.count, n1.assigned_nid 
<a name="l00688"></a>00688                 FROM 
<a name="l00689"></a>00689                     (
<a name="l00690"></a>00690                     SELECT fid, fval, is_cont, key as class, count, assigned_nid 
<a name="l00691"></a>00691                     FROM 
<a name="l00692"></a>00692                         (
<a name="l00693"></a>00693                         SELECT DISTINCT fval, count, fid, is_cont, assigned_nid 
<a name="l00694"></a>00694                         FROM %
<a name="l00695"></a>00695                         ) AS t1
<a name="l00696"></a>00696                     CROSS JOIN
<a name="l00697"></a>00697                     (
<a name="l00698"></a>00698                         SELECT key FROM MADLIB_SCHEMA.%
<a name="l00699"></a>00699                     ) as t2
<a name="l00700"></a>00700                 ) AS n1 
<a name="l00701"></a>00701                 LEFT JOIN % n2   
<a name="l00702"></a>00702                 ON coalesce(n2.class,0) = coalesce(n1.class,0) AND
<a name="l00703"></a>00703                     coalesce(n2.assigned_nid,0) = coalesce(n1.assigned_nid,0) AND
<a name="l00704"></a>00704                     coalesce(n2.fid,0)= coalesce (n1.fid,0) AND
<a name="l00705"></a>00705                     coalesce(n2.fval,0) = coalesce(n1.fval,0)  
<a name="l00706"></a>00706             ) t;&#39;,
<a name="l00707"></a>00707             ARRAY[
<a name="l00708"></a>00708                 instance_table_name,
<a name="l00709"></a>00709                 window_func_stmt,
<a name="l00710"></a>00710                 group_table_name,
<a name="l00711"></a>00711                 class_table_name,
<a name="l00712"></a>00712                 group_table_name
<a name="l00713"></a>00713             ]
<a name="l00714"></a>00714         ) INTO curstmt;
<a name="l00715"></a>00715 
<a name="l00716"></a>00716     IF(verbosity &gt; 0) THEN
<a name="l00717"></a>00717         RAISE INFO &#39;window function stmt: %&#39;, curstmt;
<a name="l00718"></a>00718     END IF;
<a name="l00719"></a>00719             
<a name="l00720"></a>00720     EXECUTE curstmt;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     SELECT MADLIB_SCHEMA.__format
<a name="l00723"></a>00723         (
<a name="l00724"></a>00724             &#39;INSERT INTO %(fid, fval, class, le, gt, assigned_nid)  
<a name="l00725"></a>00725              SELECT fid, null, class, sum(le), null, assigned_nid from
<a name="l00726"></a>00726              % where not is_cont group by fid,class,assigned_nid;&#39;,
<a name="l00727"></a>00727             instance_table_name,
<a name="l00728"></a>00728             instance_table_name
<a name="l00729"></a>00729         ) INTO curstmt;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     EXECUTE curstmt;                    
<a name="l00732"></a>00732 END
<a name="l00733"></a>00733 $$ LANGUAGE PLPGSQL;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="comment">/*</span>
<a name="l00737"></a>00737 <span class="comment"> * generate the training instances for current leaf nodes by grouping sets for greenplumn</span>
<a name="l00738"></a>00738 <span class="comment"> * Parameters:</span>
<a name="l00739"></a>00739 <span class="comment"> *      input_table_name:       The name of the original table containing all the records in training set.</span>
<a name="l00740"></a>00740 <span class="comment"> *      metatable_name:         Contains the relevant information of the input table</span>
<a name="l00741"></a>00741 <span class="comment"> *      instance_table_name:    The output table name, which contains all the training set for current leaf nodes.</span>
<a name="l00742"></a>00742 <span class="comment"> *      selection_table_name:   It has two columns: id and assigned_nid. The id column is the same with that in input table.</span>
<a name="l00743"></a>00743 <span class="comment"> *                              Each record will be assigned to a node.</span>
<a name="l00744"></a>00744 <span class="comment"> *      verbosity               ture if print the debug info </span>
<a name="l00745"></a>00745 <span class="comment"> */</span>
<a name="l00746"></a>00746 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__generate_training_instance_greenplum
<a name="l00747"></a>00747     (
<a name="l00748"></a>00748     input_table_name     TEXT, 
<a name="l00749"></a>00749     metatable_name       TEXT,
<a name="l00750"></a>00750     instance_table_name  TEXT,
<a name="l00751"></a>00751     selection_table_name TEXT,
<a name="l00752"></a>00752     verbosity            INT
<a name="l00753"></a>00753     );
<a name="l00754"></a>00754 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__generate_training_instance_greenplum
<a name="l00755"></a>00755     (
<a name="l00756"></a>00756     input_table_name      TEXT, 
<a name="l00757"></a>00757     metatable_name        TEXT,
<a name="l00758"></a>00758     instance_table_name   TEXT,
<a name="l00759"></a>00759     selection_table_name  TEXT,
<a name="l00760"></a>00760     verbosity             INT
<a name="l00761"></a>00761     )
<a name="l00762"></a>00762 RETURNS <span class="keywordtype">void</span> AS $$
<a name="l00763"></a>00763 DECLARE
<a name="l00764"></a>00764     curstmt             TEXT := &#39;&#39;;
<a name="l00765"></a>00765     result_rec          RECORD;
<a name="l00766"></a>00766     feature_stmt        TEXT := &#39;&#39;;
<a name="l00767"></a>00767     bracket_stmt        TEXT := &#39;&#39;;
<a name="l00768"></a>00768     group_stmt          TEXT := &#39;&#39;;
<a name="l00769"></a>00769     group_result_stmt   TEXT := &#39;&#39;;
<a name="l00770"></a>00770     class_table_name    TEXT := &#39;&#39;;
<a name="l00771"></a>00771     group_table_name    TEXT := &#39;training_instance_aux&#39;;
<a name="l00772"></a>00772     max_num_col_group   INT  := 30;
<a name="l00773"></a>00773     index               INT  := 1;
<a name="l00774"></a>00774     
<a name="l00775"></a>00775 BEGIN
<a name="l00776"></a>00776     EXECUTE &#39;TRUNCATE &#39; || instance_table_name;
<a name="l00777"></a>00777     EXECUTE &#39;TRUNCATE &#39; || group_table_name;
<a name="l00778"></a>00778    
<a name="l00779"></a>00779     SELECT MADLIB_SCHEMA.__format
<a name="l00780"></a>00780         (
<a name="l00781"></a>00781         &#39;SELECT table_name 
<a name="l00782"></a>00782         FROM MADLIB_SCHEMA.% 
<a name="l00783"></a>00783         WHERE column_type = &#39;&#39;c&#39;&#39;&#39;,
<a name="l00784"></a>00784         metatable_name
<a name="l00785"></a>00785         )
<a name="l00786"></a>00786     INTO curstmt;
<a name="l00787"></a>00787     
<a name="l00788"></a>00788     EXECUTE curstmt INTO class_table_name;
<a name="l00789"></a>00789               
<a name="l00790"></a>00790     SELECT MADLIB_SCHEMA.__format
<a name="l00791"></a>00791         (
<a name="l00792"></a>00792             &#39;SELECT <span class="keywordtype">id</span>, column_name, is_cont 
<a name="l00793"></a>00793             FROM MADLIB_SCHEMA.% 
<a name="l00794"></a>00794             WHERE column_type = &#39;&#39;f&#39;&#39; ORDER BY <span class="keywordtype">id</span>&#39;,
<a name="l00795"></a>00795             metatable_name
<a name="l00796"></a>00796         )
<a name="l00797"></a>00797         INTO curstmt;
<a name="l00798"></a>00798     
<a name="l00799"></a>00799     FOR result_rec IN EXECUTE (curstmt) LOOP
<a name="l00800"></a>00800         
<a name="l00801"></a>00801         feature_stmt = feature_stmt || 
<a name="l00802"></a>00802                         &#39;MADLIB_SCHEMA.__tfc((&#39; || 
<a name="l00803"></a>00803                         result_rec.<span class="keywordtype">id</span> || 
<a name="l00804"></a>00804                         &#39;,&#39; ||
<a name="l00805"></a>00805                         result_rec.column_name || 
<a name="l00806"></a>00806                         &#39;::FLOAT8,&#39;&#39;&#39; || 
<a name="l00807"></a>00807                         MADLIB_SCHEMA.__to_char(result_rec.is_cont) ||
<a name="l00808"></a>00808                         &#39;&#39;&#39;)::MADLIB_SCHEMA.__attr_info,&#39;;
<a name="l00809"></a>00809         
<a name="l00810"></a>00810         group_stmt = group_stmt || 
<a name="l00811"></a>00811                     &#39;(&#39; ||
<a name="l00812"></a>00812                     result_rec.column_name || 
<a name="l00813"></a>00813                     &#39;, assigned_nid)&#39; || 
<a name="l00814"></a>00814                     &#39;,(&#39; || 
<a name="l00815"></a>00815                     result_rec.column_name || 
<a name="l00816"></a>00816                     &#39;,class, assigned_nid),&#39;;
<a name="l00817"></a>00817                     
<a name="l00818"></a>00818         bracket_stmt = bracket_stmt || &#39;)&#39;;
<a name="l00819"></a>00819         
<a name="l00820"></a>00820         IF ((index % max_num_col_group) = 0) THEN
<a name="l00821"></a>00821                 PERFORM MADLIB_SCHEMA.__execute_grouping_stmt
<a name="l00822"></a>00822                     (
<a name="l00823"></a>00823                     (index / max_num_col_group)::INT4,
<a name="l00824"></a>00824                     rtrim(feature_stmt, &#39;,&#39;),
<a name="l00825"></a>00825                     bracket_stmt,
<a name="l00826"></a>00826                     rtrim(group_stmt, &#39;,&#39;),                 
<a name="l00827"></a>00827                     input_table_name,
<a name="l00828"></a>00828                     selection_table_name,
<a name="l00829"></a>00829                     group_table_name,
<a name="l00830"></a>00830                     verbosity
<a name="l00831"></a>00831                     );
<a name="l00832"></a>00832                     
<a name="l00833"></a>00833             feature_stmt = &#39;&#39;;
<a name="l00834"></a>00834             bracket_stmt = &#39;&#39;;
<a name="l00835"></a>00835             group_stmt   = &#39;&#39;;
<a name="l00836"></a>00836             
<a name="l00837"></a>00837         END IF;
<a name="l00838"></a>00838         
<a name="l00839"></a>00839         index = index + 1;
<a name="l00840"></a>00840     END LOOP;
<a name="l00841"></a>00841     
<a name="l00842"></a>00842     index = index - 1;
<a name="l00843"></a>00843     
<a name="l00844"></a>00844     IF ((index % max_num_col_group) != 0) THEN
<a name="l00845"></a>00845         PERFORM MADLIB_SCHEMA.__execute_grouping_stmt
<a name="l00846"></a>00846                 (
<a name="l00847"></a>00847                 (index / max_num_col_group)::INT4 + 1,
<a name="l00848"></a>00848                 rtrim(feature_stmt, &#39;,&#39;),
<a name="l00849"></a>00849                 bracket_stmt,
<a name="l00850"></a>00850                 rtrim(group_stmt, &#39;,&#39;),                 
<a name="l00851"></a>00851                 input_table_name,
<a name="l00852"></a>00852                 selection_table_name,
<a name="l00853"></a>00853                 group_table_name,
<a name="l00854"></a>00854                 verbosity
<a name="l00855"></a>00855                 );  
<a name="l00856"></a>00856     END IF;    
<a name="l00857"></a>00857     
<a name="l00858"></a>00858     PERFORM MADLIB_SCHEMA.__create_training_instance
<a name="l00859"></a>00859         (
<a name="l00860"></a>00860         instance_table_name,
<a name="l00861"></a>00861         class_table_name,
<a name="l00862"></a>00862         group_table_name,
<a name="l00863"></a>00863         verbosity
<a name="l00864"></a>00864         );
<a name="l00865"></a>00865 END
<a name="l00866"></a>00866 $$ LANGUAGE PLPGSQL;
<a name="l00867"></a>00867     
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="comment">/*</span>
<a name="l00870"></a>00870 <span class="comment"> * generate the training instances for current leaf nodes by union all statement for postgres</span>
<a name="l00871"></a>00871 <span class="comment"> * Parameters:</span>
<a name="l00872"></a>00872 <span class="comment"> *      input_table_name:       The name of the original table containing all the records in training set.</span>
<a name="l00873"></a>00873 <span class="comment"> *      metatable_name:         Contains the relevant information of the input table</span>
<a name="l00874"></a>00874 <span class="comment"> *      instance_table_name:    The output table name, which contains all the training set for current leaf nodes.</span>
<a name="l00875"></a>00875 <span class="comment"> *      selection_table_name:   It has two columns: id and assigned_nid. The id column is the same with that in input table.</span>
<a name="l00876"></a>00876 <span class="comment"> *                              Each record will be assigned to a node.</span>
<a name="l00877"></a>00877 <span class="comment"> *      verbosity               ture if print the debug info </span>
<a name="l00878"></a>00878 <span class="comment"> */</span>
<a name="l00879"></a>00879 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__generate_training_instance_postgres
<a name="l00880"></a>00880     (
<a name="l00881"></a>00881     input_table_name     TEXT, 
<a name="l00882"></a>00882     metatable_name       TEXT,
<a name="l00883"></a>00883     instance_table_name  TEXT,
<a name="l00884"></a>00884     selection_table_name TEXT,
<a name="l00885"></a>00885     verbosity            INT
<a name="l00886"></a>00886     );
<a name="l00887"></a>00887 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__generate_training_instance_postgres
<a name="l00888"></a>00888     (
<a name="l00889"></a>00889     input_table_name      TEXT, 
<a name="l00890"></a>00890     metatable_name        TEXT,
<a name="l00891"></a>00891     instance_table_name   TEXT,
<a name="l00892"></a>00892     selection_table_name  TEXT,
<a name="l00893"></a>00893     verbosity             INT
<a name="l00894"></a>00894     )
<a name="l00895"></a>00895 RETURNS <span class="keywordtype">void</span> AS $$
<a name="l00896"></a>00896 DECLARE
<a name="l00897"></a>00897     curstmt             TEXT := &#39;&#39;;
<a name="l00898"></a>00898     result_rec          RECORD;
<a name="l00899"></a>00899     feature_stmt        TEXT := &#39;&#39;;
<a name="l00900"></a>00900     bracket_stmt        TEXT := &#39;&#39;;
<a name="l00901"></a>00901     group_stmt          TEXT := &#39;&#39;;
<a name="l00902"></a>00902     group_result_stmt   TEXT := &#39;&#39;;
<a name="l00903"></a>00903     class_table_name    TEXT := &#39;&#39;;
<a name="l00904"></a>00904     name                TEXT;
<a name="l00905"></a>00905     null_stmt           TEXT := &#39;&#39;;    
<a name="l00906"></a>00906     group_table_name    TEXT := &#39;training_instance_aux&#39;;
<a name="l00907"></a>00907     max_num_col_group   INT  := 30;
<a name="l00908"></a>00908     index               INT  := 1;
<a name="l00909"></a>00909 BEGIN
<a name="l00910"></a>00910     EXECUTE &#39;TRUNCATE &#39; || instance_table_name;
<a name="l00911"></a>00911     EXECUTE &#39;TRUNCATE &#39; || group_table_name;
<a name="l00912"></a>00912     
<a name="l00913"></a>00913     SELECT MADLIB_SCHEMA.__format
<a name="l00914"></a>00914         (
<a name="l00915"></a>00915         &#39;SELECT table_name 
<a name="l00916"></a>00916         FROM MADLIB_SCHEMA.% 
<a name="l00917"></a>00917         WHERE column_type = &#39;&#39;c&#39;&#39;&#39;,
<a name="l00918"></a>00918         metatable_name
<a name="l00919"></a>00919         )
<a name="l00920"></a>00920     INTO curstmt;
<a name="l00921"></a>00921     
<a name="l00922"></a>00922     EXECUTE curstmt INTO class_table_name;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924     EXECUTE &#39;DROP TABLE IF EXISTS training_instace_with_nid&#39;;
<a name="l00925"></a>00925     SELECT MADLIB_SCHEMA.__format
<a name="l00926"></a>00926         (
<a name="l00927"></a>00927         &#39;CREATE TEMP TABLE training_instace_with_nid 
<a name="l00928"></a>00928          AS SELECT %, class, assigned_nid 
<a name="l00929"></a>00929          FROM % t1 
<a name="l00930"></a>00930          LEFT JOIN % t2 
<a name="l00931"></a>00931          ON t1.<span class="keywordtype">id</span> = t2.<span class="keywordtype">id</span>
<a name="l00932"></a>00932          m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY(assigned_nid)&#39;)&#39;,
<a name="l00933"></a>00933         ARRAY[
<a name="l00934"></a>00934             MADLIB_SCHEMA.__get_feature_name_in_selectstmt(metatable_name),
<a name="l00935"></a>00935             input_table_name,
<a name="l00936"></a>00936             selection_table_name
<a name="l00937"></a>00937             ]
<a name="l00938"></a>00938         )
<a name="l00939"></a>00939     INTO curstmt;
<a name="l00940"></a>00940     
<a name="l00941"></a>00941     IF(verbosity &gt; 0) THEN
<a name="l00942"></a>00942         RAISE INFO &#39;training_instace_with_nid creation stmt: %&#39;, curstmt;
<a name="l00943"></a>00943     END IF;
<a name="l00944"></a>00944             
<a name="l00945"></a>00945     EXECUTE curStmt;
<a name="l00946"></a>00946 
<a name="l00947"></a>00947     -- get all the feature names, and default value is null
<a name="l00948"></a>00948     FOR name IN EXECUTE 
<a name="l00949"></a>00949         (&#39;SELECT column_name 
<a name="l00950"></a>00950           FROM   MADLIB_SCHEMA.&#39; || metatable_name || &#39; &#39; ||
<a name="l00951"></a>00951          &#39;WHERE  column_type = &#39;&#39;f&#39;&#39; ORDER BY <span class="keywordtype">id</span>;&#39;
<a name="l00952"></a>00952         )
<a name="l00953"></a>00953         LOOP
<a name="l00954"></a>00954         null_stmt = null_stmt || &#39;null as &#39; || name || &#39;, &#39;;
<a name="l00955"></a>00955     END LOOP;
<a name="l00956"></a>00956     
<a name="l00957"></a>00957     
<a name="l00958"></a>00958     EXECUTE &#39;DROP TABLE IF EXISTS training_instace_count&#39;;
<a name="l00959"></a>00959     
<a name="l00960"></a>00960     SELECT MADLIB_SCHEMA.__format
<a name="l00961"></a>00961         (
<a name="l00962"></a>00962         &#39;CREATE TEMP TABLE training_instace_count 
<a name="l00963"></a>00963          AS 
<a name="l00964"></a>00964          (
<a name="l00965"></a>00965          SELECT % null as class, COUNT(*) as count, assigned_nid
<a name="l00966"></a>00966          FROM training_instace_with_nid
<a name="l00967"></a>00967          GROUP BY assigned_nid
<a name="l00968"></a>00968          UNION ALL
<a name="l00969"></a>00969          SELECT % class, COUNT(*), assigned_nid
<a name="l00970"></a>00970          FROM training_instace_with_nid
<a name="l00971"></a>00971          GROUP BY assigned_nid, class
<a name="l00972"></a>00972          )
<a name="l00973"></a>00973          m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY(assigned_nid)&#39;)&#39;,
<a name="l00974"></a>00974         ARRAY[
<a name="l00975"></a>00975             null_stmt,
<a name="l00976"></a>00976             null_stmt
<a name="l00977"></a>00977             ]
<a name="l00978"></a>00978         )
<a name="l00979"></a>00979     INTO curstmt;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981     IF(verbosity &gt; 0) THEN
<a name="l00982"></a>00982         RAISE INFO &#39;training_instace_count creation stmt: %&#39;, curstmt;
<a name="l00983"></a>00983     END IF;
<a name="l00984"></a>00984         
<a name="l00985"></a>00985     EXECUTE curStmt;
<a name="l00986"></a>00986     
<a name="l00987"></a>00987     SELECT MADLIB_SCHEMA.__format
<a name="l00988"></a>00988         (
<a name="l00989"></a>00989             &#39;SELECT <span class="keywordtype">id</span>, column_name, is_cont 
<a name="l00990"></a>00990             FROM MADLIB_SCHEMA.% 
<a name="l00991"></a>00991             WHERE column_type = &#39;&#39;f&#39;&#39; ORDER BY <span class="keywordtype">id</span>&#39;,
<a name="l00992"></a>00992             metatable_name
<a name="l00993"></a>00993         )
<a name="l00994"></a>00994     INTO curstmt;
<a name="l00995"></a>00995     
<a name="l00996"></a>00996     FOR result_rec IN EXECUTE (curstmt) LOOP
<a name="l00997"></a>00997         
<a name="l00998"></a>00998         feature_stmt = feature_stmt || 
<a name="l00999"></a>00999                         &#39;MADLIB_SCHEMA.__tfc((&#39; || 
<a name="l01000"></a>01000                         result_rec.<span class="keywordtype">id</span> || 
<a name="l01001"></a>01001                         &#39;,&#39; ||
<a name="l01002"></a>01002                         result_rec.column_name || 
<a name="l01003"></a>01003                         &#39;::FLOAT8,&#39;&#39;&#39; || 
<a name="l01004"></a>01004                         MADLIB_SCHEMA.__to_char(result_rec.is_cont) ||
<a name="l01005"></a>01005                         &#39;&#39;&#39;)::MADLIB_SCHEMA.__attr_info,&#39;;
<a name="l01006"></a>01006         
<a name="l01007"></a>01007         bracket_stmt = bracket_stmt || &#39;)&#39;;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009        SELECT MADLIB_SCHEMA.__format
<a name="l01010"></a>01010             (
<a name="l01011"></a>01011             &#39;INSERT INTO training_instace_count(%, class, count, assigned_nid) 
<a name="l01012"></a>01012              (
<a name="l01013"></a>01013              SELECT %, null, COUNT(*), assigned_nid
<a name="l01014"></a>01014              FROM training_instace_with_nid
<a name="l01015"></a>01015              GROUP BY assigned_nid, %
<a name="l01016"></a>01016              UNION ALL
<a name="l01017"></a>01017              SELECT %, class, COUNT(*), assigned_nid
<a name="l01018"></a>01018              FROM training_instace_with_nid
<a name="l01019"></a>01019              GROUP BY assigned_nid, %, class
<a name="l01020"></a>01020              )&#39;,
<a name="l01021"></a>01021             ARRAY[
<a name="l01022"></a>01022                 result_rec.column_name,
<a name="l01023"></a>01023                 result_rec.column_name,
<a name="l01024"></a>01024                 result_rec.column_name,
<a name="l01025"></a>01025                 result_rec.column_name,
<a name="l01026"></a>01026                 result_rec.column_name
<a name="l01027"></a>01027                 ]
<a name="l01028"></a>01028             )
<a name="l01029"></a>01029         INTO curstmt;
<a name="l01030"></a>01030         
<a name="l01031"></a>01031         IF(verbosity &gt; 0) THEN
<a name="l01032"></a>01032             RAISE INFO &#39;training_instace_count insertion for each feature stmt: %&#39;, curstmt;
<a name="l01033"></a>01033         END IF;
<a name="l01034"></a>01034     
<a name="l01035"></a>01035         EXECUTE curStmt;
<a name="l01036"></a>01036     END LOOP;
<a name="l01037"></a>01037     
<a name="l01038"></a>01038     SELECT MADLIB_SCHEMA.__format
<a name="l01039"></a>01039         (
<a name="l01040"></a>01040         &#39;INSERT INTO %
<a name="l01041"></a>01041         SELECT ((% null%)::MADLIB_SCHEMA.__attr_info).*, class, count, assigned_nid
<a name="l01042"></a>01042         FROM training_instace_count
<a name="l01043"></a>01043         WHERE assigned_nid IS NOT NULL&#39;,
<a name="l01044"></a>01044         ARRAY[
<a name="l01045"></a>01045         group_table_name,
<a name="l01046"></a>01046         feature_stmt,
<a name="l01047"></a>01047         bracket_stmt
<a name="l01048"></a>01048         ]
<a name="l01049"></a>01049     ) INTO curstmt;    
<a name="l01050"></a>01050     
<a name="l01051"></a>01051     IF(verbosity &gt; 0) THEN
<a name="l01052"></a>01052         RAISE INFO &#39;Inser into auxiliary table stmt: %&#39;, curstmt;
<a name="l01053"></a>01053     END IF;
<a name="l01054"></a>01054             
<a name="l01055"></a>01055     EXECUTE curstmt;
<a name="l01056"></a>01056       
<a name="l01057"></a>01057     PERFORM MADLIB_SCHEMA.__create_training_instance
<a name="l01058"></a>01058         (
<a name="l01059"></a>01059         instance_table_name,
<a name="l01060"></a>01060         class_table_name,
<a name="l01061"></a>01061         group_table_name,
<a name="l01062"></a>01062         verbosity
<a name="l01063"></a>01063         );
<a name="l01064"></a>01064                          
<a name="l01065"></a>01065 END
<a name="l01066"></a>01066 $$ LANGUAGE PLPGSQL;
<a name="l01067"></a>01067 
<a name="l01068"></a>01068 DROP TYPE IF EXISTS MADLIB_SCHEMA.__rep_type CASCADE;
<a name="l01069"></a>01069 CREATE TYPE MADLIB_SCHEMA.__rep_type AS
<a name="l01070"></a>01070     (
<a name="l01071"></a>01071     numOfOrgClasses BIGINT[]
<a name="l01072"></a>01072     );
<a name="l01073"></a>01073 
<a name="l01074"></a>01074 DROP TYPE IF EXISTS MADLIB_SCHEMA.__rep_result CASCADE;
<a name="l01075"></a>01075 CREATE TYPE MADLIB_SCHEMA.__rep_result AS
<a name="l01076"></a>01076     (
<a name="l01077"></a>01077     maxclass  BIGINT,
<a name="l01078"></a>01078     isreplace BIGINT
<a name="l01079"></a>01079     );
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__rep_aggr_class_count_sfunc
<a name="l01082"></a>01082     (
<a name="l01083"></a>01083     BIGINT[],
<a name="l01084"></a>01084     INT, 
<a name="l01085"></a>01085     INT, 
<a name="l01086"></a>01086     INT
<a name="l01087"></a>01087     ) CASCADE;
<a name="l01088"></a>01088 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__rep_aggr_class_count_sfunc
<a name="l01089"></a>01089     (
<a name="l01090"></a>01090     class_count_array       BIGINT[],        
<a name="l01091"></a>01091     classified_class        INT,
<a name="l01092"></a>01092     original_class          INT,
<a name="l01093"></a>01093     max_num_of_classes      INT
<a name="l01094"></a>01094     ) 
<a name="l01095"></a>01095 RETURNS BIGINT[]
<a name="l01096"></a>01096 AS &#39;MODULE_PATHNAME&#39;, &#39;rep_aggr_class_count_sfunc&#39;
<a name="l01097"></a>01097 LANGUAGE C IMMUTABLE;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__rep_aggr_class_count_prefunc
<a name="l01100"></a>01100     (
<a name="l01101"></a>01101     BIGINT[],
<a name="l01102"></a>01102     BIGINT[]
<a name="l01103"></a>01103     ) CASCADE;
<a name="l01104"></a>01104 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__rep_aggr_class_count_prefunc
<a name="l01105"></a>01105     (
<a name="l01106"></a>01106     BIGINT[],
<a name="l01107"></a>01107     BIGINT[]
<a name="l01108"></a>01108     ) 
<a name="l01109"></a>01109 RETURNS BIGINT[]
<a name="l01110"></a>01110 AS &#39;MODULE_PATHNAME&#39;, &#39;rep_aggr_class_count_prefunc&#39;
<a name="l01111"></a>01111 LANGUAGE C IMMUTABLE;
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__rep_aggr_class_count_ffunc
<a name="l01114"></a>01114     (
<a name="l01115"></a>01115     BIGINT[]
<a name="l01116"></a>01116     ) CASCADE;
<a name="l01117"></a>01117 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__rep_aggr_class_count_ffunc
<a name="l01118"></a>01118     (
<a name="l01119"></a>01119     class_count_array       BIGINT[]        
<a name="l01120"></a>01120     ) 
<a name="l01121"></a>01121 RETURNS BIGINT[]
<a name="l01122"></a>01122 AS &#39;MODULE_PATHNAME&#39;, &#39;rep_aggr_class_count_ffunc&#39;
<a name="l01123"></a>01123 LANGUAGE C STRICT IMMUTABLE;
<a name="l01124"></a>01124 
<a name="l01125"></a>01125 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__rep_aggr_class_count_wrapper
<a name="l01126"></a>01126     (
<a name="l01127"></a>01127     BIGINT[]
<a name="l01128"></a>01128     ) CASCADE;
<a name="l01129"></a>01129 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__rep_aggr_class_count_wrapper
<a name="l01130"></a>01130     (
<a name="l01131"></a>01131     internal_result BIGINT[]
<a name="l01132"></a>01132     ) 
<a name="l01133"></a>01133 RETURNS MADLIB_SCHEMA.__rep_result AS $$
<a name="l01134"></a>01134 DECLARE
<a name="l01135"></a>01135     result MADLIB_SCHEMA.__rep_result;
<a name="l01136"></a>01136 BEGIN
<a name="l01137"></a>01137     IF(internal_result IS NOT NULL) THEN
<a name="l01138"></a>01138        result.maxclass = internal_result[1];
<a name="l01139"></a>01139        result.isreplace = internal_result[2];        
<a name="l01140"></a>01140     ELSE
<a name="l01141"></a>01141        result.maxclass = -1;
<a name="l01142"></a>01142        result.isreplace = -1;
<a name="l01143"></a>01143     END IF;
<a name="l01144"></a>01144     RETURN result;
<a name="l01145"></a>01145 END
<a name="l01146"></a>01146 $$ LANGUAGE PLPGSQL;
<a name="l01147"></a>01147 
<a name="l01148"></a>01148 DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.__rep_aggr_class_count
<a name="l01149"></a>01149     (
<a name="l01150"></a>01150     INT,
<a name="l01151"></a>01151     INT,
<a name="l01152"></a>01152     INT
<a name="l01153"></a>01153     );
<a name="l01154"></a>01154 CREATE AGGREGATE MADLIB_SCHEMA.__rep_aggr_class_count
<a name="l01155"></a>01155     (
<a name="l01156"></a>01156     INT,
<a name="l01157"></a>01157     INT,
<a name="l01158"></a>01158     INT
<a name="l01159"></a>01159     ) 
<a name="l01160"></a>01160 (
<a name="l01161"></a>01161   SFUNC=MADLIB_SCHEMA.__rep_aggr_class_count_sfunc,
<a name="l01162"></a>01162   m4_ifdef(`__GREENPLUM__&#39;, `prefunc=MADLIB_SCHEMA.__rep_aggr_class_count_prefunc,&#39;)
<a name="l01163"></a>01163   FINALFUNC=MADLIB_SCHEMA.__rep_aggr_class_count_ffunc,
<a name="l01164"></a>01164   STYPE=BIGINT[]
<a name="l01165"></a>01165 );
<a name="l01166"></a>01166 
<a name="l01167"></a>01167 <span class="comment">/*</span>
<a name="l01168"></a>01168 <span class="comment"> * This type is used to store information for the calculated best split </span>
<a name="l01169"></a>01169 <span class="comment"> *</span>
<a name="l01170"></a>01170 <span class="comment"> * Parameters:</span>
<a name="l01171"></a>01171 <span class="comment"> *      feature:              The ID of the selected feature.</span>
<a name="l01172"></a>01172 <span class="comment"> *      probability:          The predicted probability of our chosen class.</span>
<a name="l01173"></a>01173 <span class="comment"> *      maxclass:             The ID of the class chosen by the algorithm</span>
<a name="l01174"></a>01174 <span class="comment"> *      infoGain:             The information gain.</span>
<a name="l01175"></a>01175 <span class="comment"> *      live:                 1- For the chosen split, we should split further.</span>
<a name="l01176"></a>01176 <span class="comment"> *                            0- For the chosen split, we shouldn&#39;t split further.</span>
<a name="l01177"></a>01177 <span class="comment"> *      ebp_coeff:            total error for error-based pruning.</span>
<a name="l01178"></a>01178 <span class="comment"> *      is_cont_feature:      whether the selected feature is continuous.</span>
<a name="l01179"></a>01179 <span class="comment"> *      split_value:          If the selected feature is continuous, it specifies</span>
<a name="l01180"></a>01180 <span class="comment"> *                            the split value. Otherwise, it is of no use.</span>
<a name="l01181"></a>01181 <span class="comment"> *      distinct_features:    The number of distinct values for the selected feature.</span>
<a name="l01182"></a>01182 <span class="comment"> */</span>
<a name="l01183"></a>01183 DROP TYPE IF EXISTS MADLIB_SCHEMA.__best_split_result CASCADE;
<a name="l01184"></a>01184 CREATE TYPE MADLIB_SCHEMA.__best_split_result AS
<a name="l01185"></a>01185     (
<a name="l01186"></a>01186     node_id             INT,
<a name="l01187"></a>01187     feature             INT,
<a name="l01188"></a>01188     probability         FLOAT,
<a name="l01189"></a>01189     maxclass            INTEGER,
<a name="l01190"></a>01190     infogain            FLOAT,
<a name="l01191"></a>01191     live                INT,
<a name="l01192"></a>01192     ebp_coeff           FLOAT,
<a name="l01193"></a>01193     is_cont_feature     BOOLEAN,
<a name="l01194"></a>01194     split_value         FLOAT,
<a name="l01195"></a>01195     distinct_features   INT,
<a name="l01196"></a>01196     total_size          INT
<a name="l01197"></a>01197     );
<a name="l01198"></a>01198 
<a name="l01199"></a>01199 <span class="comment">/*</span>
<a name="l01200"></a>01200 <span class="comment"> * This function find the best split and return the information.</span>
<a name="l01201"></a>01201 <span class="comment"> *</span>
<a name="l01202"></a>01202 <span class="comment"> * Parameters:</span>
<a name="l01203"></a>01203 <span class="comment"> *  feature_dimensions:     The total number of different features</span>
<a name="l01204"></a>01204 <span class="comment"> *  featureValCountStr:     A string in csv format. Each element is </span>
<a name="l01205"></a>01205 <span class="comment"> *                          a numeric value equal to the count of </span>
<a name="l01206"></a>01206 <span class="comment"> *                          distinct features for each feature.</span>
<a name="l01207"></a>01207 <span class="comment"> *  distinct_classes:       Total number of different classes.</span>
<a name="l01208"></a>01208 <span class="comment"> *  assigned_nid:              It specifies which part of records should </span>
<a name="l01209"></a>01209 <span class="comment"> *                          be used to calculate the best split.</span>
<a name="l01210"></a>01210 <span class="comment"> *  table_name:             The name of the table containing the training</span>
<a name="l01211"></a>01211 <span class="comment"> *                          set.</span>
<a name="l01212"></a>01212 <span class="comment"> *  confidence_level:       This parameter is used by the &#39;Error-Based Pruning&#39;.</span>
<a name="l01213"></a>01213 <span class="comment"> *                          Please refer to the paper for detailed definition.</span>
<a name="l01214"></a>01214 <span class="comment"> *                          The paper&#39;s name is &#39;Error-Based Pruning of Decision  </span>
<a name="l01215"></a>01215 <span class="comment"> *                          Trees Grown on Very Large Data Sets Can Work!&#39;.</span>
<a name="l01216"></a>01216 <span class="comment"> *  feature_table_name:     Is is the name of one internal table, which contains</span>
<a name="l01217"></a>01217 <span class="comment"> *                          meta data for each feature.</span>
<a name="l01218"></a>01218 <span class="comment"> *  sp_criterion:           It defines the split criterion to be used.</span>
<a name="l01219"></a>01219 <span class="comment"> *                          (1- information gain. 2- gain ratio. 3- gini)</span>
<a name="l01220"></a>01220 <span class="comment"> *  continue_gow:           It specifies whether we should still grow the tree</span>
<a name="l01221"></a>01221 <span class="comment"> *                          on the selected branch.</span>
<a name="l01222"></a>01222 <span class="comment"> * Return:</span>
<a name="l01223"></a>01223 <span class="comment"> *  The return is of the type of MADLIB_SCHEMA.__best_split_result, which contains the information</span>
<a name="l01224"></a>01224 <span class="comment"> *  for best split. Please refer to that structure for detailed definition. </span>
<a name="l01225"></a>01225 <span class="comment"> */</span>
<a name="l01226"></a>01226 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__find_best_split
<a name="l01227"></a>01227     (
<a name="l01228"></a>01228     feature_dimensions      INT, 
<a name="l01229"></a>01229     distinct_classes        INT,  
<a name="l01230"></a>01230     selection_begin         INT, 
<a name="l01231"></a>01231     selection_cnt           INT,
<a name="l01232"></a>01232     table_name              TEXT, 
<a name="l01233"></a>01233     confidence_level        FLOAT,
<a name="l01234"></a>01234     feature_table_name      TEXT, 
<a name="l01235"></a>01235     sp_criterion            INT, 
<a name="l01236"></a>01236     continue_gow            INT
<a name="l01237"></a>01237     );
<a name="l01238"></a>01238     
<a name="l01239"></a>01239 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__find_best_split
<a name="l01240"></a>01240     (
<a name="l01241"></a>01241     feature_dimensions      INT, 
<a name="l01242"></a>01242     distinct_classes        INT,  
<a name="l01243"></a>01243     selection_begin         INT, 
<a name="l01244"></a>01244     selection_cnt           INT, 
<a name="l01245"></a>01245     table_name              TEXT, 
<a name="l01246"></a>01246     confidence_level        FLOAT,
<a name="l01247"></a>01247     feature_table_name      TEXT, 
<a name="l01248"></a>01248     sp_criterion            INT, 
<a name="l01249"></a>01249     continue_gow            INT
<a name="l01250"></a>01250     ) 
<a name="l01251"></a>01251 RETURNS SETOF MADLIB_SCHEMA.__best_split_result AS $$
<a name="l01252"></a>01252 DECLARE
<a name="l01253"></a>01253     total_size         INT;
<a name="l01254"></a>01254     result             MADLIB_SCHEMA.__best_split_result;
<a name="l01255"></a>01255     has_cont_text      TEXT := &#39;t&#39;;
<a name="l01256"></a>01256     curstmt            TEXT := &#39;&#39;;
<a name="l01257"></a>01257     result_rec         RECORD;
<a name="l01258"></a>01258     exec_begin         TIMESTAMP;
<a name="l01259"></a>01259     best_answer        FLOAT8[];
<a name="l01260"></a>01260 BEGIN    
<a name="l01261"></a>01261     exec_begin = clock_timestamp();
<a name="l01262"></a>01262     
<a name="l01263"></a>01263     TRUNCATE info_impurity;
<a name="l01264"></a>01264     
<a name="l01265"></a>01265     SELECT MADLIB_SCHEMA.__format
<a name="l01266"></a>01266         (
<a name="l01267"></a>01267         &#39;INSERT INTO info_impurity 
<a name="l01268"></a>01268         SELECT assigned_nid, 
<a name="l01269"></a>01269              MAX(le) 
<a name="l01270"></a>01270         FROM %
<a name="l01271"></a>01271         WHERE fid IS NULL 
<a name="l01272"></a>01272         AND assigned_nid IS NOT NULL 
<a name="l01273"></a>01273         AND class IS NULL
<a name="l01274"></a>01274         GROUP BY assigned_nid;&#39;,
<a name="l01275"></a>01275         table_name
<a name="l01276"></a>01276         )
<a name="l01277"></a>01277     INTO curstmt;
<a name="l01278"></a>01278     
<a name="l01279"></a>01279     EXECUTE curstmt;
<a name="l01280"></a>01280     
<a name="l01281"></a>01281 m4_changequote(`&gt;&gt;&gt;&#39;, `&lt;&lt;&lt;&#39;)
<a name="l01282"></a>01282 m4_ifdef(&gt;&gt;&gt;__HAS_ORDERED_AGGREGATES__&lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l01283"></a>01283     -- With ordered aggregate support, we can use this facility.
<a name="l01284"></a>01284     SELECT MADLIB_SCHEMA.__format
<a name="l01285"></a>01285         (
<a name="l01286"></a>01286         &#39;SELECT s1.assigned_nid, 
<a name="l01287"></a>01287             MAX(ARRAY[s1.info_impurity, s1.fid, coalesce(s1.split_value, &#39;&#39;NaN&#39;&#39;::FLOAT8), s1.class_prob, s1.class_id, s1.total_size]::FLOAT8[]) as info
<a name="l01288"></a>01288         FROM (
<a name="l01289"></a>01289             SELECT assigned_nid,fid,split_value,
<a name="l01290"></a>01290                 (MADLIB_SCHEMA.__scv_aggr_wrapper(
<a name="l01291"></a>01291                     MADLIB_SCHEMA.__scv_aggr
<a name="l01292"></a>01292                         (%,fval,class,is_cont,le,gt, total_size
<a name="l01293"></a>01293                         ORDER BY fval desc,class desc)
<a name="l01294"></a>01294                     )::MADLIB_SCHEMA.__scv_aggr_result).*
<a name="l01295"></a>01295             FROM (
<a name="l01296"></a>01296                 SELECT t1.*, t2.total_size FROM % t1, info_impurity t2
<a name="l01297"></a>01297                 WHERE t1.assigned_nid = t2.assigned_nid AND 
<a name="l01298"></a>01298                         (t1.fid IS NOT NULL) AND (t1.assigned_nid IS NOT NULL AND t2.assigned_nid IS NOT NULL)
<a name="l01299"></a>01299                 ) y 
<a name="l01300"></a>01300             GROUP BY assigned_nid,fid,split_value 
<a name="l01301"></a>01301             ) s1  
<a name="l01302"></a>01302         GROUP BY s1.assigned_nid
<a name="l01303"></a>01303         ORDER BY s1.assigned_nid;&#39;,
<a name="l01304"></a>01304         MADLIB_SCHEMA.__to_char(sp_criterion),
<a name="l01305"></a>01305         table_name
<a name="l01306"></a>01306         )
<a name="l01307"></a>01307     INTO curstmt;   
<a name="l01308"></a>01308 &lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l01309"></a>01309     -- Without ordered aggregate support, we use window function as a workaround.
<a name="l01310"></a>01310     -- The performance is much worse than ordered aggregate.
<a name="l01311"></a>01311     SELECT MADLIB_SCHEMA.__format
<a name="l01312"></a>01312         (
<a name="l01313"></a>01313         &#39;SELECT s1.assigned_nid, 
<a name="l01314"></a>01314             MAX(ARRAY[s1.info_impurity, s1.fid, coalesce(s1.split_value, &#39;&#39;NaN&#39;&#39;::FLOAT8), s1.class_prob, s1.class_id, s1.total_size]::FLOAT8[]) as info
<a name="l01315"></a>01315         FROM (
<a name="l01316"></a>01316             SELECT * FROM (
<a name="l01317"></a>01317               SELECT assigned_nid,fid,split_value,
<a name="l01318"></a>01318                 row_number() over
<a name="l01319"></a>01319                         (PARTITION BY assigned_nid,fid,split_value 
<a name="l01320"></a>01320                          ORDER BY fval asc,class asc) as row_num,
<a name="l01321"></a>01321                 (MADLIB_SCHEMA.__scv_aggr_wrapper(
<a name="l01322"></a>01322                     MADLIB_SCHEMA.__scv_aggr
<a name="l01323"></a>01323                         (%,fval,class,is_cont,le,gt, total_size) over
<a name="l01324"></a>01324                         (PARTITION BY assigned_nid,fid,split_value 
<a name="l01325"></a>01325                          ORDER BY fval desc,class desc)
<a name="l01326"></a>01326                     )::MADLIB_SCHEMA.__scv_aggr_result).*
<a name="l01327"></a>01327               FROM (
<a name="l01328"></a>01328                 SELECT t1.*, t2.total_size FROM % t1, info_impurity t2
<a name="l01329"></a>01329                 WHERE t1.assigned_nid = t2.assigned_nid AND 
<a name="l01330"></a>01330                         (t1.fid IS NOT NULL) AND (t1.assigned_nid IS NOT NULL AND t2.assigned_nid IS NOT NULL)
<a name="l01331"></a>01331                 ) y 
<a name="l01332"></a>01332               ) k where row_num =1 
<a name="l01333"></a>01333             ) s1    
<a name="l01334"></a>01334         GROUP BY s1.assigned_nid
<a name="l01335"></a>01335         ORDER BY s1.assigned_nid;&#39;,
<a name="l01336"></a>01336         MADLIB_SCHEMA.__to_char(sp_criterion),
<a name="l01337"></a>01337         table_name
<a name="l01338"></a>01338         )
<a name="l01339"></a>01339     INTO curstmt;   
<a name="l01340"></a>01340 &lt;&lt;&lt;)
<a name="l01341"></a>01341 m4_changequote(&gt;&gt;&gt;`&lt;&lt;&lt;, &gt;&gt;&gt;&#39;&lt;&lt;&lt;)
<a name="l01342"></a>01342     
<a name="l01343"></a>01343     -- s1.info_impurity[1], s1.fid[2], s1.split_value[3], 
<a name="l01344"></a>01344     -- s2.class_prob[4], s2.class_id[5], s1.total_size[6]
<a name="l01345"></a>01345     FOR result_rec IN EXECUTE (curstmt) LOOP
<a name="l01346"></a>01346         result.node_id              = result_rec.assigned_nid;
<a name="l01347"></a>01347         best_answer                 = result_rec.info;
<a name="l01348"></a>01348         result.feature              = best_answer[2];
<a name="l01349"></a>01349         result.maxclass             = best_answer[5];
<a name="l01350"></a>01350         result.probability          = best_answer[4];
<a name="l01351"></a>01351         result.infogain             = best_answer[1];
<a name="l01352"></a>01352         result.total_size           = best_answer[6];
<a name="l01353"></a>01353         result.distinct_features    = MADLIB_SCHEMA.__distinct_feature_value(feature_table_name, result.feature);
<a name="l01354"></a>01354         
<a name="l01355"></a>01355         IF (result.probability &gt; 0.999999999 OR float8le(result.infogain, 0)) THEN
<a name="l01356"></a>01356             result.live = 0;
<a name="l01357"></a>01357         ELSE
<a name="l01358"></a>01358             result.live = 1;
<a name="l01359"></a>01359         END IF;
<a name="l01360"></a>01360         
<a name="l01361"></a>01361         result.ebp_coeff = MADLIB_SCHEMA.__ebp_calc_errors(result.total_size, result.probability, confidence_level); 
<a name="l01362"></a>01362         
<a name="l01363"></a>01363         IF (best_answer[3] = &#39;NaN&#39;::FLOAT8) THEN
<a name="l01364"></a>01364             result.split_value      = NULL;
<a name="l01365"></a>01365         ELSE
<a name="l01366"></a>01366             result.split_value      = best_answer[3];
<a name="l01367"></a>01367         END IF;
<a name="l01368"></a>01368         result.is_cont_feature  = (result.split_value IS NOT NULL);
<a name="l01369"></a>01369         
<a name="l01370"></a>01370         RETURN next result;
<a name="l01371"></a>01371     END LOOP;
<a name="l01372"></a>01372         
<a name="l01373"></a>01373     RETURN;
<a name="l01374"></a>01374 END
<a name="l01375"></a>01375 $$ LANGUAGE PLPGSQL;
<a name="l01376"></a>01376 
<a name="l01377"></a>01377 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__jump_aggr_sfunc
<a name="l01378"></a>01378     (
<a name="l01379"></a>01379     INT[], 
<a name="l01380"></a>01380     INT, 
<a name="l01381"></a>01381     INT
<a name="l01382"></a>01382     ) CASCADE;
<a name="l01383"></a>01383 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__jump_aggr_sfunc
<a name="l01384"></a>01384     (
<a name="l01385"></a>01385     INT[], 
<a name="l01386"></a>01386     INT, 
<a name="l01387"></a>01387     INT
<a name="l01388"></a>01388     ) 
<a name="l01389"></a>01389 RETURNS INT[] AS $$
<a name="l01390"></a>01390 DECLARE
<a name="l01391"></a>01391     temp INT[];
<a name="l01392"></a>01392 BEGIN
<a name="l01393"></a>01393     temp = $1;
<a name="l01394"></a>01394     temp[$2+1] = $3;
<a name="l01395"></a>01395     
<a name="l01396"></a>01396     RETURN temp;
<a name="l01397"></a>01397 END
<a name="l01398"></a>01398 $$ LANGUAGE PLPGSQL;
<a name="l01399"></a>01399 
<a name="l01400"></a>01400 DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.__jump_aggr
<a name="l01401"></a>01401     (
<a name="l01402"></a>01402     INT, 
<a name="l01403"></a>01403     INT
<a name="l01404"></a>01404     );
<a name="l01405"></a>01405 CREATE AGGREGATE MADLIB_SCHEMA.__jump_aggr
<a name="l01406"></a>01406     (
<a name="l01407"></a>01407     INT, 
<a name="l01408"></a>01408     INT
<a name="l01409"></a>01409     ) 
<a name="l01410"></a>01410 (
<a name="l01411"></a>01411   SFUNC=MADLIB_SCHEMA.__jump_aggr_sfunc,
<a name="l01412"></a>01412   STYPE=INT[]
<a name="l01413"></a>01413 );
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 
<a name="l01416"></a>01416 <span class="comment">/*</span>
<a name="l01417"></a>01417 <span class="comment"> *   For training one decision tree, we need some internal tables</span>
<a name="l01418"></a>01418 <span class="comment"> *   to store intermediate results. This function creates those</span>
<a name="l01419"></a>01419 <span class="comment"> *   tables. Moreover, this function also creates the tree table</span>
<a name="l01420"></a>01420 <span class="comment"> *   specified by user.</span>
<a name="l01421"></a>01421 <span class="comment"> *</span>
<a name="l01422"></a>01422 <span class="comment"> *   Parameters:</span>
<a name="l01423"></a>01423 <span class="comment"> *      result_tree_table_name: The name of the tree specified by user.      </span>
<a name="l01424"></a>01424 <span class="comment"> */</span>
<a name="l01425"></a>01425 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__create_tree_tables
<a name="l01426"></a>01426     (
<a name="l01427"></a>01427     TEXT
<a name="l01428"></a>01428     );
<a name="l01429"></a>01429 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_tree_tables
<a name="l01430"></a>01430     (
<a name="l01431"></a>01431     result_tree_table_name TEXT
<a name="l01432"></a>01432     ) 
<a name="l01433"></a>01433 RETURNS <span class="keywordtype">void</span> AS $$ 
<a name="l01434"></a>01434 BEGIN
<a name="l01435"></a>01435     -- The training algorithm starts by eliminating all redundant points, 
<a name="l01436"></a>01436     -- by producing a smaller subset of unique, weighted points,
<a name="l01437"></a>01437     -- which was stored by the two tables below.
<a name="l01438"></a>01438     --  Columns:
<a name="l01439"></a>01439     --      <span class="keywordtype">id</span>:             It is used to uniquely identify one record.
<a name="l01440"></a>01440     --      feature:        It is used to store the value of one unique record.
<a name="l01441"></a>01441     --      class:          The class of that record.
<a name="l01442"></a>01442     --      weight:         The count of such a record.
<a name="l01443"></a>01443     --      assigned_nid:   This field is not used while removing redundant records.
<a name="l01444"></a>01444     --                      It is used to train a decision tree.
<a name="l01445"></a>01445 
<a name="l01446"></a>01446 
<a name="l01447"></a>01447     DROP TABLE IF EXISTS training_instance CASCADE;
<a name="l01448"></a>01448     CREATE TEMP TABLE training_instance
<a name="l01449"></a>01449     (
<a name="l01450"></a>01450         fid            INTEGER,
<a name="l01451"></a>01451         fval           FLOAT8,
<a name="l01452"></a>01452         class          INTEGER,
<a name="l01453"></a>01453         is_cont        BOOLEAN,
<a name="l01454"></a>01454         split_value    FLOAT8,
<a name="l01455"></a>01455         le             BIGINT,
<a name="l01456"></a>01456         gt             BIGINT,
<a name="l01457"></a>01457         assigned_nid   BIGINT
<a name="l01458"></a>01458     ) m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (fid, fval)&#39;);
<a name="l01459"></a>01459     
<a name="l01460"></a>01460     DROP TABLE IF EXISTS training_instance_aux CASCADE;
<a name="l01461"></a>01461     CREATE TEMP TABLE training_instance_aux
<a name="l01462"></a>01462     (
<a name="l01463"></a>01463         fid             INTEGER,
<a name="l01464"></a>01464         fval            FLOAT8,
<a name="l01465"></a>01465         is_cont         BOOLEAN,
<a name="l01466"></a>01466         class           INTEGER,
<a name="l01467"></a>01467         count           INTEGER,
<a name="l01468"></a>01468         assigned_nid    BIGINT
<a name="l01469"></a>01469     ) m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (fid, fval)&#39;);
<a name="l01470"></a>01470 
<a name="l01471"></a>01471     DROP TABLE IF EXISTS info_impurity CASCADE;
<a name="l01472"></a>01472     CREATE TEMP TABLE info_impurity
<a name="l01473"></a>01473     (
<a name="l01474"></a>01474         assigned_nid         BIGINT,
<a name="l01475"></a>01475         total_size           BIGINT
<a name="l01476"></a>01476     )m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (assigned_nid)&#39;);
<a name="l01477"></a>01477     
<a name="l01478"></a>01478     -- The table below stores the decision tree information just constructed.
<a name="l01479"></a>01479     -- It is an internal table, which contains some redundant nodes. 
<a name="l01480"></a>01480     -- In the last step, we will remove those redundant nodes and move the
<a name="l01481"></a>01481     -- useful records to the table specified by user.
<a name="l01482"></a>01482     -- Columns:
<a name="l01483"></a>01483     --      <span class="keywordtype">id</span>:             Tree node <span class="keywordtype">id</span>
<a name="l01484"></a>01484     --      tree_location:  Set of values that lead to this branch. 
<a name="l01485"></a>01485     --                      0 is the initial point (no value). But this path 
<a name="l01486"></a>01486     --                      does not specify which feature was used
<a name="l01487"></a>01487     --                      for the branching.
<a name="l01488"></a>01488     --      feature:        Which element of the feature vector was used for 
<a name="l01489"></a>01489     --                      branching at this node. Notice that this feature is not 
<a name="l01490"></a>01490     --                      used in the current tree_location. It will be added 
<a name="l01491"></a>01491     --                      in the next step.
<a name="l01492"></a>01492     --      probability:    If forced to make a call for a dominant class 
<a name="l01493"></a>01493     --                      at a given point this would be the confidence of the 
<a name="l01494"></a>01494     --                      call (this is only an estimated value).
<a name="l01495"></a>01495     --      maxclass:       If forced to make a call for a dominant class 
<a name="l01496"></a>01496     --                      at a given point this is the selected class.
<a name="l01497"></a>01497     --      split_gain:     Information gain computed using entropy (at this 
<a name="l01498"></a>01498     --                      node), also used to determine termination of the branch.
<a name="l01499"></a>01499     --      live:           Indication that the branch is still growing. 1 means &quot;live&quot;. 
<a name="l01500"></a>01500     --      cat_size:       Number of data point at this node.
<a name="l01501"></a>01501     --      parent_id:      Id of the parent branch.
<a name="l01502"></a>01502     --      jump:           Location of children for each feature value. 
<a name="l01503"></a>01503     --                      Result such as [2:3]={2,3}, should be read: 
<a name="l01504"></a>01504     --                      jump[<span class="stringliteral">&#39;feature value&#39;</span>+1], so in <span class="keyword">this</span> <span class="keywordflow">case</span> there were no 
<a name="l01505"></a>01505     --                      0-value points <span class="keywordflow">for</span> <span class="keyword">this</span> feature. For value 1 jump to 2; 
<a name="l01506"></a>01506     --                      <span class="keywordflow">for</span> value 2 jump to 3;
<a name="l01507"></a>01507     --      is_feature_cont: It specifies whether the selected feature is a continuous feature.
<a name="l01508"></a>01508     --      split_value:    For continuous feature, it specifies the split value. Otherwise, 
<a name="l01509"></a>01509     --                      it is of no meaning and fixed to 0.    
<a name="l01510"></a>01510     --
<a name="l01511"></a>01511     DROP TABLE IF EXISTS tree_internal CASCADE;
<a name="l01512"></a>01512     CREATE TEMP TABLE tree_internal
<a name="l01513"></a>01513     (
<a name="l01514"></a>01514         <span class="keywordtype">id</span>              SERIAL,
<a name="l01515"></a>01515         tree_location   INT[],
<a name="l01516"></a>01516         feature         INT,
<a name="l01517"></a>01517         probability     FLOAT,
<a name="l01518"></a>01518         ebp_coeff       FLOAT,
<a name="l01519"></a>01519         maxclass        INTEGER,
<a name="l01520"></a>01520         split_gain      FLOAT,
<a name="l01521"></a>01521         live            INT,
<a name="l01522"></a>01522         cat_size        INT,
<a name="l01523"></a>01523         parent_id       INT,
<a name="l01524"></a>01524         jump            INT[],
<a name="l01525"></a>01525         is_feature_cont BOOLEAN,
<a name="l01526"></a>01526         split_value     FLOAT
<a name="l01527"></a>01527     ) m4_ifdef(`__GREENPLUM__<span class="stringliteral">&#39;, `DISTRIBUTED BY (id)&#39;</span>);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529     -- The table below stores the <span class="keyword">final</span> decision tree information.
<a name="l01530"></a>01530     -- It is an the table specified by users. 
<a name="l01531"></a>01531     -- Please refer the table above <span class="keywordflow">for</span> detailed column definition.
<a name="l01532"></a>01532     EXECUTE <span class="stringliteral">&#39;DROP TABLE IF EXISTS &#39;</span>||result_tree_table_name||<span class="stringliteral">&#39; CASCADE;&#39;</span>;
<a name="l01533"></a>01533     EXECUTE <span class="stringliteral">&#39;CREATE TABLE &#39;</span>||result_tree_table_name||E<span class="stringliteral">&#39;</span>
<a name="l01534"></a>01534 <span class="stringliteral">    (</span>
<a name="l01535"></a>01535 <span class="stringliteral">        id              SERIAL,</span>
<a name="l01536"></a>01536 <span class="stringliteral">        tree_location   INT[],</span>
<a name="l01537"></a>01537 <span class="stringliteral">        feature         INT,</span>
<a name="l01538"></a>01538 <span class="stringliteral">        probability     FLOAT,</span>
<a name="l01539"></a>01539 <span class="stringliteral">        ebp_coeff       FLOAT,</span>
<a name="l01540"></a>01540 <span class="stringliteral">        maxclass        INTEGER,</span>
<a name="l01541"></a>01541 <span class="stringliteral">        split_gain      FLOAT,</span>
<a name="l01542"></a>01542 <span class="stringliteral">        live            INT,</span>
<a name="l01543"></a>01543 <span class="stringliteral">        cat_size        INT,</span>
<a name="l01544"></a>01544 <span class="stringliteral">        parent_id       INT,</span>
<a name="l01545"></a>01545 <span class="stringliteral">        jump            INT[],</span>
<a name="l01546"></a>01546 <span class="stringliteral">        is_feature_cont BOOLEAN,</span>
<a name="l01547"></a>01547 <span class="stringliteral">        split_value     FLOAT    </span>
<a name="l01548"></a>01548 <span class="stringliteral">    ) m4_ifdef(`__GREENPLUM__&#39;</span>, `DISTRIBUTED BY (<span class="keywordtype">id</span>)<span class="stringliteral">&#39;);&#39;</span>;
<a name="l01549"></a>01549 
<a name="l01550"></a>01550     -- These two auxiliary <span class="keyword">internal</span> tables help to
<a name="l01551"></a>01551     -- <span class="keyword">remove</span> redundant tree nodes and move the useful
<a name="l01552"></a>01552     -- node to the <span class="keyword">final</span> tree table.
<a name="l01553"></a>01553     DROP TABLE IF EXISTS auxiliary_tree_info CASCADE;
<a name="l01554"></a>01554     CREATE TEMP TABLE auxiliary_tree_info
<a name="l01555"></a>01555     (
<a name="l01556"></a>01556         <span class="keywordtype">id</span>          INT,
<a name="l01557"></a>01557         new_id      INT,
<a name="l01558"></a>01558         parent_id   INT
<a name="l01559"></a>01559     ) m4_ifdef(`__GREENPLUM__<span class="stringliteral">&#39;, `DISTRIBUTED BY (id)&#39;</span>);
<a name="l01560"></a>01560 
<a name="l01561"></a>01561     DROP TABLE IF EXISTS auxiliary_tree_info2 CASCADE;
<a name="l01562"></a>01562     CREATE TEMP TABLE auxiliary_tree_info2
<a name="l01563"></a>01563     (
<a name="l01564"></a>01564         <span class="keywordtype">id</span>          INT,
<a name="l01565"></a>01565         new_id      INT,
<a name="l01566"></a>01566         parent_id   INT
<a name="l01567"></a>01567     ) m4_ifdef(`__GREENPLUM__<span class="stringliteral">&#39;, `DISTRIBUTED BY (id)&#39;</span>);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 END 
<a name="l01570"></a>01570 $$ LANGUAGE PLPGSQL;
<a name="l01571"></a>01571 
<a name="l01572"></a>01572 <span class="comment">/*</span>
<a name="l01573"></a>01573 <span class="comment"> * Prune the trained tree with &quot;Reduced Error Pruning&quot; algorithm</span>
<a name="l01574"></a>01574 <span class="comment"> *  </span>
<a name="l01575"></a>01575 <span class="comment"> * Parameters:</span>
<a name="l01576"></a>01576 <span class="comment"> *      tree_table_name:    The name of the table containing the tree.</span>
<a name="l01577"></a>01577 <span class="comment"> *      validation_table:   The name of the table containing validation set.</span>
<a name="l01578"></a>01578 <span class="comment"> *      max_num_classes:    The count of different classes.</span>
<a name="l01579"></a>01579 <span class="comment"> */</span>
<a name="l01580"></a>01580 DROP FUNCTION IF EXISTS  MADLIB_SCHEMA.__rep_prune_tree
<a name="l01581"></a>01581     (
<a name="l01582"></a>01582     tree_table_name     TEXT, 
<a name="l01583"></a>01583     validation_table    TEXT, 
<a name="l01584"></a>01584     max_num_classes     INT
<a name="l01585"></a>01585     );
<a name="l01586"></a>01586 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__rep_prune_tree
<a name="l01587"></a>01587     (
<a name="l01588"></a>01588     tree_table_name     TEXT, 
<a name="l01589"></a>01589     validation_table    TEXT, 
<a name="l01590"></a>01590     max_num_classes     INT
<a name="l01591"></a>01591     ) 
<a name="l01592"></a>01592 RETURNS <span class="keywordtype">void</span> AS $$
<a name="l01593"></a>01593 DECLARE
<a name="l01594"></a>01594     num_parent_ids          INTEGER;
<a name="l01595"></a>01595     cf_table_name           TEXT := <span class="stringliteral">&#39;_ct&#39;</span>;
<a name="l01596"></a>01596     encoded_table_name      TEXT;
<a name="l01597"></a>01597     metatable_name          TEXT ;
<a name="l01598"></a>01598     curstmt                 TEXT;
<a name="l01599"></a>01599     id_col_name             TEXT;
<a name="l01600"></a>01600     class_col_name          TEXT;
<a name="l01601"></a>01601     classify_result         TEXT;
<a name="l01602"></a>01602     temp_text               TEXT;
<a name="l01603"></a>01603     n                       INT;
<a name="l01604"></a>01604 BEGIN
<a name="l01605"></a>01605     metatable_name  = MADLIB_SCHEMA.__get_metatable_name(tree_table_name);
<a name="l01606"></a>01606     id_col_name     = MADLIB_SCHEMA.__get_id_column_name(metatable_name);
<a name="l01607"></a>01607     class_col_name  = MADLIB_SCHEMA.__get_class_column_name(metatable_name);
<a name="l01608"></a>01608     
<a name="l01609"></a>01609     -- the value of <span class="keyword">class </span>column in validation table must in the KV table
<a name="l01610"></a>01610     SELECT MADLIB_SCHEMA.__format
<a name="l01611"></a>01611         (
<a name="l01612"></a>01612         &#39;SELECT COUNT(*) 
<a name="l01613"></a>01613          FROM %
<a name="l01614"></a>01614          WHERE % NOT IN
<a name="l01615"></a>01615             (SELECT % FROM MADLIB_SCHEMA.% WHERE % IS NOT NULL)<span class="stringliteral">&#39;,</span>
<a name="l01616"></a>01616 <span class="stringliteral">        ARRAY[</span>
<a name="l01617"></a>01617 <span class="stringliteral">            validation_table,</span>
<a name="l01618"></a>01618 <span class="stringliteral">            class_col_name,</span>
<a name="l01619"></a>01619 <span class="stringliteral">            class_col_name,</span>
<a name="l01620"></a>01620 <span class="stringliteral">            MADLIB_SCHEMA.__get_classtable_name(metatable_name),</span>
<a name="l01621"></a>01621 <span class="stringliteral">            class_col_name</span>
<a name="l01622"></a>01622 <span class="stringliteral">        ]</span>
<a name="l01623"></a>01623 <span class="stringliteral">        )</span>
<a name="l01624"></a>01624 <span class="stringliteral">    INTO curstmt;</span>
<a name="l01625"></a>01625 <span class="stringliteral">    </span>
<a name="l01626"></a>01626 <span class="stringliteral">    EXECUTE curstmt INTO n;</span>
<a name="l01627"></a>01627 <span class="stringliteral">    </span>
<a name="l01628"></a>01628 <span class="stringliteral">    PERFORM MADLIB_SCHEMA.__assert</span>
<a name="l01629"></a>01629 <span class="stringliteral">            (</span>
<a name="l01630"></a>01630 <span class="stringliteral">                n = 0,</span>
<a name="l01631"></a>01631 <span class="stringliteral">                &#39;</span>the value of <span class="keyword">class </span>column in validation table must in training table&#39;
<a name="l01632"></a>01632             ); 
<a name="l01633"></a>01633 
<a name="l01634"></a>01634     cf_table_name   = MADLIB_SCHEMA.__get_schema_name(tree_table_name)    ||
<a name="l01635"></a>01635                       MADLIB_SCHEMA.__strip_schema_name(tree_table_name)  || 
<a name="l01636"></a>01636                       cf_table_name;
<a name="l01637"></a>01637     classify_result = cf_table_name;   
<a name="l01638"></a>01638                         
<a name="l01639"></a>01639     SELECT MADLIB_SCHEMA.__c45_classify_internal
<a name="l01640"></a>01640     (
<a name="l01641"></a>01641         validation_table, 
<a name="l01642"></a>01642         tree_table_name, 
<a name="l01643"></a>01643         classify_result, 
<a name="l01644"></a>01644         <span class="charliteral">&#39;t&#39;</span>,
<a name="l01645"></a>01645         <span class="charliteral">&#39;f&#39;</span>
<a name="l01646"></a>01646     ) INTO encoded_table_name;
<a name="l01647"></a>01647 
<a name="l01648"></a>01648     -- after encoding in classification, class_col_name is fixed to <span class="keyword">class</span>
<a name="l01649"></a>01649     class_col_name  = <span class="stringliteral">&#39;class&#39;</span>;
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 m4_changequote(`&gt;&gt;&gt;<span class="stringliteral">&#39;, `&lt;&lt;&lt;&#39;</span>)
<a name="l01652"></a>01652 m4_ifdef(&gt;&gt;&gt;__GREENPLUM_PRE_4_1__&lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l01653"></a>01653     EXECUTE &#39;DROP TABLE IF EXISTS c45_rep_pong CASCADE&#39;;
<a name="l01654"></a>01654     EXECUTE &#39;CREATE TEMP TABLE c45_rep_pong AS SELECT * FROM &#39; || classify_result || &#39; LIMIT 0 DISTRIBUTED BY(<span class="keywordtype">id</span>)&#39;;
<a name="l01655"></a>01655 &lt;&lt;&lt;)
<a name="l01656"></a>01656 m4_changequote(&gt;&gt;&gt;`&lt;&lt;&lt;, &gt;&gt;&gt;&#39;&lt;&lt;&lt;)
<a name="l01657"></a>01657     
<a name="l01658"></a>01658     LOOP
<a name="l01659"></a>01659         DROP TABLE IF EXISTS selected_parent_ids_rep;
<a name="l01660"></a>01660         CREATE TEMP TABLE selected_parent_ids_rep
<a name="l01661"></a>01661         (
<a name="l01662"></a>01662             parent_id BIGINT,
<a name="l01663"></a>01663             maxclass  INT
<a name="l01664"></a>01664         ) m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (parent_id)&#39;);
<a name="l01665"></a>01665        
<a name="l01666"></a>01666         SELECT MADLIB_SCHEMA.__format
<a name="l01667"></a>01667             (
<a name="l01668"></a>01668                 &#39;INSERT INTO selected_parent_ids_rep 
<a name="l01669"></a>01669                 SELECT parent_id, (t.g).maxclass as maxclass 
<a name="l01670"></a>01670                 FROM 
<a name="l01671"></a>01671                 (
<a name="l01672"></a>01672                     SELECT parent_id, 
<a name="l01673"></a>01673                            MADLIB_SCHEMA.__rep_aggr_class_count_wrapper(MADLIB_SCHEMA.__rep_aggr_class_count
<a name="l01674"></a>01674                                 (c.class, s.%, % )) as g 
<a name="l01675"></a>01675                     FROM % c, % s 
<a name="l01676"></a>01676                     WHERE c.<span class="keywordtype">id</span>=s.% 
<a name="l01677"></a>01677                     GROUP BY parent_id
<a name="l01678"></a>01678                 ) t 
<a name="l01679"></a>01679                 WHERE (t.g).isreplace &gt;= 0 AND 
<a name="l01680"></a>01680                       t.parent_id IN 
<a name="l01681"></a>01681                       (
<a name="l01682"></a>01682                           Select parent_id FROM % 
<a name="l01683"></a>01683                           WHERE parent_id NOT IN
<a name="l01684"></a>01684                               (
<a name="l01685"></a>01685                                   Select parent_id  
<a name="l01686"></a>01686                                   FROM % 
<a name="l01687"></a>01687                                   WHERE jump IS NOT NULL
<a name="l01688"></a>01688                               ) and <span class="keywordtype">id</span> &lt;&gt; 1
<a name="l01689"></a>01689                       );&#39;,
<a name="l01690"></a>01690                   ARRAY[
<a name="l01691"></a>01691                       class_col_name,
<a name="l01692"></a>01692                       MADLIB_SCHEMA.__to_char(max_num_classes),
<a name="l01693"></a>01693                       classify_result,
<a name="l01694"></a>01694                       encoded_table_name,
<a name="l01695"></a>01695                       id_col_name,
<a name="l01696"></a>01696                       tree_table_name,
<a name="l01697"></a>01697                       tree_table_name
<a name="l01698"></a>01698                   ]
<a name="l01699"></a>01699               )
<a name="l01700"></a>01700               INTO curstmt;
<a name="l01701"></a>01701             
<a name="l01702"></a>01702         EXECUTE curstmt;
<a name="l01703"></a>01703                         
<a name="l01704"></a>01704         EXECUTE &#39;SELECT parent_id FROM selected_parent_ids_rep limit 1;&#39; INTO num_parent_ids;
<a name="l01705"></a>01705         IF (num_parent_ids IS NULL)  THEN
<a name="l01706"></a>01706             EXIT;
<a name="l01707"></a>01707         END IF;
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 m4_changequote(`&gt;&gt;&gt;&#39;, `&lt;&lt;&lt;&#39;)
<a name="l01710"></a>01710 m4_ifdef(`__GREENPLUM_PRE_4_1__&#39;, &gt;&gt;&gt;
<a name="l01711"></a>01711         -- for GPDB4.0, update operation can&#39;t distribute data across segments
<a name="l01712"></a>01712         -- we use two tables to update the data
<a name="l01713"></a>01713         IF (classify_result = &#39;c45_rep_pong&#39;) THEN
<a name="l01714"></a>01714             temp_text = cf_table_name;
<a name="l01715"></a>01715         ELSE
<a name="l01716"></a>01716             temp_text =  &#39;c45_rep_pong&#39;;
<a name="l01717"></a>01717         END IF;
<a name="l01718"></a>01718         
<a name="l01719"></a>01719         EXECUTE &#39;TRUNCATE &#39; ||  temp_text;
<a name="l01720"></a>01720         SELECT MADLIB_SCHEMA.__format
<a name="l01721"></a>01721             (
<a name="l01722"></a>01722             &#39;INSERT INTO %(<span class="keywordtype">id</span>, class, parent_id, leaf_id)
<a name="l01723"></a>01723              SELECT m.<span class="keywordtype">id</span>,  t.maxclass, t.parent_id, t.<span class="keywordtype">id</span>
<a name="l01724"></a>01724              FROM % m, % t
<a name="l01725"></a>01725              WHERE t.<span class="keywordtype">id</span> IN (SELECT parent_id FROM selected_parent_ids_rep) AND
<a name="l01726"></a>01726              m.parent_id = t.<span class="keywordtype">id</span>&#39;,
<a name="l01727"></a>01727             ARRAY[
<a name="l01728"></a>01728                 temp_text,
<a name="l01729"></a>01729                 classify_result,
<a name="l01730"></a>01730                 tree_table_name
<a name="l01731"></a>01731             ]
<a name="l01732"></a>01732             )
<a name="l01733"></a>01733         INTO curstmt;
<a name="l01734"></a>01734         
<a name="l01735"></a>01735         EXECUTE curstmt;
<a name="l01736"></a>01736         
<a name="l01737"></a>01737         classify_result = temp_text;
<a name="l01738"></a>01738 &lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l01739"></a>01739         SELECT MADLIB_SCHEMA.__format
<a name="l01740"></a>01740             (
<a name="l01741"></a>01741                 &#39;UPDATE % m set class = t.maxclass, parent_id = t.parent_id,leaf_id = t.<span class="keywordtype">id</span>  FROM % t
<a name="l01742"></a>01742                  WHERE t.<span class="keywordtype">id</span> IN (SELECT parent_id FROM selected_parent_ids_rep) AND
<a name="l01743"></a>01743                  m.parent_id=t.<span class="keywordtype">id</span>&#39;,
<a name="l01744"></a>01744                 classify_result,
<a name="l01745"></a>01745                 tree_table_name
<a name="l01746"></a>01746             )
<a name="l01747"></a>01747         INTO curstmt;
<a name="l01748"></a>01748         EXECUTE curstmt;        
<a name="l01749"></a>01749 &lt;&lt;&lt;)
<a name="l01750"></a>01750 m4_changequote(&gt;&gt;&gt;`&lt;&lt;&lt;, &gt;&gt;&gt;&#39;&lt;&lt;&lt;)
<a name="l01751"></a>01751             
<a name="l01752"></a>01752         SELECT MADLIB_SCHEMA.__format
<a name="l01753"></a>01753             (
<a name="l01754"></a>01754                 &#39;DELETE FROM % WHERE parent_id IN (SELECT parent_id FROM selected_parent_ids_rep)&#39;,
<a name="l01755"></a>01755                 tree_table_name
<a name="l01756"></a>01756             )
<a name="l01757"></a>01757             INTO curstmt;
<a name="l01758"></a>01758         
<a name="l01759"></a>01759         EXECUTE curstmt;
<a name="l01760"></a>01760 
<a name="l01761"></a>01761         SELECT MADLIB_SCHEMA.__format
<a name="l01762"></a>01762             (
<a name="l01763"></a>01763                 &#39;UPDATE % t1 SET jump = NULL, maxclass = t2.maxclass 
<a name="l01764"></a>01764                  FROM selected_parent_ids_rep t2
<a name="l01765"></a>01765                  WHERE t1.<span class="keywordtype">id</span> = t2.parent_id;&#39;,
<a name="l01766"></a>01766                 tree_table_name
<a name="l01767"></a>01767             )
<a name="l01768"></a>01768             INTO curstmt;
<a name="l01769"></a>01769         
<a name="l01770"></a>01770         EXECUTE curstmt;
<a name="l01771"></a>01771         
<a name="l01772"></a>01772     END LOOP;
<a name="l01773"></a>01773     
<a name="l01774"></a>01774     EXECUTE &#39;DROP TABLE IF EXISTS &#39; || encoded_table_name || &#39; CASCADE;&#39;;
<a name="l01775"></a>01775 END
<a name="l01776"></a>01776 $$ LANGUAGE PLPGSQL;
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 
<a name="l01779"></a>01779 <span class="comment">/*</span>
<a name="l01780"></a>01780 <span class="comment"> * Calculates the total errors used by Error Based Pruning (EBP).</span>
<a name="l01781"></a>01781 <span class="comment"> *</span>
<a name="l01782"></a>01782 <span class="comment"> * Parameters:</span>
<a name="l01783"></a>01783 <span class="comment"> *      total:              the number of total cases represented by the node being processed.</span>
<a name="l01784"></a>01784 <span class="comment"> *      prob:               the probability to mis-classify cases represented by the child nodes</span>
<a name="l01785"></a>01785 <span class="comment"> *                          if they are pruned with EBP.</span>
<a name="l01786"></a>01786 <span class="comment"> *      confidence_level:   a certainty factor to calculate the confidence limits</span>
<a name="l01787"></a>01787 <span class="comment"> *                          for the probability of error using the binomial theorem.</span>
<a name="l01788"></a>01788 <span class="comment"> * Return:</span>
<a name="l01789"></a>01789 <span class="comment"> *      The computed total error</span>
<a name="l01790"></a>01790 <span class="comment"> */</span>
<a name="l01791"></a>01791 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__ebp_calc_errors
<a name="l01792"></a>01792     (
<a name="l01793"></a>01793     total            FLOAT8,
<a name="l01794"></a>01794     prob             FLOAT8,
<a name="l01795"></a>01795     confidence_level FLOAT8
<a name="l01796"></a>01796     );
<a name="l01797"></a>01797 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ebp_calc_errors
<a name="l01798"></a>01798     (
<a name="l01799"></a>01799     total               FLOAT8,
<a name="l01800"></a>01800     prob                FLOAT8,
<a name="l01801"></a>01801     confidence_level    FLOAT8
<a name="l01802"></a>01802     ) RETURNS FLOAT8 
<a name="l01803"></a>01803 AS &#39;MODULE_PATHNAME&#39;, &#39;ebp_calc_errors&#39;
<a name="l01804"></a>01804 LANGUAGE C STRICT IMMUTABLE;
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="comment">/*</span>
<a name="l01807"></a>01807 <span class="comment"> * Prune the trained tree with &quot; Error based Pruning&quot; algorithm</span>
<a name="l01808"></a>01808 <span class="comment"> *  </span>
<a name="l01809"></a>01809 <span class="comment"> * Parameters:</span>
<a name="l01810"></a>01810 <span class="comment"> *      tree_table_name:    The name of the table containing the tree.</span>
<a name="l01811"></a>01811 <span class="comment"> */</span>
<a name="l01812"></a>01812 DROP FUNCTION IF EXISTS  MADLIB_SCHEMA.__ebp_prune_tree
<a name="l01813"></a>01813     (
<a name="l01814"></a>01814     tree_table_name TEXT
<a name="l01815"></a>01815     );
<a name="l01816"></a>01816 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ebp_prune_tree
<a name="l01817"></a>01817     (
<a name="l01818"></a>01818     tree_table_name TEXT
<a name="l01819"></a>01819     ) 
<a name="l01820"></a>01820 RETURNS <span class="keywordtype">void</span> AS $$
<a name="l01821"></a>01821 DECLARE
<a name="l01822"></a>01822     num_parent_ids INTEGER;
<a name="l01823"></a>01823     curstmt TEXT;
<a name="l01824"></a>01824 BEGIN
<a name="l01825"></a>01825     LOOP
<a name="l01826"></a>01826         DROP TABLE IF EXISTS selected_parent_ids_ebp;
<a name="l01827"></a>01827         CREATE TEMP TABLE selected_parent_ids_ebp(parent_id BIGINT) m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY(parent_id)&#39;);
<a name="l01828"></a>01828         
<a name="l01829"></a>01829         SELECT MADLIB_SCHEMA.__format
<a name="l01830"></a>01830             (
<a name="l01831"></a>01831                 &#39;INSERT INTO selected_parent_ids_ebp 
<a name="l01832"></a>01832                 SELECT s.parent_id as parent_id 
<a name="l01833"></a>01833                 FROM  
<a name="l01834"></a>01834                 (
<a name="l01835"></a>01835                     Select parent_id, sum(ebp_coeff) as ebp_coeff 
<a name="l01836"></a>01836                     FROM 
<a name="l01837"></a>01837                     (
<a name="l01838"></a>01838                         Select parent_id, ebp_coeff 
<a name="l01839"></a>01839                         FROM % 
<a name="l01840"></a>01840                         WHERE parent_id NOT IN 
<a name="l01841"></a>01841                             (
<a name="l01842"></a>01842                             Select parent_id  FROM % WHERE jump IS NOT NULL
<a name="l01843"></a>01843                             )  and <span class="keywordtype">id</span> &lt;&gt; 1
<a name="l01844"></a>01844                     ) m 
<a name="l01845"></a>01845                     GROUP BY m.parent_id
<a name="l01846"></a>01846                  ) s 
<a name="l01847"></a>01847                  LEFT JOIN  % p 
<a name="l01848"></a>01848                     ON p.<span class="keywordtype">id</span> = s.parent_id 
<a name="l01849"></a>01849                  WHERE  p.ebp_coeff &lt; s.ebp_coeff;&#39;,
<a name="l01850"></a>01850                  tree_table_name,
<a name="l01851"></a>01851                  tree_table_name,
<a name="l01852"></a>01852                  tree_table_name
<a name="l01853"></a>01853             )
<a name="l01854"></a>01854             INTO curstmt;
<a name="l01855"></a>01855          
<a name="l01856"></a>01856         EXECUTE curstmt;
<a name="l01857"></a>01857                  
<a name="l01858"></a>01858         EXECUTE &#39;SELECT parent_id FROM selected_parent_ids_ebp LIMIT 1;&#39; INTO num_parent_ids;
<a name="l01859"></a>01859 
<a name="l01860"></a>01860         IF (num_parent_ids IS NULL)  THEN
<a name="l01861"></a>01861             EXIT;
<a name="l01862"></a>01862         END IF;
<a name="l01863"></a>01863         
<a name="l01864"></a>01864         SELECT MADLIB_SCHEMA.__format
<a name="l01865"></a>01865             (
<a name="l01866"></a>01866                 &#39;DELETE FROM % 
<a name="l01867"></a>01867                 WHERE parent_id IN 
<a name="l01868"></a>01868                     (SELECT parent_id FROM selected_parent_ids_ebp)&#39;,
<a name="l01869"></a>01869                 tree_table_name
<a name="l01870"></a>01870             )
<a name="l01871"></a>01871             INTO curstmt;
<a name="l01872"></a>01872             
<a name="l01873"></a>01873         EXECUTE curstmt;
<a name="l01874"></a>01874         
<a name="l01875"></a>01875         SELECT MADLIB_SCHEMA.__format
<a name="l01876"></a>01876             (
<a name="l01877"></a>01877                 &#39;UPDATE %  
<a name="l01878"></a>01878                 SET jump = NULL 
<a name="l01879"></a>01879                 WHERE <span class="keywordtype">id</span> IN 
<a name="l01880"></a>01880                     (SELECT parent_id FROM selected_parent_ids_ebp)&#39;,
<a name="l01881"></a>01881                 tree_table_name
<a name="l01882"></a>01882             )
<a name="l01883"></a>01883             INTO curstmt;
<a name="l01884"></a>01884             
<a name="l01885"></a>01885         EXECUTE curstmt;
<a name="l01886"></a>01886         
<a name="l01887"></a>01887     END LOOP;
<a name="l01888"></a>01888 END
<a name="l01889"></a>01889 $$ LANGUAGE PLPGSQL;
<a name="l01890"></a>01890 
<a name="l01891"></a>01891 <span class="comment">/*</span>
<a name="l01892"></a>01892 <span class="comment"> * Generate the final trained tree</span>
<a name="l01893"></a>01893 <span class="comment"> *  </span>
<a name="l01894"></a>01894 <span class="comment"> * Parameters:</span>
<a name="l01895"></a>01895 <span class="comment"> *      result_tree_table_name:    The name of the table containing the tree.</span>
<a name="l01896"></a>01896 <span class="comment"> */</span>
<a name="l01897"></a>01897 DROP FUNCTION IF EXISTS  MADLIB_SCHEMA.__generate_final_tree(TEXT);
<a name="l01898"></a>01898 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__generate_final_tree
<a name="l01899"></a>01899     (
<a name="l01900"></a>01900     result_tree_table_name TEXT
<a name="l01901"></a>01901     ) 
<a name="l01902"></a>01902 RETURNS <span class="keywordtype">void</span> AS $$
<a name="l01903"></a>01903 DECLARE
<a name="l01904"></a>01904     tree_size INTEGER;
<a name="l01905"></a>01905 BEGIN
<a name="l01906"></a>01906     TRUNCATE auxiliary_tree_info;
<a name="l01907"></a>01907     TRUNCATE auxiliary_tree_info2;
<a name="l01908"></a>01908     
<a name="l01909"></a>01909     EXECUTE &#39;DELETE FROM tree_internal WHERE COALESCE(cat_size,0) = 0&#39;;
<a name="l01910"></a>01910     
<a name="l01911"></a>01911     EXECUTE &#39;SELECT count(*) FROM tree_internal&#39; INTO tree_size;
<a name="l01912"></a>01912     EXECUTE &#39;INSERT INTO auxiliary_tree_info (<span class="keywordtype">id</span>, parent_id, new_id) SELECT <span class="keywordtype">id</span>, 
<a name="l01913"></a>01913             MAX(parent_id), (&#39;||tree_size||&#39;+1) - count(1) 
<a name="l01914"></a>01914             OVER(ORDER BY <span class="keywordtype">id</span> DESC ROWS UNBOUNDED PRECEDING) FROM tree_internal GROUP BY <span class="keywordtype">id</span>&#39;;
<a name="l01915"></a>01915             
<a name="l01916"></a>01916     EXECUTE &#39;INSERT INTO auxiliary_tree_info2 (<span class="keywordtype">id</span>, parent_id, new_id) 
<a name="l01917"></a>01917             SELECT  g2.<span class="keywordtype">id</span>,g.new_id,g2.new_id FROM auxiliary_tree_info g, 
<a name="l01918"></a>01918             auxiliary_tree_info g2  WHERE g.<span class="keywordtype">id</span> = g2.parent_id&#39;;
<a name="l01919"></a>01919     
<a name="l01920"></a>01920     TRUNCATE auxiliary_tree_info;
<a name="l01921"></a>01921     EXECUTE &#39;TRUNCATE &#39;||result_tree_table_name||&#39;;&#39;;
<a name="l01922"></a>01922     
<a name="l01923"></a>01923     EXECUTE &#39;INSERT INTO &#39;|| result_tree_table_name||&#39; SELECT n.new_id, 
<a name="l01924"></a>01924             g.tree_location, g.feature, g.probability, 
<a name="l01925"></a>01925             g.ebp_coeff,g.maxclass, g.split_gain, g.live, g.cat_size, 
<a name="l01926"></a>01926             n.parent_id, g.jump, g.is_feature_cont, g.split_value 
<a name="l01927"></a>01927             FROM tree_internal g, auxiliary_tree_info2 n WHERE n.<span class="keywordtype">id</span> = g.<span class="keywordtype">id</span>&#39;;
<a name="l01928"></a>01928             
<a name="l01929"></a>01929     EXECUTE &#39;INSERT INTO &#39;||result_tree_table_name
<a name="l01930"></a>01930             ||&#39; SELECT * FROM tree_internal WHERE <span class="keywordtype">id</span> = 1&#39;;
<a name="l01931"></a>01931             
<a name="l01932"></a>01932     TRUNCATE tree_internal;
<a name="l01933"></a>01933     EXECUTE &#39;INSERT INTO tree_internal (<span class="keywordtype">id</span>, jump) SELECT parent_id, 
<a name="l01934"></a>01934             MADLIB_SCHEMA.__jump_aggr(tree_location[array_upper(tree_location,1)], <span class="keywordtype">id</span>) FROM &#39;
<a name="l01935"></a>01935             ||result_tree_table_name||&#39; GROUP BY parent_id&#39;;
<a name="l01936"></a>01936             
<a name="l01937"></a>01937     TRUNCATE auxiliary_tree_info2;
<a name="l01938"></a>01938     EXECUTE &#39;UPDATE &#39;||result_tree_table_name||&#39; k 
<a name="l01939"></a>01939             SET jump = g.jump FROM tree_internal g WHERE g.<span class="keywordtype">id</span> = k.<span class="keywordtype">id</span>&#39;;
<a name="l01940"></a>01940     TRUNCATE tree_internal;
<a name="l01941"></a>01941 END
<a name="l01942"></a>01942 $$ LANGUAGE PLPGSQL;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944 <span class="comment">/*</span>
<a name="l01945"></a>01945 <span class="comment"> * This function trains a tree </span>
<a name="l01946"></a>01946 <span class="comment"> *  </span>
<a name="l01947"></a>01947 <span class="comment"> * Parameters:</span>
<a name="l01948"></a>01948 <span class="comment"> *      split_criterion:            This parameter specifies which split criterion </span>
<a name="l01949"></a>01949 <span class="comment"> *                                  should be used for tree construction and pruning. The  </span>
<a name="l01950"></a>01950 <span class="comment"> *                                  valid values are infogain, gainratio, and gini.</span>
<a name="l01951"></a>01951 <span class="comment"> *      training_table_name:        Name of the table/view with the source data</span>
<a name="l01952"></a>01952 <span class="comment"> *      result_tree_table_name:     The name of the table where the resulting DT will be stored.</span>
<a name="l01953"></a>01953 <span class="comment"> *      validation_table_name:      The validation table used for pruning tree. </span>
<a name="l01954"></a>01954 <span class="comment"> *      id_col_name:                Name of the column containing id of each point.</span>
<a name="l01955"></a>01955 <span class="comment"> *      class_col_name:             Name of the column containing correct class of each point.</span>
<a name="l01956"></a>01956 <span class="comment"> *      confidence_level:           A statistical confidence interval of the resubstitution error.</span>
<a name="l01957"></a>01957 <span class="comment"> *      max_num_iter:               Max number of branches to follow (e.g. 2000)</span>
<a name="l01958"></a>01958 <span class="comment"> *      max_tree_depth:             Maximum decision tree depth </span>
<a name="l01959"></a>01959 <span class="comment"> *      min_percent_mode:           Specifies the minimum number of cases required in a child node</span>
<a name="l01960"></a>01960 <span class="comment"> *      min_percent_split:          specifies the minimum number of cases required in a node  </span>
<a name="l01961"></a>01961 <span class="comment"> *                                  in order for a further split to be possible.</span>
<a name="l01962"></a>01962 <span class="comment"> *      verbosity:                  If True (or 1) will run in verbose mode</span>
<a name="l01963"></a>01963 <span class="comment"> *</span>
<a name="l01964"></a>01964 <span class="comment"> * Return:</span>
<a name="l01965"></a>01965 <span class="comment"> *      One summary result for training tree. Please refer to the structure of</span>
<a name="l01966"></a>01966 <span class="comment"> *      &#39;MADLIB_SCHEMA.c45_train_result&#39; for detailed definition.</span>
<a name="l01967"></a>01967 <span class="comment"> */</span>
<a name="l01968"></a>01968 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__train_tree
<a name="l01969"></a>01969     (
<a name="l01970"></a>01970     split_criterion         TEXT,
<a name="l01971"></a>01971     training_table_name     TEXT, 
<a name="l01972"></a>01972     training_table_meta     TEXT,
<a name="l01973"></a>01973     result_tree_table_name  TEXT,
<a name="l01974"></a>01974     validation_table_name   TEXT,
<a name="l01975"></a>01975     id_col_name             TEXT, 
<a name="l01976"></a>01976     class_col_name          TEXT, 
<a name="l01977"></a>01977     confidence_level        FLOAT, 
<a name="l01978"></a>01978     max_num_iter            INT, 
<a name="l01979"></a>01979     max_tree_depth          INT,
<a name="l01980"></a>01980     min_percent_mode        FLOAT,
<a name="l01981"></a>01981     min_percent_split       FLOAT,
<a name="l01982"></a>01982     verbosity               INT
<a name="l01983"></a>01983     ) 
<a name="l01984"></a>01984 RETURNS MADLIB_SCHEMA.c45_train_result AS $$
<a name="l01985"></a>01985 DECLARE
<a name="l01986"></a>01986     feature_dimension           INT;
<a name="l01987"></a>01987     num_live_nodes              INT;
<a name="l01988"></a>01988     assigned_nid                INT;
<a name="l01989"></a>01989     location                    INT[];
<a name="l01990"></a>01990     temp_location               INT[];
<a name="l01991"></a>01991     num_classes                 INT;
<a name="l01992"></a>01992     max_iter                    INT := max_num_iter;
<a name="l01993"></a>01993     max_depth                   INT := max_tree_depth;
<a name="l01994"></a>01994     answer                      MADLIB_SCHEMA.__best_split_result;
<a name="l01995"></a>01995     location_size               INT;
<a name="l01996"></a>01996     max_id                      INT;
<a name="l01997"></a>01997     exec_begin                  TIMESTAMP;
<a name="l01998"></a>01998     find_best_time              INTERVAL;
<a name="l01999"></a>01999     begin_find_best_time        TIMESTAMP;
<a name="l02000"></a>02000     data_transfer_time          INTERVAL;
<a name="l02001"></a>02001     begin_data_transfer         TIMESTAMP;
<a name="l02002"></a>02002     total_size                  FLOAT;
<a name="l02003"></a>02003     sp_crit                     INT := 1;
<a name="l02004"></a>02004     curstmt                     TEXT := &#39;&#39;;
<a name="l02005"></a>02005     grow_tree                   INT := 0;
<a name="l02006"></a>02006     ret                         MADLIB_SCHEMA.c45_train_result;
<a name="l02007"></a>02007     selection_visit             BOOLEAN[];
<a name="l02008"></a>02008     selection_index             INT := 1;
<a name="l02009"></a>02009     select_max_id               INT := 0;
<a name="l02010"></a>02010     best_time_cmp               BOOLEAN := &#39;f&#39;;
<a name="l02011"></a>02011 BEGIN   
<a name="l02012"></a>02012     exec_begin = clock_timestamp();
<a name="l02013"></a>02013     find_best_time = exec_begin - exec_begin;
<a name="l02014"></a>02014 
<a name="l02015"></a>02015     ret.split_criterion = split_criterion;   
<a name="l02016"></a>02016                   
<a name="l02017"></a>02017     IF(split_criterion = &#39;infogain&#39;) THEN
<a name="l02018"></a>02018         sp_crit = 1;
<a name="l02019"></a>02019     ELSIF (split_criterion = &#39;gainratio&#39;) THEN
<a name="l02020"></a>02020         sp_crit = 2;
<a name="l02021"></a>02021     ELSIF (split_criterion = &#39;gini&#39;) THEN
<a name="l02022"></a>02022         sp_crit = 3;
<a name="l02023"></a>02023     ELSE
<a name="l02024"></a>02024         RAISE EXCEPTION &#39;%&#39;, &#39;Invalid split criterion!&#39;;
<a name="l02025"></a>02025     END IF;
<a name="l02026"></a>02026 
<a name="l02027"></a>02027     PERFORM MADLIB_SCHEMA.__create_tree_tables(result_tree_table_name);
<a name="l02028"></a>02028     
<a name="l02029"></a>02029     EXECUTE &#39;SELECT count(*) FROM &#39;|| training_table_name ||&#39;;&#39; INTO total_size;
<a name="l02030"></a>02030     
<a name="l02031"></a>02031     IF(verbosity &gt; 0) THEN
<a name="l02032"></a>02032         RAISE INFO &#39;INPUT TABLE SIZE: %&#39;, total_size;
<a name="l02033"></a>02033     END IF;
<a name="l02034"></a>02034     
<a name="l02035"></a>02035     ret.training_set_size = total_size;
<a name="l02036"></a>02036     
<a name="l02037"></a>02037     EXECUTE &#39;DROP TABLE IF EXISTS instance_selection CASCADE&#39;;
<a name="l02038"></a>02038     EXECUTE &#39;CREATE TEMP TABLE instance_selection AS SELECT <span class="keywordtype">id</span>, 1::BIGINT as assigned_nid FROM &#39; || 
<a name="l02039"></a>02039          training_table_name || 
<a name="l02040"></a>02040             &#39; m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (<span class="keywordtype">id</span>)&#39;)&#39;;
<a name="l02041"></a>02041     
<a name="l02042"></a>02042     EXECUTE &#39;CREATE INDEX instance_selection_selection_index ON instance_selection (assigned_nid)&#39;;
<a name="l02043"></a>02043 
<a name="l02044"></a>02044 
<a name="l02045"></a>02045     feature_dimension = MADLIB_SCHEMA.__num_of_feature(training_table_meta);
<a name="l02046"></a>02046 
<a name="l02047"></a>02047     num_classes = MADLIB_SCHEMA.__num_of_class(training_table_meta); 
<a name="l02048"></a>02048     
<a name="l02049"></a>02049     IF(verbosity &gt; 0) THEN
<a name="l02050"></a>02050         RAISE INFO &#39;NUMBER OF CLASSES IN THE TRAINING SET %&#39;, num_classes;
<a name="l02051"></a>02051     END IF;
<a name="l02052"></a>02052     
<a name="l02053"></a>02053     IF(num_classes &lt; 2 OR num_classes &gt; 8000000)THEN
<a name="l02054"></a>02054         RAISE EXCEPTION &#39;The number of classes must be in range 2 to 8,000,000!&#39;;
<a name="l02055"></a>02055     END IF;
<a name="l02056"></a>02056     
<a name="l02057"></a>02057     EXECUTE &#39;INSERT INTO tree_internal (tree_location, feature, probability, maxclass, 
<a name="l02058"></a>02058         split_gain, live, cat_size, parent_id) 
<a name="l02059"></a>02059         VALUES(ARRAY[0], 0, 1, 1, 1, 1, 0, 0);&#39;;
<a name="l02060"></a>02060                
<a name="l02061"></a>02061     location_size = 0;
<a name="l02062"></a>02062     
<a name="l02063"></a>02063     begin_data_transfer = clock_timestamp();
<a name="l02064"></a>02064     
<a name="l02065"></a>02065     LOOP
<a name="l02066"></a>02066         EXECUTE &#39;SELECT COUNT(<span class="keywordtype">id</span>) FROM tree_internal WHERE live = 1&#39; INTO num_live_nodes;
<a name="l02067"></a>02067         
<a name="l02068"></a>02068         IF ((max_depth &lt; 0) OR (num_live_nodes &lt; 1)) THEN
<a name="l02069"></a>02069             IF(verbosity &gt; 0) THEN
<a name="l02070"></a>02070                 RAISE INFO &#39;EXIT: LIMIT tree depth: % OR LIMIT iteration: % OR NO NODES LEFT&#39;, max_depth, max_iter;
<a name="l02071"></a>02071             END IF;
<a name="l02072"></a>02072             
<a name="l02073"></a>02073             EXIT;
<a name="l02074"></a>02074         END IF;
<a name="l02075"></a>02075         
<a name="l02076"></a>02076         max_depth = max_depth - 1;
<a name="l02077"></a>02077         IF(verbosity &gt; 0) THEN
<a name="l02078"></a>02078             RAISE INFO &#39;current level: %&#39;, max_tree_depth - max_depth;
<a name="l02079"></a>02079         END IF;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081         EXECUTE &#39;SELECT <span class="keywordtype">id</span> FROM tree_internal WHERE live = 1 ORDER BY <span class="keywordtype">id</span> LIMIT 1;&#39; INTO assigned_nid;
<a name="l02082"></a>02082         EXECUTE &#39;SELECT <span class="keywordtype">id</span> FROM tree_internal WHERE live = 1 ORDER BY <span class="keywordtype">id</span> DESC LIMIT 1;&#39; INTO max_id;
<a name="l02083"></a>02083         
<a name="l02084"></a>02084         FOR selection_index IN 1..(max_id - assigned_nid + 1) LOOP
<a name="l02085"></a>02085             selection_visit[selection_index] = &#39;f&#39;;
<a name="l02086"></a>02086         END LOOP;
<a name="l02087"></a>02087         
<a name="l02088"></a>02088         select_max_id = max_id;
<a name="l02089"></a>02089         
<a name="l02090"></a>02090 m4_changequote(`&gt;&gt;&gt;&#39;, `&lt;&lt;&lt;&#39;)
<a name="l02091"></a>02091 m4_ifdef(&gt;&gt;&gt;__GREENPLUM__&lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l02092"></a>02092         PERFORM MADLIB_SCHEMA.__generate_training_instance_greenplum
<a name="l02093"></a>02093             (
<a name="l02094"></a>02094             training_table_name,
<a name="l02095"></a>02095             training_table_meta,
<a name="l02096"></a>02096             &#39;training_instance&#39;,
<a name="l02097"></a>02097             &#39;instance_selection&#39;,
<a name="l02098"></a>02098             verbosity
<a name="l02099"></a>02099             );
<a name="l02100"></a>02100 &lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l02101"></a>02101         PERFORM MADLIB_SCHEMA.__generate_training_instance_postgres
<a name="l02102"></a>02102             (
<a name="l02103"></a>02103             training_table_name,
<a name="l02104"></a>02104             training_table_meta,
<a name="l02105"></a>02105             &#39;training_instance&#39;,
<a name="l02106"></a>02106             &#39;instance_selection&#39;,
<a name="l02107"></a>02107             verbosity
<a name="l02108"></a>02108             );
<a name="l02109"></a>02109 &lt;&lt;&lt;)
<a name="l02110"></a>02110 m4_changequote(&gt;&gt;&gt;`&lt;&lt;&lt;, &gt;&gt;&gt;&#39;&lt;&lt;&lt;)
<a name="l02111"></a>02111         
<a name="l02112"></a>02112         begin_find_best_time = clock_timestamp();
<a name="l02113"></a>02113         
<a name="l02114"></a>02114         best_time_cmp = &#39;t&#39;;
<a name="l02115"></a>02115         
<a name="l02116"></a>02116         FOR answer IN 
<a name="l02117"></a>02117                     (
<a name="l02118"></a>02118                     SELECT * FROM MADLIB_SCHEMA.__find_best_split
<a name="l02119"></a>02119                         (
<a name="l02120"></a>02120                         feature_dimension, 
<a name="l02121"></a>02121                         num_classes, 
<a name="l02122"></a>02122                         assigned_nid, 
<a name="l02123"></a>02123                         max_id - assigned_nid + 1, 
<a name="l02124"></a>02124                         &#39;training_instance&#39;,
<a name="l02125"></a>02125                         confidence_level,
<a name="l02126"></a>02126                         training_table_meta,
<a name="l02127"></a>02127                         sp_crit,
<a name="l02128"></a>02128                         grow_tree
<a name="l02129"></a>02129                         )
<a name="l02130"></a>02130                     ) 
<a name="l02131"></a>02131                     LOOP
<a name="l02132"></a>02132             IF (0 = answer.feature) THEN
<a name="l02133"></a>02133                 CONTINUE;
<a name="l02134"></a>02134             END IF;
<a name="l02135"></a>02135             
<a name="l02136"></a>02136             -- mark this node <span class="keywordtype">id</span> was visited
<a name="l02137"></a>02137             selection_visit[answer.node_id - assigned_nid + 1] = &#39;t&#39;;
<a name="l02138"></a>02138             
<a name="l02139"></a>02139             IF (answer.is_cont_feature) THEN
<a name="l02140"></a>02140                 IF(verbosity &gt; 0) THEN
<a name="l02141"></a>02141                     RAISE INFO &#39;selected feature is continuous&#39;;
<a name="l02142"></a>02142                     RAISE INFO &#39;answer:%&#39;, answer;  
<a name="l02143"></a>02143                 END IF;
<a name="l02144"></a>02144                 
<a name="l02145"></a>02145                 EXECUTE &#39;UPDATE tree_internal 
<a name="l02146"></a>02146                         SET feature = &#39;||answer.feature||&#39;,
<a name="l02147"></a>02147                             probability = &#39;|| answer.probability||&#39;,
<a name="l02148"></a>02148                             maxclass = &#39;||answer.maxclass||&#39;,
<a name="l02149"></a>02149                             split_gain = &#39;||answer.infogain||&#39;,
<a name="l02150"></a>02150                             ebp_coeff = &#39;||answer.ebp_coeff||&#39;,
<a name="l02151"></a>02151                             cat_size = &#39;||answer.total_size|| E&#39;,
<a name="l02152"></a>02152                             live = 0,
<a name="l02153"></a>02153                             is_feature_cont = &#39;&#39;t&#39;&#39;,
<a name="l02154"></a>02154                             split_value = &#39;|| answer.split_value ||
<a name="l02155"></a>02155                          &#39; WHERE <span class="keywordtype">id</span> =&#39; || answer.node_id || &#39;;&#39;;
<a name="l02156"></a>02156             ELSE
<a name="l02157"></a>02157                 IF (verbosity &gt; 0) THEN
<a name="l02158"></a>02158                     RAISE INFO &#39;selected feature is discrete&#39;;
<a name="l02159"></a>02159                     RAISE INFO &#39;answer:%&#39;, answer;       
<a name="l02160"></a>02160                 END IF;   
<a name="l02161"></a>02161                   
<a name="l02162"></a>02162                 EXECUTE &#39;UPDATE tree_internal 
<a name="l02163"></a>02163                         SET feature = &#39;||answer.feature||&#39;,
<a name="l02164"></a>02164                             probability = &#39;|| answer.probability||&#39;,
<a name="l02165"></a>02165                             maxclass = &#39;||answer.maxclass||&#39;,
<a name="l02166"></a>02166                             split_gain = &#39;||answer.infogain||&#39;,
<a name="l02167"></a>02167                             ebp_coeff = &#39;||answer.ebp_coeff||&#39;,
<a name="l02168"></a>02168                             cat_size = &#39;||answer.total_size|| E&#39;,
<a name="l02169"></a>02169                             live = 0,
<a name="l02170"></a>02170                             is_feature_cont = &#39;&#39;f&#39;&#39;,
<a name="l02171"></a>02171                             split_value = null
<a name="l02172"></a>02172                         WHERE <span class="keywordtype">id</span> =&#39; || answer.node_id || &#39;;&#39;;
<a name="l02173"></a>02173             END IF;   
<a name="l02174"></a>02174             
<a name="l02175"></a>02175             -- no need to grow tree with the attribute 
<a name="l02176"></a>02176             -- if comes up the maximum number;
<a name="l02177"></a>02177             -- if its percent is lower than minimum split value
<a name="l02178"></a>02178             IF (answer.node_id &gt;= max_num_iter) THEN
<a name="l02179"></a>02179                 max_iter = 0;
<a name="l02180"></a>02180                 CONTINUE;
<a name="l02181"></a>02181             END IF;
<a name="l02182"></a>02182 
<a name="l02183"></a>02183             IF (answer.total_size &lt; min_percent_split * total_size) THEN
<a name="l02184"></a>02184                 CONTINUE;
<a name="l02185"></a>02185             END IF;
<a name="l02186"></a>02186                         
<a name="l02187"></a>02187             -- grow the tree
<a name="l02188"></a>02188             EXECUTE &#39;SELECT gt.tree_location FROM tree_internal gt 
<a name="l02189"></a>02189                     WHERE gt.<span class="keywordtype">id</span> =&#39; || answer.node_id ||&#39;;&#39; 
<a name="l02190"></a>02190                     INTO location;
<a name="l02191"></a>02191             
<a name="l02192"></a>02192             --here insert live determination function 
<a name="l02193"></a>02193             IF (answer.live &gt; 0 and answer.is_cont_feature = &#39;f&#39;) THEN 
<a name="l02194"></a>02194                 IF(verbosity &gt; 0) THEN
<a name="l02195"></a>02195                     RAISE INFO &#39;determine live for discrete&#39;;
<a name="l02196"></a>02196                 END IF;  
<a name="l02197"></a>02197                             
<a name="l02198"></a>02198                 FOR i IN 1..answer.distinct_features LOOP
<a name="l02199"></a>02199                     temp_location = location;
<a name="l02200"></a>02200                     temp_location[array_upper(temp_location,1)+1] = i;
<a name="l02201"></a>02201                     EXECUTE &#39;INSERT INTO tree_internal (tree_location, feature, probability, 
<a name="l02202"></a>02202                         maxclass, split_gain, live, parent_id) 
<a name="l02203"></a>02203                         VALUES(ARRAY[&#39;                          || 
<a name="l02204"></a>02204                             array_to_string(temp_location, &#39;,&#39;) ||
<a name="l02205"></a>02205                             &#39;], 0, 1, 1, 1, 1, &#39;                || 
<a name="l02206"></a>02206                             answer.node_id                      ||
<a name="l02207"></a>02207                           &#39;);&#39;;
<a name="l02208"></a>02208                 END LOOP;
<a name="l02209"></a>02209                 
<a name="l02210"></a>02210                 SELECT MADLIB_SCHEMA.__format
<a name="l02211"></a>02211                     (
<a name="l02212"></a>02212                     &#39;UPDATE instance_selection s
<a name="l02213"></a>02213                     SET assigned_nid = % + %
<a name="l02214"></a>02214                     FROM % t
<a name="l02215"></a>02215                     WHERE assigned_nid = % and t.<span class="keywordtype">id</span> = s.<span class="keywordtype">id</span>;&#39;,
<a name="l02216"></a>02216                     ARRAY[
<a name="l02217"></a>02217                         MADLIB_SCHEMA.__get_feature_name(answer.feature,training_table_meta),
<a name="l02218"></a>02218                         MADLIB_SCHEMA.__to_char(select_max_id),
<a name="l02219"></a>02219                         training_table_name,
<a name="l02220"></a>02220                         MADLIB_SCHEMA.__to_char(answer.node_id)
<a name="l02221"></a>02221                     ]
<a name="l02222"></a>02222                     ) 
<a name="l02223"></a>02223                     INTO curstmt;
<a name="l02224"></a>02224                     
<a name="l02225"></a>02225                 EXECUTE curstmt;
<a name="l02226"></a>02226                 
<a name="l02227"></a>02227                 select_max_id = select_max_id + answer.distinct_features;
<a name="l02228"></a>02228                 
<a name="l02229"></a>02229             ELSIF (answer.live &gt; 0 and answer.is_cont_feature = &#39;t&#39;) THEN
<a name="l02230"></a>02230                 IF(verbosity &gt; 0) THEN
<a name="l02231"></a>02231                     RAISE INFO &#39;determine live for continuous&#39;;
<a name="l02232"></a>02232                 END IF;  
<a name="l02233"></a>02233                 FOR i IN 1..2 LOOP
<a name="l02234"></a>02234                     temp_location = location;
<a name="l02235"></a>02235                     temp_location[array_upper(temp_location,1)+1] = i;
<a name="l02236"></a>02236                     EXECUTE &#39;INSERT INTO tree_internal (tree_location, feature, probability, 
<a name="l02237"></a>02237                         maxclass, split_gain, live, parent_id) 
<a name="l02238"></a>02238                         VALUES(ARRAY[&#39;                          ||
<a name="l02239"></a>02239                             array_to_string(temp_location, &#39;,&#39;) ||
<a name="l02240"></a>02240                             &#39;], 0, 1, 1, 1, 1, &#39;                || 
<a name="l02241"></a>02241                             answer.node_id                      ||
<a name="l02242"></a>02242                          &#39;);&#39;;
<a name="l02243"></a>02243                     
<a name="l02244"></a>02244                 END LOOP;
<a name="l02245"></a>02245 
<a name="l02246"></a>02246                 SELECT MADLIB_SCHEMA.__format
<a name="l02247"></a>02247                     (
<a name="l02248"></a>02248                     &#39;UPDATE instance_selection s
<a name="l02249"></a>02249                     SET assigned_nid = (
<a name="l02250"></a>02250                                     CASE WHEN (% &lt; %) THEN
<a name="l02251"></a>02251                                         2
<a name="l02252"></a>02252                                     ELSE
<a name="l02253"></a>02253                                         1
<a name="l02254"></a>02254                                     END
<a name="l02255"></a>02255                                     )
<a name="l02256"></a>02256                                     + %
<a name="l02257"></a>02257                     FROM % t
<a name="l02258"></a>02258                     WHERE assigned_nid = % and t.<span class="keywordtype">id</span> = s.<span class="keywordtype">id</span>;&#39;,
<a name="l02259"></a>02259                     ARRAY[
<a name="l02260"></a>02260                         MADLIB_SCHEMA.__to_char(answer.split_value),
<a name="l02261"></a>02261                         MADLIB_SCHEMA.__get_feature_name(answer.feature, training_table_meta),
<a name="l02262"></a>02262                         MADLIB_SCHEMA.__to_char(select_max_id),
<a name="l02263"></a>02263                         training_table_name,
<a name="l02264"></a>02264                         MADLIB_SCHEMA.__to_char(answer.node_id)
<a name="l02265"></a>02265                     ]
<a name="l02266"></a>02266                     ) 
<a name="l02267"></a>02267                     INTO curstmt;
<a name="l02268"></a>02268                     
<a name="l02269"></a>02269                 EXECUTE curstmt;
<a name="l02270"></a>02270                                
<a name="l02271"></a>02271                 select_max_id = select_max_id + 2;
<a name="l02272"></a>02272             ELSE
<a name="l02273"></a>02273                 -- answer.live = 0
<a name="l02274"></a>02274                 -- process the min_percent_mode
<a name="l02275"></a>02275                 IF (total_size * min_percent_mode &gt; answer.total_size) THEN
<a name="l02276"></a>02276                     --RAISE INFO &#39;%&#39;, &#39;min_percent_mode&#39;;
<a name="l02277"></a>02277                     EXECUTE &#39;DELETE FROM tree_internal WHERE <span class="keywordtype">id</span> = &#39; || answer.node_id || &#39;;&#39;;
<a name="l02278"></a>02278                 END IF;
<a name="l02279"></a><a class="code" href="decision__tree_8sql__in.html#ab267187db09b3244e92ff03d32ec7706">02279</a>             END IF;                      
<a name="l02280"></a>02280         END LOOP;
<a name="l02281"></a>02281         
<a name="l02282"></a>02282         -- Remove the nodes which contains no data
<a name="l02283"></a>02283         FOR selection_index IN assigned_nid..max_id  LOOP
<a name="l02284"></a>02284             IF (NOT selection_visit[selection_index - assigned_nid + 1]) THEN
<a name="l02285"></a>02285                 IF (verbosity &gt; 0) THEN
<a name="l02286"></a>02286                     RAISE NOTICE &#39;%, %&#39;, &#39;unneccesary node!&#39;, selection_index;
<a name="l02287"></a>02287                 END IF;
<a name="l02288"></a>02288                 
<a name="l02289"></a>02289                 EXECUTE &#39;DELETE FROM tree_internal WHERE <span class="keywordtype">id</span> = &#39;|| selection_index ||&#39;;&#39;;
<a name="l02290"></a>02290             END IF;
<a name="l02291"></a>02291         END LOOP;
<a name="l02292"></a>02292                
<a name="l02293"></a>02293         IF(verbosity &gt; 0) THEN
<a name="l02294"></a>02294             RAISE INFO &#39;computation time in this level:%&#39;,(clock_timestamp() - begin_find_best_time);
<a name="l02295"></a>02295         END IF;
<a name="l02296"></a>02296         IF (best_time_cmp) THEN
<a name="l02297"></a>02297             find_best_time = find_best_time + (clock_timestamp() - begin_find_best_time);
<a name="l02298"></a>02298             best_time_cmp = &#39;f&#39;;
<a name="l02299"></a>02299         END IF;
<a name="l02300"></a>02300     END LOOP;
<a name="l02301"></a>02301     
<a name="l02302"></a>02302     data_transfer_time =  (clock_timestamp() - begin_data_transfer) - find_best_time;
<a name="l02303"></a>02303     
<a name="l02304"></a>02304     PERFORM MADLIB_SCHEMA.__generate_final_tree( result_tree_table_name );
<a name="l02305"></a>02305     
<a name="l02306"></a>02306     IF (confidence_level &lt; 100.0) THEN
<a name="l02307"></a>02307        EXECUTE &#39;SELECT MADLIB_SCHEMA.__ebp_prune_tree(&#39; || quote_literal(result_tree_table_name) || &#39;);&#39;;
<a name="l02308"></a>02308     END IF;
<a name="l02309"></a>02309     
<a name="l02310"></a>02310     IF (validation_table_name IS NOT NULL) THEN
<a name="l02311"></a>02311        PERFORM MADLIB_SCHEMA.__rep_prune_tree(result_tree_table_name, validation_table_name , num_classes);
<a name="l02312"></a>02312     END IF;
<a name="l02313"></a>02313     
<a name="l02314"></a>02314     EXECUTE &#39;select count(*) from &#39;||result_tree_table_name||&#39;;&#39; into ret.tree_nodes;
<a name="l02315"></a>02315     EXECUTE &#39;select max(array_upper(tree_location,1)) from &#39;||result_tree_table_name||&#39;;&#39; into ret.tree_depth;
<a name="l02316"></a>02316     IF(verbosity &gt; 0) THEN
<a name="l02317"></a>02317         <span class="comment">/*</span>
<a name="l02318"></a>02318 <span class="comment">         * We measure the time with the dataset of kddcup1999, which can be found at</span>
<a name="l02319"></a>02319 <span class="comment">         * http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html.</span>
<a name="l02320"></a>02320 <span class="comment">         * We test the training with that dataset on two machines with two X5570@2.93GHz CPUs</span>
<a name="l02321"></a>02321 <span class="comment">         * and 48GB memory running x86_64 GNU/Linux and GPDB 4.2. </span>
<a name="l02322"></a>02322 <span class="comment">         * </span>
<a name="l02323"></a>02323 <span class="comment">         * We use three different configurations, 4 segments, 8 segments and 16 segments.</span>
<a name="l02324"></a>02324 <span class="comment">         * The 16 segments configuration spans over two machines connected with 10GB Ethernet HUB</span>
<a name="l02325"></a>02325 <span class="comment">         * The test results are as follows:</span>
<a name="l02326"></a>02326 <span class="comment">         * </span>
<a name="l02327"></a>02327 <span class="comment">         * 4 segments results:</span>
<a name="l02328"></a>02328 <span class="comment">         * Data conversion:            5 minutes 43 seconds</span>
<a name="l02329"></a>02329 <span class="comment">         * Find best time:             30 minutes 10 seconds</span>
<a name="l02330"></a>02330 <span class="comment">         * olap query/windows func:    43 minutes 5 seconds</span>
<a name="l02331"></a>02331 <span class="comment">         * Total train:                79 minutes 06 seconds</span>
<a name="l02332"></a>02332 <span class="comment">         * </span>
<a name="l02333"></a>02333 <span class="comment">         * 8 segments results:</span>
<a name="l02334"></a>02334 <span class="comment">         * Data conversion:            4 minutes 10 seconds</span>
<a name="l02335"></a>02335 <span class="comment">         * Find best time:             19 minutes 14 seconds</span>
<a name="l02336"></a>02336 <span class="comment">         * olap query/windows func:    29 minutes 58 seconds</span>
<a name="l02337"></a>02337 <span class="comment">         * Total train:                53 minutes 40 seconds</span>
<a name="l02338"></a>02338 <span class="comment">    </span>
<a name="l02339"></a>02339 <span class="comment">         * 16 segments results:</span>
<a name="l02340"></a>02340 <span class="comment">         * Data conversion:            2 minutes 24 seconds</span>
<a name="l02341"></a>02341 <span class="comment">         * Find best time:             10 minutes 29 seconds</span>
<a name="l02342"></a>02342 <span class="comment">         * olap query/windows func:    16 minutes 17 seconds</span>
<a name="l02343"></a>02343 <span class="comment">         * Total train:                29 minutes 13 seconds</span>
<a name="l02344"></a>02344 <span class="comment">         */</span>
<a name="l02345"></a>02345 
<a name="l02346"></a>02346         RAISE INFO &#39;total of find best time: %&#39;, find_best_time;
<a name="l02347"></a>02347         RAISE INFO &#39;total of olap query/windows func time: %&#39;, data_transfer_time;
<a name="l02348"></a>02348         RAISE INFO &#39;total of pruning time: %&#39;, 
<a name="l02349"></a>02349             (clock_timestamp() - begin_data_transfer -find_best_time - data_transfer_time);
<a name="l02350"></a>02350         RAISE INFO &#39;total of __train_tree time: %&#39;, clock_timestamp() - exec_begin;        
<a name="l02351"></a>02351     END IF;
<a name="l02352"></a>02352     
<a name="l02353"></a>02353     ret.cost_time = clock_timestamp() - exec_begin;
<a name="l02354"></a>02354     RETURN ret;
<a name="l02355"></a>02355 END
<a name="l02356"></a>02356 $$ LANGUAGE PLPGSQL;
<a name="l02357"></a>02357 <span class="comment"></span>
<a name="l02358"></a>02358 <span class="comment">/**</span>
<a name="l02359"></a>02359 <span class="comment"> * @brief This is the long form API of training tree with all specified parameters.</span>
<a name="l02360"></a>02360 <span class="comment"> *</span>
<a name="l02361"></a>02361 <span class="comment"> * @param split_criterion_name      This parameter specifies which split criterion </span>
<a name="l02362"></a>02362 <span class="comment"> *                                  should be used for tree construction and pruning. </span>
<a name="l02363"></a>02363 <span class="comment"> *                                  The valid values are infogain, gainratio, or gini.</span>
<a name="l02364"></a>02364 <span class="comment"> * @param training_table_name       Name of the table/view with the source data</span>
<a name="l02365"></a>02365 <span class="comment"> * @param result_tree_table_name    The name of the table where the resulting DT will be stored.</span>
<a name="l02366"></a>02366 <span class="comment"> * @param validation_table_name     The validation table used for pruning tree. </span>
<a name="l02367"></a>02367 <span class="comment"> * @param continuous_feature_names  A comma-separated list of the names of the features whose values are continuous. </span>
<a name="l02368"></a>02368 <span class="comment"> * @param feature_col_names         A comma-separated list of names of the table columns, each of which defines a feature.</span>
<a name="l02369"></a>02369 <span class="comment"> * @param id_col_name               Name of the column containing id of each point.</span>
<a name="l02370"></a>02370 <span class="comment"> * @param class_col_name            Name of the column containing correct class of each point.</span>
<a name="l02371"></a>02371 <span class="comment"> * @param confidence_level          A statistical confidence interval of the resubstitution error.</span>
<a name="l02372"></a>02372 <span class="comment"> * @param how2handle_missing_value The way to handle missing value. The valid value is &#39;explicit&#39; or &#39;ignore&#39;.</span>
<a name="l02373"></a>02373 <span class="comment"> * @param max_num_iter              Max number of branches to follow (e.g. 2000)</span>
<a name="l02374"></a>02374 <span class="comment"> * @param max_tree_depth            Maximum decision tree depth </span>
<a name="l02375"></a>02375 <span class="comment"> * @param min_percent_mode          Specifies the minimum number of cases required in a child node</span>
<a name="l02376"></a>02376 <span class="comment"> * @param min_percent_split         specifies the minimum number of cases required in a node in order for </span>
<a name="l02377"></a>02377 <span class="comment"> *                                  a further split to be possible.</span>
<a name="l02378"></a>02378 <span class="comment"> * @param verbosity                 If True (or 1) will run in verbose mode</span>
<a name="l02379"></a>02379 <span class="comment"> *</span>
<a name="l02380"></a>02380 <span class="comment"> * @return</span>
<a name="l02381"></a>02381 <span class="comment"> * - &lt;tt&gt;training_set_size&lt;/tt&gt; - Number of items in the training set</span>
<a name="l02382"></a>02382 <span class="comment"> * - &lt;tt&gt;tree_nodes&lt;/tt&gt; - Number of nodes in the resulting tree</span>
<a name="l02383"></a>02383 <span class="comment"> * - &lt;tt&gt;cost_time&lt;/tt&gt; - Time spent training the tree</span>
<a name="l02384"></a>02384 <span class="comment"> * - &lt;tt&gt;split_criterion&lt;/tt&gt; - Split criterion used to build the tree.</span>
<a name="l02385"></a>02385 <span class="comment"> *</span>
<a name="l02386"></a>02386 <span class="comment"> * This will also create the output table with name specified via &#39;result_tree_table_name&#39;.</span>
<a name="l02387"></a>02387 <span class="comment"> * The result table can be queried directly or displayed using c45_display.</span>
<a name="l02388"></a>02388 <span class="comment"> */</span>
<a name="l02389"></a>02389 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ab267187db09b3244e92ff03d32ec7706" title="This is the long form API of training tree with all specified parameters.">c45_train</a>
<a name="l02390"></a>02390     (
<a name="l02391"></a>02391     split_criterion             TEXT,
<a name="l02392"></a>02392     training_table_name         TEXT, 
<a name="l02393"></a>02393     result_tree_table_name      TEXT,
<a name="l02394"></a>02394     validation_table_name       TEXT, 
<a name="l02395"></a>02395     continuous_feature_names    TEXT, 
<a name="l02396"></a>02396     feature_col_names           TEXT, 
<a name="l02397"></a>02397     id_col_name                 TEXT, 
<a name="l02398"></a>02398     class_col_name              TEXT, 
<a name="l02399"></a>02399     confidence_level            FLOAT,
<a name="l02400"></a>02400     how2handle_missing_value    TEXT, 
<a name="l02401"></a>02401     max_num_iter                INT, 
<a name="l02402"></a>02402     max_tree_depth              INT, 
<a name="l02403"></a>02403     min_percent_mode            FLOAT,
<a name="l02404"></a>02404     min_percent_split           FLOAT, 
<a name="l02405"></a>02405     verbosity                   INT
<a name="l02406"></a>02406     ) 
<a name="l02407"></a>02407 RETURNS MADLIB_SCHEMA.c45_train_result AS $$
<a name="l02408"></a>02408 DECLARE
<a name="l02409"></a>02409     cont_feature_col_names          TEXT[];
<a name="l02410"></a>02410     feature_name_array              TEXT[];
<a name="l02411"></a>02411     exec_begin                      TIMESTAMP;
<a name="l02412"></a>02412     tree_schema_name                TEXT;
<a name="l02413"></a>02413     tree_table_name                 TEXT;
<a name="l02414"></a>02414     training_encoded_table_name     TEXT;
<a name="l02415"></a>02415     training_metatable_name         TEXT;
<a name="l02416"></a>02416     h2hmv_routine_id                INT := 1;  
<a name="l02417"></a>02417     ret                             MADLIB_SCHEMA.c45_train_result;
<a name="l02418"></a>02418 BEGIN   
<a name="l02419"></a>02419     exec_begin = clock_timestamp();
<a name="l02420"></a>02420     
<a name="l02421"></a>02421     IF (verbosity &lt; 1) THEN
<a name="l02422"></a>02422         -- get rid of the messages whose severity level is lower than &#39;WARNING&#39;
<a name="l02423"></a>02423         SET client_min_messages = WARNING;
<a name="l02424"></a>02424     END IF;
<a name="l02425"></a>02425     
<a name="l02426"></a>02426     PERFORM MADLIB_SCHEMA.__assert
<a name="l02427"></a>02427         (
<a name="l02428"></a>02428             (split_criterion IS NOT NULL)   AND
<a name="l02429"></a>02429             (
<a name="l02430"></a>02430              split_criterion = &#39;infogain&#39;   OR 
<a name="l02431"></a>02431              split_criterion = &#39;gainratio&#39;  OR 
<a name="l02432"></a>02432              split_criterion = &#39;gini&#39;
<a name="l02433"></a>02433             ),
<a name="l02434"></a>02434             &#39;split_criterion must be infogain, gainratio or gini&#39;
<a name="l02435"></a>02435         );
<a name="l02436"></a>02436             
<a name="l02437"></a>02437     PERFORM MADLIB_SCHEMA.__assert
<a name="l02438"></a>02438         (
<a name="l02439"></a>02439                 id_col_name IS NOT NULL AND
<a name="l02440"></a>02440                 class_col_name IS NOT NULL AND
<a name="l02441"></a>02441                 length(btrim(id_col_name, &#39; &#39;)) &gt; 0 AND
<a name="l02442"></a>02442                 length(btrim(class_col_name, &#39; &#39;)) &gt; 0,
<a name="l02443"></a>02443                 &#39;invalid <span class="keywordtype">id</span> column name or class column name&#39;
<a name="l02444"></a>02444             );
<a name="l02445"></a>02445                         
<a name="l02446"></a>02446     PERFORM MADLIB_SCHEMA.__assert
<a name="l02447"></a>02447         (
<a name="l02448"></a>02448             training_table_name IS NOT NULL AND
<a name="l02449"></a>02449             MADLIB_SCHEMA.__table_exists
<a name="l02450"></a>02450                 (
<a name="l02451"></a>02451                     MADLIB_SCHEMA.__get_schema_name(training_table_name),
<a name="l02452"></a>02452                     MADLIB_SCHEMA.__strip_schema_name(training_table_name)
<a name="l02453"></a>02453                 ),
<a name="l02454"></a>02454             &#39;the specified training table&#39; || coalesce(&#39;&lt;&#39; || training_table_name || &#39;&gt; does not exist&#39;, &#39; is NULL&#39;)
<a name="l02455"></a>02455         );
<a name="l02456"></a>02456 
<a name="l02457"></a>02457     PERFORM MADLIB_SCHEMA.__assert
<a name="l02458"></a>02458         (
<a name="l02459"></a>02459             MADLIB_SCHEMA.__column_exists
<a name="l02460"></a>02460                 (
<a name="l02461"></a>02461                     MADLIB_SCHEMA.__get_schema_name(training_table_name),
<a name="l02462"></a>02462                     MADLIB_SCHEMA.__strip_schema_name(training_table_name),
<a name="l02463"></a>02463                     lower(btrim(id_col_name, &#39; &#39;))
<a name="l02464"></a>02464                 ),
<a name="l02465"></a>02465             &#39;the specified training table&lt;&#39; || training_table_name || &#39;&gt; does not have column &#39;&#39;&#39; || id_col_name || &#39;&#39;&#39;&#39;
<a name="l02466"></a>02466         );
<a name="l02467"></a>02467 
<a name="l02468"></a>02468     PERFORM MADLIB_SCHEMA.__assert
<a name="l02469"></a>02469         (
<a name="l02470"></a>02470             MADLIB_SCHEMA.__column_exists
<a name="l02471"></a>02471                 (
<a name="l02472"></a>02472                     MADLIB_SCHEMA.__get_schema_name(training_table_name),
<a name="l02473"></a>02473                     MADLIB_SCHEMA.__strip_schema_name(training_table_name),
<a name="l02474"></a>02474                     lower(btrim(class_col_name, &#39; &#39;))
<a name="l02475"></a>02475                 ),
<a name="l02476"></a>02476             &#39;the specified training table&lt;&#39; || training_table_name || &#39;&gt; does not have column &#39;&#39;&#39; || class_col_name || &#39;&#39;&#39;&#39;
<a name="l02477"></a>02477         );
<a name="l02478"></a>02478 
<a name="l02479"></a>02479     PERFORM MADLIB_SCHEMA.__assert
<a name="l02480"></a>02480         (
<a name="l02481"></a>02481             validation_table_name IS NULL OR
<a name="l02482"></a>02482             MADLIB_SCHEMA.__table_exists
<a name="l02483"></a>02483                 (
<a name="l02484"></a>02484                     MADLIB_SCHEMA.__get_schema_name(validation_table_name),
<a name="l02485"></a>02485                     MADLIB_SCHEMA.__strip_schema_name(validation_table_name)
<a name="l02486"></a>02486                 ),
<a name="l02487"></a>02487              &#39;the specified validation table&lt;&#39; || validation_table_name || &#39;&gt; does not exist&#39;
<a name="l02488"></a>02488         );
<a name="l02489"></a>02489 
<a name="l02490"></a>02490     PERFORM MADLIB_SCHEMA.__assert
<a name="l02491"></a>02491             (
<a name="l02492"></a>02492                 (result_tree_table_name IS NOT NULL) AND
<a name="l02493"></a>02493                 (
<a name="l02494"></a>02494                  NOT MADLIB_SCHEMA.__table_exists
<a name="l02495"></a>02495                     (
<a name="l02496"></a>02496                         MADLIB_SCHEMA.__get_schema_name(result_tree_table_name),
<a name="l02497"></a>02497                         MADLIB_SCHEMA.__strip_schema_name(result_tree_table_name)
<a name="l02498"></a>02498                     )
<a name="l02499"></a>02499                 ),
<a name="l02500"></a>02500                 &#39;the specified result tree table&#39; || coalesce(&#39;&lt;&#39; || result_tree_table_name || &#39;&gt; exists&#39;, &#39; is NULL&#39;)
<a name="l02501"></a>02501             );   
<a name="l02502"></a>02502 
<a name="l02503"></a>02503     -- the maximum length of an identifier 63
<a name="l02504"></a>02504     -- encoding table name convension:  &lt;tree table schema name&gt;_&lt;tree table name&gt;_ed
<a name="l02505"></a>02505     -- data info table name convension: &lt;tree table schema name&gt;_&lt;tree table name&gt;_di
<a name="l02506"></a>02506     -- the KV table name convension:    &lt;tree table schema name&gt;_&lt;tree table name&gt;_&lt;<span class="preprocessor">####&gt;</span>
<a name="l02507"></a>02507 <span class="preprocessor"></span>    -- therefore, the maximum length of <span class="stringliteral">&#39;&lt;tree table schema name&gt;_&lt;tree table name&gt;&#39;</span> is 58
<a name="l02508"></a>02508     PERFORM MADLIB_SCHEMA.__assert
<a name="l02509"></a>02509         (
<a name="l02510"></a>02510             length(
<a name="l02511"></a>02511                 MADLIB_SCHEMA.__get_schema_name(result_tree_table_name) || 
<a name="l02512"></a>02512                 <span class="charliteral">&#39;_&#39;</span>                                                     || 
<a name="l02513"></a>02513                 MADLIB_SCHEMA.__strip_schema_name(result_tree_table_name)) &lt;= 58,
<a name="l02514"></a>02514             <span class="stringliteral">&#39;the maximum length of &#39;</span><span class="stringliteral">&#39;&lt;tree table schema name&gt;_&lt;tree table name&gt;&#39;</span><span class="stringliteral">&#39; is 58&#39;</span>
<a name="l02515"></a>02515         );
<a name="l02516"></a>02516                     
<a name="l02517"></a>02517     PERFORM MADLIB_SCHEMA.__assert
<a name="l02518"></a>02518             (
<a name="l02519"></a>02519                 (confidence_level IS NOT NULL)      AND 
<a name="l02520"></a>02520                 float8ge(confidence_level, 0.001)   AND 
<a name="l02521"></a>02521                 float8le(confidence_level, 100), 
<a name="l02522"></a>02522                 <span class="stringliteral">&#39;confidence level value must be in range from 0.001 to 100&#39;</span>
<a name="l02523"></a>02523             );
<a name="l02524"></a>02524             
<a name="l02525"></a>02525     PERFORM MADLIB_SCHEMA.__assert
<a name="l02526"></a>02526             (
<a name="l02527"></a>02527                 how2handle_missing_value = <span class="stringliteral">&#39;ignore&#39;</span> OR how2handle_missing_value = <span class="stringliteral">&#39;explicit&#39;</span>,
<a name="l02528"></a>02528                 <span class="stringliteral">&#39;how2handle_missing_value must be ignore or explicit!&#39;</span>
<a name="l02529"></a>02529             );    
<a name="l02530"></a>02530 
<a name="l02531"></a>02531     PERFORM MADLIB_SCHEMA.__assert
<a name="l02532"></a>02532             (
<a name="l02533"></a>02533                 max_num_iter        IS NOT NULL AND
<a name="l02534"></a>02534                 max_tree_depth      IS NOT NULL AND
<a name="l02535"></a>02535                 max_num_iter        &gt; 0         AND
<a name="l02536"></a>02536                 max_tree_depth      &gt; 0,
<a name="l02537"></a>02537                 <span class="stringliteral">&#39;invalid parameters value for max_num_iter, max_tree_depth&#39;</span>
<a name="l02538"></a>02538             );
<a name="l02539"></a>02539 
<a name="l02540"></a>02540     PERFORM MADLIB_SCHEMA.__assert
<a name="l02541"></a>02541             (
<a name="l02542"></a>02542                 min_percent_mode IS NOT NULL    AND
<a name="l02543"></a>02543                 float8ge(min_percent_mode, 0)   AND
<a name="l02544"></a>02544                 float8le(min_percent_mode, 1),
<a name="l02545"></a>02545                 <span class="stringliteral">&#39;min_percent_mode value must be in range from 0 to 1&#39;</span>
<a name="l02546"></a>02546             );
<a name="l02547"></a>02547 
<a name="l02548"></a>02548     PERFORM MADLIB_SCHEMA.__assert
<a name="l02549"></a>02549             (
<a name="l02550"></a>02550                 min_percent_split IS NOT NULL   AND                
<a name="l02551"></a>02551                 float8ge(min_percent_split, 0)  AND
<a name="l02552"></a>02552                 float8le(min_percent_split, 1),                
<a name="l02553"></a>02553                 <span class="stringliteral">&#39;min_percent_split value must be in range from 0 to 1&#39;</span>
<a name="l02554"></a>02554             );
<a name="l02555"></a>02555             
<a name="l02556"></a>02556     PERFORM MADLIB_SCHEMA.__assert
<a name="l02557"></a>02557             (
<a name="l02558"></a>02558                 verbosity IS NOT NULL,                
<a name="l02559"></a>02559                 <span class="stringliteral">&#39;verbosity must be non-null&#39;</span>
<a name="l02560"></a>02560             );
<a name="l02561"></a>02561                                                    
<a name="l02562"></a>02562     IF (how2handle_missing_value = <span class="stringliteral">&#39;ignore&#39;</span>) THEN
<a name="l02563"></a>02563         h2hmv_routine_id = 1;
<a name="l02564"></a>02564     ELSE
<a name="l02565"></a>02565         h2hmv_routine_id = 2;
<a name="l02566"></a>02566     END IF;
<a name="l02567"></a>02567     
<a name="l02568"></a>02568     PERFORM MADLIB_SCHEMA.__insert_into_traininginfo
<a name="l02569"></a>02569                 (
<a name="l02570"></a>02570                 result_tree_table_name,
<a name="l02571"></a>02571                 training_table_name,
<a name="l02572"></a><a class="code" href="decision__tree_8sql__in.html#a18b30ff1a063e7cd16274bf7ab2a71dc">02572</a>                 null,
<a name="l02573"></a>02573                 null,
<a name="l02574"></a>02574                 validation_table_name,
<a name="l02575"></a>02575                 how2handle_missing_value,
<a name="l02576"></a>02576                 split_criterion
<a name="l02577"></a>02577                 );
<a name="l02578"></a>02578 
<a name="l02579"></a>02579     cont_feature_col_names = MADLIB_SCHEMA.__csvstr_to_array(continuous_feature_names);
<a name="l02580"></a>02580     
<a name="l02581"></a>02581     IF ( verbosity &gt; 0 ) THEN
<a name="l02582"></a>02582         RAISE INFO &#39;continuous features:%&#39;, cont_feature_col_names;
<a name="l02583"></a>02583     END IF;
<a name="l02584"></a>02584     
<a name="l02585"></a>02585     tree_table_name = MADLIB_SCHEMA.__strip_schema_name(result_tree_table_name);
<a name="l02586"></a>02586     tree_schema_name = MADLIB_SCHEMA.__get_schema_name(result_tree_table_name);
<a name="l02587"></a>02587     
<a name="l02588"></a>02588     IF(verbosity &gt; 0) THEN
<a name="l02589"></a>02589         RAISE INFO &#39;table name after strip schema:%&#39;,tree_table_name;
<a name="l02590"></a>02590     END IF;
<a name="l02591"></a>02591     
<a name="l02592"></a>02592     training_encoded_table_name = &#39;MADLIB_SCHEMA.&#39; || tree_schema_name || &#39;_&#39; ||tree_table_name || &#39;_ed&#39;;
<a name="l02593"></a>02593     training_metatable_name =  tree_schema_name || &#39;_&#39; || tree_table_name || &#39;_di&#39;;
<a name="l02594"></a>02594  
<a name="l02595"></a>02595     IF(verbosity &gt; 0) THEN
<a name="l02596"></a>02596         RAISE INFO &#39;Before encoding: %&#39;, clock_timestamp() - exec_begin;
<a name="l02597"></a>02597     END IF; 
<a name="l02598"></a>02598         
<a name="l02599"></a>02599     PERFORM MADLIB_SCHEMA.__encode_tabular_table
<a name="l02600"></a>02600         (
<a name="l02601"></a>02601         training_table_name,
<a name="l02602"></a>02602         lower(id_col_name),
<a name="l02603"></a>02603         MADLIB_SCHEMA.__csvstr_to_array(feature_col_names),
<a name="l02604"></a>02604         lower(class_col_name),
<a name="l02605"></a>02605         cont_feature_col_names,
<a name="l02606"></a>02606         training_encoded_table_name,
<a name="l02607"></a>02607         training_metatable_name,
<a name="l02608"></a>02608         h2hmv_routine_id,
<a name="l02609"></a>02609         verbosity &gt; 0
<a name="l02610"></a>02610         );
<a name="l02611"></a>02611     
<a name="l02612"></a>02612     PERFORM  MADLIB_SCHEMA.__set_encode_and_metatable_name
<a name="l02613"></a>02613                 ( 
<a name="l02614"></a>02614                 result_tree_table_name, 
<a name="l02615"></a>02615                 training_metatable_name,
<a name="l02616"></a>02616                 training_encoded_table_name
<a name="l02617"></a>02617                 );
<a name="l02618"></a>02618                 
<a name="l02619"></a>02619     IF(verbosity &gt; 0) THEN
<a name="l02620"></a>02620             RAISE INFO &#39;After encoding: %&#39;, clock_timestamp() - exec_begin;
<a name="l02621"></a>02621             RAISE INFO &#39;successfully encode the input table :%&#39;,training_encoded_table_name;
<a name="l02622"></a>02622     END IF;    
<a name="l02623"></a>02623 
<a name="l02624"></a>02624     ret = MADLIB_SCHEMA.__train_tree
<a name="l02625"></a>02625             (
<a name="l02626"></a>02626             split_criterion ,
<a name="l02627"></a>02627             training_encoded_table_name ,
<a name="l02628"></a>02628             training_metatable_name,
<a name="l02629"></a>02629             result_tree_table_name ,
<a name="l02630"></a>02630             validation_table_name , 
<a name="l02631"></a>02631             &#39;<span class="keywordtype">id</span>&#39;, 
<a name="l02632"></a>02632             &#39;class&#39;, 
<a name="l02633"></a>02633             confidence_level,
<a name="l02634"></a>02634             max_num_iter , 
<a name="l02635"></a>02635             max_tree_depth , 
<a name="l02636"></a>02636             min_percent_mode ,
<a name="l02637"></a><a class="code" href="decision__tree_8sql__in.html#a6c039416b94686b915e2a4c1133a5d44">02637</a>             min_percent_split,
<a name="l02638"></a>02638             verbosity
<a name="l02639"></a>02639             );
<a name="l02640"></a>02640 
<a name="l02641"></a>02641     IF ( verbosity &gt; 0 ) THEN
<a name="l02642"></a>02642             RAISE INFO &#39;Training Total Time: %&#39;, clock_timestamp() - exec_begin;
<a name="l02643"></a>02643     END IF;
<a name="l02644"></a>02644     
<a name="l02645"></a>02645     ret.cost_time = clock_timestamp() - exec_begin;
<a name="l02646"></a>02646     RETURN ret;
<a name="l02647"></a>02647 END
<a name="l02648"></a>02648 $$ LANGUAGE PLPGSQL;
<a name="l02649"></a>02649 <span class="comment"></span>
<a name="l02650"></a>02650 <span class="comment">/**</span>
<a name="l02651"></a>02651 <span class="comment"> * @brief C45 train algorithm in short form.</span>
<a name="l02652"></a>02652 <span class="comment"> *</span>
<a name="l02653"></a>02653 <span class="comment"> * @param split_criterion_name This parameter specifies which split criterion</span>
<a name="l02654"></a>02654 <span class="comment"> * should be used for tree construction and pruning.</span>
<a name="l02655"></a>02655 <span class="comment"> * The valid values are infogain, gainratio, or gini.</span>
<a name="l02656"></a>02656 <span class="comment"> * @param training_table_name Name of the table/view with the source data</span>
<a name="l02657"></a>02657 <span class="comment"> * @param result_tree_table_name The name of the table where the resulting DT will be stored.</span>
<a name="l02658"></a>02658 <span class="comment"> *</span>
<a name="l02659"></a>02659 <span class="comment"> * @return</span>
<a name="l02660"></a>02660 <span class="comment"> * - &lt;tt&gt;training_set_size&lt;/tt&gt; - Number of items in the training set</span>
<a name="l02661"></a>02661 <span class="comment"> * - &lt;tt&gt;tree_nodes&lt;/tt&gt; - Number of nodes in the resulting tree</span>
<a name="l02662"></a>02662 <span class="comment"> * - &lt;tt&gt;cost_time&lt;/tt&gt; - Time spent training the tree</span>
<a name="l02663"></a>02663 <span class="comment"> * - &lt;tt&gt;split_criterion&lt;/tt&gt; - Split criterion used to build the tree.</span>
<a name="l02664"></a>02664 <span class="comment"> *</span>
<a name="l02665"></a>02665 <span class="comment"> * This will also create the output table with name specified via &#39;result_tree_table_name&#39;.</span>
<a name="l02666"></a>02666 <span class="comment"> * The result table can be queried directly or displayed using c45_display.</span>
<a name="l02667"></a>02667 <span class="comment"> *</span>
<a name="l02668"></a>02668 <span class="comment"> * @note  </span>
<a name="l02669"></a>02669 <span class="comment"> * This calls the long form of C45 with the following default parameters:</span>
<a name="l02670"></a>02670 <span class="comment"> * - validation_table_name := NULL</span>
<a name="l02671"></a>02671 <span class="comment"> * - continuous_feature_names := NULL</span>
<a name="l02672"></a>02672 <span class="comment"> * - id_column_name := &#39;id&#39;</span>
<a name="l02673"></a>02673 <span class="comment"> * - class_column_name := &#39;class&#39;</span>
<a name="l02674"></a>02674 <span class="comment"> * - confidence_level = 25</span>
<a name="l02675"></a>02675 <span class="comment"> * - how2handle_missing_value = &#39;explicit&#39;</span>
<a name="l02676"></a>02676 <span class="comment"> * - max_num_iter := 2000</span>
<a name="l02677"></a>02677 <span class="comment"> * - max_tree_deapth := 10</span>
<a name="l02678"></a>02678 <span class="comment"> * - min_percent_mode := 0.001</span>
<a name="l02679"></a>02679 <span class="comment"> * - min_percent_split := 0.01</span>
<a name="l02680"></a>02680 <span class="comment"> * - verbosity := false</span>
<a name="l02681"></a>02681 <span class="comment"> */</span>
<a name="l02682"></a>02682 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ab267187db09b3244e92ff03d32ec7706" title="This is the long form API of training tree with all specified parameters.">c45_train</a>
<a name="l02683"></a>02683     (
<a name="l02684"></a>02684     split_criterion         TEXT,
<a name="l02685"></a>02685     training_table_name     TEXT, 
<a name="l02686"></a>02686     result_tree_table_name  TEXT
<a name="l02687"></a>02687     ) 
<a name="l02688"></a>02688 RETURNS MADLIB_SCHEMA.c45_train_result AS $$
<a name="l02689"></a>02689 DECLARE
<a name="l02690"></a><a class="code" href="decision__tree_8sql__in.html#ac71787c47795b3b0b133cdbd37438242">02690</a>     ret MADLIB_SCHEMA.c45_train_result;
<a name="l02691"></a>02691 BEGIN   
<a name="l02692"></a>02692     ret = MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ab267187db09b3244e92ff03d32ec7706" title="This is the long form API of training tree with all specified parameters.">c45_train</a>(
<a name="l02693"></a>02693         split_criterion,
<a name="l02694"></a>02694         training_table_name, 
<a name="l02695"></a>02695         result_tree_table_name,
<a name="l02696"></a>02696         null,
<a name="l02697"></a>02697         null,       
<a name="l02698"></a>02698         null,
<a name="l02699"></a>02699         &#39;<span class="keywordtype">id</span>&#39;,
<a name="l02700"></a>02700         &#39;class&#39;,
<a name="l02701"></a>02701         25,
<a name="l02702"></a>02702         &#39;explicit&#39;,
<a name="l02703"></a>02703         2000,
<a name="l02704"></a>02704         10,
<a name="l02705"></a>02705         0.001,
<a name="l02706"></a>02706         0.01,
<a name="l02707"></a>02707         0           
<a name="l02708"></a>02708     );
<a name="l02709"></a>02709     
<a name="l02710"></a>02710     RETURN ret;
<a name="l02711"></a>02711 END
<a name="l02712"></a>02712 $$ LANGUAGE PLPGSQL;
<a name="l02713"></a>02713 <span class="comment"></span>
<a name="l02714"></a>02714 <span class="comment">/**</span>
<a name="l02715"></a>02715 <span class="comment"> * @brief C45 train algorithm in short form.</span>
<a name="l02716"></a>02716 <span class="comment"> *</span>
<a name="l02717"></a>02717 <span class="comment"> * @param split_criterion_name This parameter specifies which split criterion</span>
<a name="l02718"></a>02718 <span class="comment"> * should be used for tree construction and pruning.</span>
<a name="l02719"></a>02719 <span class="comment"> * The valid values are infogain, gainratio, or gini.</span>
<a name="l02720"></a>02720 <span class="comment"> * @param training_table_name Name of the table/view with the source data</span>
<a name="l02721"></a>02721 <span class="comment"> * @param result_tree_table_name The name of the table where the resulting DT will be stored.</span>
<a name="l02722"></a>02722 <span class="comment"> * @param validation_table_name The validation table used for pruning tree.</span>
<a name="l02723"></a>02723 <span class="comment"> * @param continuous_feature_names A comma-separated list of the names of the features whose values are continuous.</span>
<a name="l02724"></a>02724 <span class="comment"> * @param feature_col_names A comma-separated list of names of the table columns, each of which defines a feature.</span>
<a name="l02725"></a>02725 <span class="comment"> * @param id_col_name Name of the column containing id of each point.</span>
<a name="l02726"></a>02726 <span class="comment"> * @param class_col_name Name of the column containing correct class of each point.</span>
<a name="l02727"></a>02727 <span class="comment"> * @param confidence_level A statistical confidence interval of the resubstitution error.</span>
<a name="l02728"></a>02728 <span class="comment"> * @param how2handle_missing_value The way to handle missing value. The valid value is &#39;explicit&#39; or &#39;ignore&#39;.</span>
<a name="l02729"></a>02729 <span class="comment"> *</span>
<a name="l02730"></a>02730 <span class="comment"> * @return</span>
<a name="l02731"></a>02731 <span class="comment"> * - &lt;tt&gt;training_set_size&lt;/tt&gt; - Number of items in the training set</span>
<a name="l02732"></a>02732 <span class="comment"> * - &lt;tt&gt;tree_nodes&lt;/tt&gt; - Number of nodes in the resulting tree</span>
<a name="l02733"></a>02733 <span class="comment"> * - &lt;tt&gt;cost_time&lt;/tt&gt; - Time spent training the tree</span>
<a name="l02734"></a>02734 <span class="comment"> * - &lt;tt&gt;split_criterion&lt;/tt&gt; - Split criterion used to build the tree.</span>
<a name="l02735"></a>02735 <span class="comment"> *</span>
<a name="l02736"></a>02736 <span class="comment"> * This will also create the output table with name specified via &#39;result_tree_table_name&#39;.</span>
<a name="l02737"></a>02737 <span class="comment"> * The result table can be queried directly or displayed using c45_display.</span>
<a name="l02738"></a>02738 <span class="comment"> *</span>
<a name="l02739"></a>02739 <span class="comment"> * @note     </span>
<a name="l02740"></a>02740 <span class="comment"> * This calls the long form of C45 with the following default parameters:</span>
<a name="l02741"></a>02741 <span class="comment"> * - max_num_iter := 2000</span>
<a name="l02742"></a>02742 <span class="comment"> * - max_tree_deapth := 10</span>
<a name="l02743"></a>02743 <span class="comment"> * - min_percent_mode := 0.001</span>
<a name="l02744"></a>02744 <span class="comment"> * - min_percent_split := 0.01</span>
<a name="l02745"></a>02745 <span class="comment"> * - verbosity := false</span>
<a name="l02746"></a>02746 <span class="comment"> */</span>
<a name="l02747"></a>02747 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ab267187db09b3244e92ff03d32ec7706" title="This is the long form API of training tree with all specified parameters.">c45_train</a>
<a name="l02748"></a>02748     (
<a name="l02749"></a>02749     split_criterion             TEXT,
<a name="l02750"></a>02750     training_table_name         TEXT, 
<a name="l02751"></a>02751     result_tree_table_name      TEXT,
<a name="l02752"></a>02752     validation_table_name       TEXT, 
<a name="l02753"></a>02753     continuous_feature_names    TEXT, 
<a name="l02754"></a>02754     feature_col_names           TEXT, 
<a name="l02755"></a>02755     id_col_name                 TEXT, 
<a name="l02756"></a>02756     class_col_name              TEXT, 
<a name="l02757"></a>02757     confidence_level            FLOAT,
<a name="l02758"></a>02758     how2handle_missing_value    TEXT
<a name="l02759"></a>02759     ) 
<a name="l02760"></a>02760 RETURNS MADLIB_SCHEMA.c45_train_result AS $$
<a name="l02761"></a>02761 DECLARE
<a name="l02762"></a>02762     ret MADLIB_SCHEMA.c45_train_result;
<a name="l02763"></a>02763 BEGIN   
<a name="l02764"></a>02764     ret = MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ab267187db09b3244e92ff03d32ec7706" title="This is the long form API of training tree with all specified parameters.">c45_train</a>
<a name="l02765"></a>02765             (
<a name="l02766"></a>02766             split_criterion,
<a name="l02767"></a>02767             training_table_name, 
<a name="l02768"></a>02768             result_tree_table_name,
<a name="l02769"></a>02769             validation_table_name , 
<a name="l02770"></a>02770             continuous_feature_names , 
<a name="l02771"></a>02771             feature_col_names , 
<a name="l02772"></a>02772             id_col_name , 
<a name="l02773"></a>02773             class_col_name , 
<a name="l02774"></a>02774             confidence_level,
<a name="l02775"></a>02775             how2handle_missing_value,
<a name="l02776"></a>02776             2000,
<a name="l02777"></a>02777             10,
<a name="l02778"></a>02778             0.001,
<a name="l02779"></a>02779             0.01,
<a name="l02780"></a>02780             0           
<a name="l02781"></a>02781             );
<a name="l02782"></a>02782     RETURN ret;
<a name="l02783"></a>02783 END
<a name="l02784"></a>02784 $$ LANGUAGE PLPGSQL;
<a name="l02785"></a>02785 <span class="comment"></span>
<a name="l02786"></a>02786 <span class="comment">/**</span>
<a name="l02787"></a>02787 <span class="comment"> * @brief Display the trained decision tree model with rules.</span>
<a name="l02788"></a>02788 <span class="comment"> *</span>
<a name="l02789"></a>02789 <span class="comment"> * @param   tree_table_name     Name of the table containing the tree&#39;s information</span>
<a name="l02790"></a>02790 <span class="comment"> * @param   verbosity           If &gt;= 1 will run in verbose mode</span>
<a name="l02791"></a>02791 <span class="comment"> *</span>
<a name="l02792"></a>02792 <span class="comment"> * @return  The rule representation text for a decision tree.</span>
<a name="l02793"></a>02793 <span class="comment"> *</span>
<a name="l02794"></a>02794 <span class="comment"> */</span>
<a name="l02795"></a>02795 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac71787c47795b3b0b133cdbd37438242" title="Display the trained decision tree model with rules.">c45_genrule</a>
<a name="l02796"></a>02796     (
<a name="l02797"></a>02797     tree_table_name TEXT,
<a name="l02798"></a>02798     verbosity       INT
<a name="l02799"></a>02799     );
<a name="l02800"></a>02800 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac71787c47795b3b0b133cdbd37438242" title="Display the trained decision tree model with rules.">c45_genrule</a>
<a name="l02801"></a>02801     (
<a name="l02802"></a>02802     tree_table_name TEXT,
<a name="l02803"></a>02803     verbosity       INT
<a name="l02804"></a>02804     ) 
<a name="l02805"></a>02805 RETURNS SETOF TEXT AS $$
<a name="l02806"></a>02806 DECLARE
<a name="l02807"></a>02807     metatable_name          TEXT;
<a name="l02808"></a>02808     classtable_name         TEXT;
<a name="l02809"></a>02809     class_column_name       TEXT;
<a name="l02810"></a>02810     rec                     RECORD;
<a name="l02811"></a>02811     fvalue_stmt             TEXT;
<a name="l02812"></a>02812     feature_rule            TEXT;
<a name="l02813"></a>02813     curstmt                 TEXT;
<a name="l02814"></a>02814     union_stmt              TEXT := NULL;
<a name="l02815"></a>02815     exec_begin              TIMESTAMP;
<a name="l02816"></a>02816     exec_leaves_rule        INTERVAL;
<a name="l02817"></a>02817     exec_internode_rule     INTERVAL;
<a name="l02818"></a>02818     exec_union              INTERVAL;    
<a name="l02819"></a>02819 BEGIN
<a name="l02820"></a>02820 
<a name="l02821"></a>02821     IF (verbosity &lt; 1) THEN
<a name="l02822"></a>02822         -- get rid of the messages whose severity level is lower than &#39;WARNING&#39;
<a name="l02823"></a>02823         SET client_min_messages = WARNING;
<a name="l02824"></a>02824     END IF;
<a name="l02825"></a>02825     
<a name="l02826"></a>02826     PERFORM MADLIB_SCHEMA.__assert
<a name="l02827"></a>02827             (
<a name="l02828"></a>02828                 (tree_table_name IS NOT NULL) AND
<a name="l02829"></a>02829                 (
<a name="l02830"></a>02830                  MADLIB_SCHEMA.__table_exists
<a name="l02831"></a>02831                     (
<a name="l02832"></a>02832                         MADLIB_SCHEMA.__get_schema_name(tree_table_name),
<a name="l02833"></a>02833                         MADLIB_SCHEMA.__strip_schema_name(tree_table_name)
<a name="l02834"></a>02834                     )
<a name="l02835"></a>02835                 ),
<a name="l02836"></a>02836                 &#39;the specified tree table&#39; || coalesce(&#39;&lt;&#39; || tree_table_name || &#39;&gt; does not exists&#39;, &#39; is NULL&#39;)
<a name="l02837"></a>02837             );   
<a name="l02838"></a>02838             
<a name="l02839"></a>02839     PERFORM MADLIB_SCHEMA.__assert
<a name="l02840"></a>02840             (
<a name="l02841"></a>02841                 verbosity IS NOT NULL,                
<a name="l02842"></a>02842                 &#39;verbosity must be non-null&#39;
<a name="l02843"></a>02843             );              
<a name="l02844"></a>02844     
<a name="l02845"></a>02845     IF (verbosity &gt; 0 ) THEN     
<a name="l02846"></a>02846         exec_begin = clock_timestamp();
<a name="l02847"></a>02847         exec_leaves_rule = exec_begin - exec_begin;
<a name="l02848"></a>02848         exec_union = exec_leaves_rule;
<a name="l02849"></a>02849         exec_internode_rule = exec_leaves_rule;
<a name="l02850"></a>02850     END IF;
<a name="l02851"></a>02851     
<a name="l02852"></a>02852     -- get metatable and classtable name given the tree table name
<a name="l02853"></a>02853     metatable_name = MADLIB_SCHEMA.__get_metatable_name(tree_table_name);
<a name="l02854"></a>02854     classtable_name = MADLIB_SCHEMA.__get_classtable_name(metatable_name);
<a name="l02855"></a>02855     class_column_name = MADLIB_SCHEMA.__get_class_column_name(metatable_name);
<a name="l02856"></a>02856     
<a name="l02857"></a>02857     EXECUTE &#39;SELECT <span class="keywordtype">id</span>, maxclass, probability, cat_size, jump FROM &#39; || tree_table_name || &#39; WHERE <span class="keywordtype">id</span> = 1&#39; 
<a name="l02858"></a>02858     INTO rec;
<a name="l02859"></a>02859     
<a name="l02860"></a>02860     -- in case the root node is leaf
<a name="l02861"></a>02861     IF (rec.jump IS NULL) THEN
<a name="l02862"></a>02862         RETURN NEXT &#39;All instances will be classified to class &#39; || 
<a name="l02863"></a>02863                      MADLIB_SCHEMA.__get_class_value(rec.maxclass, metatable_name) ||
<a name="l02864"></a>02864                      &#39; [&#39; || (rec.probability * rec.cat_size)::BIGINT || &#39;/&#39; || rec.cat_size || &#39;]&#39;; 
<a name="l02865"></a>02865         RETURN;       
<a name="l02866"></a>02866     END IF;
<a name="l02867"></a>02867     
<a name="l02868"></a>02868     -- get the meta info for features in the tree table (as best split)
<a name="l02869"></a>02869     SELECT MADLIB_SCHEMA.__format
<a name="l02870"></a>02870         (
<a name="l02871"></a>02871         &#39;SELECT <span class="keywordtype">id</span>, column_name, table_name, is_cont
<a name="l02872"></a>02872          FROM 
<a name="l02873"></a>02873             MADLIB_SCHEMA.% n1
<a name="l02874"></a>02874          WHERE <span class="keywordtype">id</span> IN
<a name="l02875"></a>02875             (SELECT DISTINCT feature
<a name="l02876"></a>02876              FROM %
<a name="l02877"></a>02877              WHERE jump IS NOT NULL
<a name="l02878"></a>02878             )&#39;,
<a name="l02879"></a>02879         metatable_name,
<a name="l02880"></a>02880         tree_table_name
<a name="l02881"></a>02881         )
<a name="l02882"></a>02882     INTO curstmt;
<a name="l02883"></a>02883     
<a name="l02884"></a>02884     -- put all the features&#39; value together using &#39;union all&#39; 
<a name="l02885"></a>02885     FOR rec IN EXECUTE curstmt LOOP
<a name="l02886"></a>02886         -- continuous feature will produce two rows
<a name="l02887"></a>02887         IF (rec.is_cont) THEN
<a name="l02888"></a>02888             SELECT MADLIB_SCHEMA.__format
<a name="l02889"></a>02889                 (
<a name="l02890"></a>02890                 &#39;SELECT % as fid, 1 as key, &#39;&#39;% &lt;= &#39;&#39;::TEXT as fname, null::text as fval
<a name="l02891"></a>02891                  UNION ALL 
<a name="l02892"></a>02892                  SELECT % as fid, 2 as key, &#39;&#39;% &gt; &#39;&#39;::TEXT as fname, null::text as fval&#39;,
<a name="l02893"></a>02893                 ARRAY[
<a name="l02894"></a>02894                     MADLIB_SCHEMA.__to_char(rec.<span class="keywordtype">id</span>),
<a name="l02895"></a>02895                     rec.column_name,
<a name="l02896"></a>02896                     MADLIB_SCHEMA.__to_char(rec.<span class="keywordtype">id</span>),
<a name="l02897"></a>02897                     rec.column_name
<a name="l02898"></a>02898                     ]
<a name="l02899"></a>02899                 )
<a name="l02900"></a>02900             INTO fvalue_stmt;
<a name="l02901"></a>02901             
<a name="l02902"></a>02902         -- discrete feature will produce the number of rows which is the same with distinct values
<a name="l02903"></a>02903         ELSE
<a name="l02904"></a>02904             SELECT MADLIB_SCHEMA.__format
<a name="l02905"></a>02905                 (
<a name="l02906"></a>02906                 &#39;SELECT % as fid, key, &#39;&#39;% = &#39;&#39;::TEXT as fname, MADLIB_SCHEMA.__to_char(%) as fval
<a name="l02907"></a>02907                  FROM MADLIB_SCHEMA.%
<a name="l02908"></a>02908                  WHERE key IS NOT NULL&#39;,
<a name="l02909"></a>02909                 ARRAY[
<a name="l02910"></a>02910                     MADLIB_SCHEMA.__to_char(rec.<span class="keywordtype">id</span>),
<a name="l02911"></a>02911                     rec.column_name,
<a name="l02912"></a>02912                     rec.column_name,
<a name="l02913"></a>02913                     rec.table_name
<a name="l02914"></a>02914                     ]
<a name="l02915"></a>02915                 )
<a name="l02916"></a>02916             INTO fvalue_stmt;
<a name="l02917"></a>02917         END IF;
<a name="l02918"></a>02918         
<a name="l02919"></a>02919         IF (union_stmt IS NULL) THEN
<a name="l02920"></a>02920             union_stmt = fvalue_stmt;
<a name="l02921"></a>02921         ELSE
<a name="l02922"></a>02922             union_stmt = union_stmt || &#39; UNION ALL &#39; || fvalue_stmt;
<a name="l02923"></a>02923         END IF;
<a name="l02924"></a>02924     END LOOP; 
<a name="l02925"></a>02925     
<a name="l02926"></a>02926     IF (verbosity &gt; 0 ) THEN     
<a name="l02927"></a>02927         exec_union = clock_timestamp() - exec_begin;
<a name="l02928"></a>02928         RAISE INFO &#39;compose feature values statement time:%&#39;, exec_union;
<a name="l02929"></a>02929         RAISE INFO &#39;feature info stmt: %&#39;, curstmt;
<a name="l02930"></a>02930         RAISE INFO &#39;feature value stmt: %&#39;, union_stmt;
<a name="l02931"></a>02931     END IF;
<a name="l02932"></a>02932     
<a name="l02933"></a>02933     -- put the rules for leaves into a temp table
<a name="l02934"></a>02934     DROP TABLE IF EXISTS c45_gen_rules_leaves;
<a name="l02935"></a>02935     SELECT MADLIB_SCHEMA.__format
<a name="l02936"></a>02936         (
<a name="l02937"></a>02937         &#39;CREATE TEMP TABLE c45_gen_rules_leaves as
<a name="l02938"></a><a class="code" href="decision__tree_8sql__in.html#acdba07d3897356a75666aa6d5999f490">02938</a>          SELECT 
<a name="l02939"></a>02939             <span class="keywordtype">id</span>, 
<a name="l02940"></a>02940                 &#39;&#39;  then class &#39;&#39;                   || 
<a name="l02941"></a>02941                 MADLIB_SCHEMA.__to_char(class)      || 
<a name="l02942"></a>02942                 &#39;&#39; [&#39;&#39;                              || 
<a name="l02943"></a>02943                 (probability * cat_size)::BIGINT    || 
<a name="l02944"></a>02944                 &#39;&#39;/&#39;&#39;                               || 
<a name="l02945"></a>02945                 cat_size                            || 
<a name="l02946"></a>02946                 &#39;&#39;]&#39;&#39; 
<a name="l02947"></a>02947             as str,
<a name="l02948"></a>02948             array_to_string(tree_location, &#39;&#39;&#39;&#39;) as location,
<a name="l02949"></a>02949             1 as rlid
<a name="l02950"></a>02950          FROM 
<a name="l02951"></a>02951             (SELECT <span class="keywordtype">id</span>, maxclass, tree_location, probability, cat_size
<a name="l02952"></a>02952              FROM %
<a name="l02953"></a>02953              WHERE jump IS NULL
<a name="l02954"></a>02954             ) n1
<a name="l02955"></a>02955             LEFT JOIN
<a name="l02956"></a>02956             (SELECT % as class, key
<a name="l02957"></a>02957              FROM MADLIB_SCHEMA.% 
<a name="l02958"></a>02958              WHERE key IS NOT NULL
<a name="l02959"></a>02959             ) n2
<a name="l02960"></a>02960             ON n1.maxclass = n2.key 
<a name="l02961"></a>02961          m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (location)&#39;)&#39;,
<a name="l02962"></a>02962         ARRAY[
<a name="l02963"></a>02963             tree_table_name,
<a name="l02964"></a>02964             class_column_name,
<a name="l02965"></a>02965             classtable_name
<a name="l02966"></a>02966             ]
<a name="l02967"></a>02967         )
<a name="l02968"></a>02968     INTO curstmt;
<a name="l02969"></a>02969     
<a name="l02970"></a>02970     EXECUTE curstmt;
<a name="l02971"></a>02971     
<a name="l02972"></a>02972     IF (verbosity &gt; 0 ) THEN     
<a name="l02973"></a>02973         exec_leaves_rule = clock_timestamp() - exec_begin;
<a name="l02974"></a>02974         RAISE INFO &#39;create table for leaves&#39;&#39; rules time:%&#39;, exec_leaves_rule - exec_union;
<a name="l02975"></a>02975         RAISE INFO &#39;create tablefor leaves stmt: %&#39;, curstmt;
<a name="l02976"></a>02976     END IF;
<a name="l02977"></a>02977     
<a name="l02978"></a>02978     DROP TABLE IF EXISTS c45_gen_rules_internode;
<a name="l02979"></a>02979     -- put rules of the internal nodes into a table
<a name="l02980"></a>02980     SELECT MADLIB_SCHEMA.__format
<a name="l02981"></a>02981         (
<a name="l02982"></a>02982         &#39;CREATE TEMP TABLE c45_gen_rules_internode AS
<a name="l02983"></a>02983         SELECT 
<a name="l02984"></a>02984             jump[key + 1] AS <span class="keywordtype">id</span>,
<a name="l02985"></a>02985             CASE WHEN (<span class="keywordtype">id</span> = 1) THEN
<a name="l02986"></a>02986                     &#39;&#39;  if &#39;&#39; || fname || COALESCE(MADLIB_SCHEMA.__to_char(split_value), MADLIB_SCHEMA.__to_char(fval), &#39;&#39;NULL&#39;&#39;) 
<a name="l02987"></a>02987                  ELSE
<a name="l02988"></a>02988                     &#39;&#39;     &#39;&#39; || fname || COALESCE(MADLIB_SCHEMA.__to_char(split_value), MADLIB_SCHEMA.__to_char(fval), &#39;&#39;NULL&#39;&#39;) 
<a name="l02989"></a>02989             END AS str,
<a name="l02990"></a>02990             array_to_string(tree_location, &#39;&#39;&#39;&#39;) || key AS location,
<a name="l02991"></a>02991             0  AS rlid                                  
<a name="l02992"></a>02992         FROM
<a name="l02993"></a>02993             (SELECT <span class="keywordtype">id</span>, feature, tree_location, jump, split_value 
<a name="l02994"></a>02994              FROM %
<a name="l02995"></a>02995              WHERE jump IS NOT NULL
<a name="l02996"></a>02996             ) n1
<a name="l02997"></a>02997             LEFT JOIN
<a name="l02998"></a>02998             (%) n2
<a name="l02999"></a>02999             ON n1.feature = n2.fid
<a name="l03000"></a>03000         WHERE n1.jump[n2.key + 1] IS NOT NULL 
<a name="l03001"></a>03001         m4_ifdef(`GREENPLUM&#39;, `DISTRIBUTED BY (location)&#39;)&#39;,
<a name="l03002"></a>03002         tree_table_name,
<a name="l03003"></a>03003         union_stmt
<a name="l03004"></a>03004         )
<a name="l03005"></a>03005     INTO curstmt;    
<a name="l03006"></a>03006     EXECUTE curstmt;
<a name="l03007"></a>03007    
<a name="l03008"></a>03008     IF (verbosity &gt; 0 ) THEN     
<a name="l03009"></a>03009         exec_internode_rule = clock_timestamp() - exec_begin;
<a name="l03010"></a>03010         RAISE INFO &#39;create table for internal nodes&#39;&#39; rules time:%&#39;, exec_internode_rule - exec_leaves_rule;
<a name="l03011"></a>03011         RAISE INFO &#39;create tablefor internal nodes stmt: %&#39;, curstmt;
<a name="l03012"></a>03012     END IF;
<a name="l03013"></a>03013    
<a name="l03014"></a>03014     FOR rec IN EXECUTE &#39;  
<a name="l03015"></a>03015                   SELECT t1.<span class="keywordtype">id</span>, t1.rlid, t2.location, t1.str 
<a name="l03016"></a>03016                   FROM
<a name="l03017"></a>03017                     c45_gen_rules_internode t1
<a name="l03018"></a>03018                     LEFT JOIN
<a name="l03019"></a>03019                     c45_gen_rules_leaves t2 
<a name="l03020"></a>03020                     ON position(t1.location in t2.location) = 1 
<a name="l03021"></a>03021                   UNION ALL 
<a name="l03022"></a>03022                   SELECT <span class="keywordtype">id</span>, rlid, location, str 
<a name="l03023"></a>03023                   FROM  c45_gen_rules_leaves n 
<a name="l03024"></a>03024                   ORDER BY location, rlid, <span class="keywordtype">id</span>&#39;
<a name="l03025"></a>03025                   LOOP
<a name="l03026"></a>03026         RETURN NEXT rec.str;
<a name="l03027"></a>03027     END LOOP;
<a name="l03028"></a>03028    
<a name="l03029"></a>03029     IF (verbosity &gt; 0 ) THEN     
<a name="l03030"></a>03030         RAISE INFO &#39;Total rules generation time:%&#39;, clock_timestamp() - exec_begin;
<a name="l03031"></a>03031     END IF;
<a name="l03032"></a>03032     
<a name="l03033"></a>03033     RETURN;
<a name="l03034"></a>03034 END $$ LANGUAGE PLPGSQL;
<a name="l03035"></a>03035 <span class="comment"></span>
<a name="l03036"></a>03036 <span class="comment">/**</span>
<a name="l03037"></a>03037 <span class="comment"> * @brief   Display the trained decision tree model with rules</span>
<a name="l03038"></a>03038 <span class="comment"> *</span>
<a name="l03039"></a>03039 <span class="comment"> * @param   tree_table_name     Name of the table containing the tree&#39;s information</span>
<a name="l03040"></a>03040 <span class="comment"> *</span>
<a name="l03041"></a>03041 <span class="comment"> * @return  The rule representation text for a decision tree.</span>
<a name="l03042"></a>03042 <span class="comment"> *</span>
<a name="l03043"></a>03043 <span class="comment"> */</span>
<a name="l03044"></a>03044 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac71787c47795b3b0b133cdbd37438242" title="Display the trained decision tree model with rules.">c45_genrule</a>
<a name="l03045"></a>03045     (
<a name="l03046"></a>03046     tree_table_name TEXT
<a name="l03047"></a>03047     );
<a name="l03048"></a>03048 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac71787c47795b3b0b133cdbd37438242" title="Display the trained decision tree model with rules.">c45_genrule</a>
<a name="l03049"></a>03049     (
<a name="l03050"></a>03050     tree_table_name TEXT
<a name="l03051"></a>03051     ) 
<a name="l03052"></a>03052 RETURNS SETOF TEXT AS $$
<a name="l03053"></a>03053 DECLARE 
<a name="l03054"></a>03054     str             TEXT;
<a name="l03055"></a>03055 BEGIN
<a name="l03056"></a>03056     -- run in non-verbose mode
<a name="l03057"></a>03057     FOR str IN EXECUTE
<a name="l03058"></a>03058                 &#39;SELECT *
<a name="l03059"></a>03059                  FROM MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac71787c47795b3b0b133cdbd37438242" title="Display the trained decision tree model with rules.">c45_genrule</a>
<a name="l03060"></a>03060                  (&#39; || coalesce(&#39;&#39;&#39;&#39; || tree_table_name || &#39;&#39;&#39;&#39;, &#39;NULL&#39;) || &#39;, 0)&#39;
<a name="l03061"></a>03061     LOOP
<a name="l03062"></a>03062         RETURN NEXT str;
<a name="l03063"></a>03063     END LOOP;
<a name="l03064"></a>03064    
<a name="l03065"></a>03065     RETURN;
<a name="l03066"></a>03066 END
<a name="l03067"></a>03067 $$ LANGUAGE PLPGSQL;
<a name="l03068"></a>03068 
<a name="l03069"></a>03069 <span class="comment">/*</span>
<a name="l03070"></a>03070 <span class="comment"> * This is a internal function for displaying one tree node in human readable </span>
<a name="l03071"></a>03071 <span class="comment"> * format. It is the step function of aggregation named __display_tree_aggr.</span>
<a name="l03072"></a>03072 <span class="comment"> * Parameters:</span>
<a name="l03073"></a>03073 <span class="comment"> *      state:              This variable is used to store the accumulated tree </span>
<a name="l03074"></a>03074 <span class="comment"> *                          display information.</span>
<a name="l03075"></a>03075 <span class="comment"> *      depth:              The depth of this node.</span>
<a name="l03076"></a>03076 <span class="comment"> *      is_cont:            Whether the feature used to split is continuous</span>
<a name="l03077"></a>03077 <span class="comment"> *      depth:              The depth of current node.</span>
<a name="l03078"></a>03078 <span class="comment"> *      feat_name:          The name of the feature used to split</span>
<a name="l03079"></a>03079 <span class="comment"> *      curr_val:           The value of the splitting feature for this node.</span>
<a name="l03080"></a>03080 <span class="comment"> *      sp_val:             For continuous feature, it specifies the split value. </span>
<a name="l03081"></a>03081 <span class="comment"> *                          Otherwise, it is of no meaning.</span>
<a name="l03082"></a>03082 <span class="comment"> *      max_prob:           For those elements in this node, the probability that</span>
<a name="l03083"></a>03083 <span class="comment"> *                          an element belongs to the max_class.</span>
<a name="l03084"></a>03084 <span class="comment"> *      max_class:          The class name with the largest number of elements </span>
<a name="l03085"></a>03085 <span class="comment"> *                          for those elements in this node.</span>
<a name="l03086"></a>03086 <span class="comment"> *      cat_size:           Total count of elements in this node.</span>
<a name="l03087"></a>03087 <span class="comment"> * Return:</span>
<a name="l03088"></a>03088 <span class="comment"> *      It returns the text containing the information of human readable information for tree.</span>
<a name="l03089"></a>03089 <span class="comment"> */</span>
<a name="l03090"></a>03090 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__display_node_sfunc
<a name="l03091"></a>03091     (
<a name="l03092"></a>03092     state       TEXT,
<a name="l03093"></a>03093     depth       INT,
<a name="l03094"></a>03094     is_cont     BOOLEAN,
<a name="l03095"></a>03095     feat_name   TEXT,
<a name="l03096"></a>03096     curr_val    TEXT,
<a name="l03097"></a>03097     sp_val      FLOAT8,
<a name="l03098"></a>03098     max_prob    FLOAT8,
<a name="l03099"></a>03099     max_class   TEXT,
<a name="l03100"></a>03100     cat_size    INT
<a name="l03101"></a>03101     );
<a name="l03102"></a>03102 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__display_node_sfunc
<a name="l03103"></a>03103     (
<a name="l03104"></a>03104     state       TEXT,
<a name="l03105"></a>03105     depth       INT,
<a name="l03106"></a>03106     is_cont     BOOLEAN,
<a name="l03107"></a>03107     feat_name   TEXT,
<a name="l03108"></a>03108     curr_val    TEXT,
<a name="l03109"></a>03109     sp_val      FLOAT8,
<a name="l03110"></a>03110     max_prob    FLOAT8,
<a name="l03111"></a>03111     max_class   TEXT,
<a name="l03112"></a>03112     cat_size    INT
<a name="l03113"></a>03113     ) 
<a name="l03114"></a>03114 RETURNS TEXT AS $$ 
<a name="l03115"></a>03115 DECLARE
<a name="l03116"></a>03116     ret                     TEXT := &#39;&#39;;
<a name="l03117"></a>03117     index                   INT;
<a name="l03118"></a>03118 BEGIN
<a name="l03119"></a>03119     -- We add indentation based on the depth.
<a name="l03120"></a>03120     FOR index IN 0..depth LOOP
<a name="l03121"></a>03121         ret = ret || &#39;    &#39;;
<a name="l03122"></a>03122     END LOOP;
<a name="l03123"></a>03123     
<a name="l03124"></a>03124     IF (depth &gt; 0) THEN
<a name="l03125"></a>03125         ret = ret ||coalesce(feat_name,&#39;null&#39;)||&#39;: &#39;;
<a name="l03126"></a>03126         -- For continuous features, there are two splits.
<a name="l03127"></a>03127         -- We will mark curr_val to 1 for &#39;&lt;=&#39;. Otherwise, 
<a name="l03128"></a>03128         -- we will mark curr_val to 2.
<a name="l03129"></a>03129         IF (is_cont) THEN
<a name="l03130"></a>03130             IF (curr_val::INT = 1) THEN
<a name="l03131"></a>03131                 ret = ret || &#39; &lt;= &#39;;
<a name="l03132"></a>03132             ELSE
<a name="l03133"></a>03133                 ret = ret || &#39; &gt; &#39;;
<a name="l03134"></a>03134             END IF;
<a name="l03135"></a>03135             ret = ret||coalesce(sp_val,0)||&#39; &#39;;
<a name="l03136"></a>03136         ELSE
<a name="l03137"></a>03137             ret = ret||&#39; = &#39;||coalesce(curr_val,&#39;null&#39;)||&#39; &#39;;
<a name="l03138"></a>03138         END IF;
<a name="l03139"></a>03139     ELSE
<a name="l03140"></a>03140         ret = ret||&#39;Root Node &#39;;
<a name="l03141"></a>03141     END IF;
<a name="l03142"></a>03142 
<a name="l03143"></a>03143     ret = ret                               || 
<a name="l03144"></a>03144           &#39; : class(&#39;                       ||  
<a name="l03145"></a>03145           coalesce(max_class,null)          || 
<a name="l03146"></a>03146           &#39;)   num_elements(&#39;               || 
<a name="l03147"></a>03147           coalesce(cat_size,0)              || 
<a name="l03148"></a>03148           &#39;)  predict_prob(&#39;                ||
<a name="l03149"></a>03149           coalesce(max_prob,0)              ||
<a name="l03150"></a>03150           &#39;)&#39;;
<a name="l03151"></a>03151 
<a name="l03152"></a>03152     ret = ret || E&#39;\n&#39;;
<a name="l03153"></a>03153 
<a name="l03154"></a>03154     -- If there exists information, append the information
<a name="l03155"></a>03155     -- for this node.
<a name="l03156"></a>03156     IF (state IS NOT NULL) THEN
<a name="l03157"></a>03157         ret = state || ret;
<a name="l03158"></a>03158     END IF;
<a name="l03159"></a>03159     
<a name="l03160"></a>03160     RETURN ret;
<a name="l03161"></a>03161 END 
<a name="l03162"></a>03162 $$ LANGUAGE PLPGSQL;
<a name="l03163"></a>03163 
<a name="l03164"></a>03164 
<a name="l03165"></a>03165 DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.__display_tree_aggr
<a name="l03166"></a>03166     (
<a name="l03167"></a>03167     INT,        -- depth
<a name="l03168"></a>03168     BOOLEAN,    -- is_cont
<a name="l03169"></a>03169     TEXT,       -- feature name
<a name="l03170"></a>03170     TEXT,       -- curr_val
<a name="l03171"></a>03171     FLOAT8,     -- split value
<a name="l03172"></a>03172     FLOAT8,     -- max_probability
<a name="l03173"></a>03173     TEXT,       -- max_class
<a name="l03174"></a>03174     INT         -- cat_size
<a name="l03175"></a>03175     ) CASCADE;
<a name="l03176"></a>03176 CREATE 
<a name="l03177"></a>03177 m4_ifdef(`__GREENPLUM__&#39;, m4_ifdef(`__HAS_ORDERED_AGGREGATES__&#39;, `ORDERED&#39;))
<a name="l03178"></a>03178 AGGREGATE MADLIB_SCHEMA.__display_tree_aggr
<a name="l03179"></a>03179     (
<a name="l03180"></a>03180     INT,        -- depth
<a name="l03181"></a>03181     BOOLEAN,    -- is_cont
<a name="l03182"></a>03182     TEXT,       -- feature name
<a name="l03183"></a>03183     TEXT,       -- curr_val
<a name="l03184"></a>03184     FLOAT8,     -- split value
<a name="l03185"></a>03185     FLOAT8,     -- max_probability
<a name="l03186"></a>03186     TEXT,       -- max_class
<a name="l03187"></a>03187     INT         -- cat_size
<a name="l03188"></a>03188     ) 
<a name="l03189"></a>03189 (
<a name="l03190"></a>03190   SFUNC=MADLIB_SCHEMA.__display_node_sfunc,
<a name="l03191"></a>03191   STYPE=TEXT
<a name="l03192"></a>03192 );
<a name="l03193"></a>03193 
<a name="l03194"></a>03194 <span class="comment">/*</span>
<a name="l03195"></a>03195 <span class="comment"> * Display the trained decision tree model with human readable format.</span>
<a name="l03196"></a>03196 <span class="comment"> * It use the recursive algorithm, which is slower than the version with </span>
<a name="l03197"></a>03197 <span class="comment"> * ordered aggregate.</span>
<a name="l03198"></a>03198 <span class="comment"> * Parameters:</span>
<a name="l03199"></a>03199 <span class="comment"> *      tree_table  Name of the table containing the tree&#39;s information</span>
<a name="l03200"></a>03200 <span class="comment"> *      max_depth   The max depth to be displayed. If it is set to null,</span>
<a name="l03201"></a>03201 <span class="comment"> *                  this function will show all levels.</span>
<a name="l03202"></a>03202 <span class="comment"> * Return:</span>
<a name="l03203"></a>03203 <span class="comment"> *      the text representing the tree with human readable format.</span>
<a name="l03204"></a>03204 <span class="comment"> */</span>
<a name="l03205"></a>03205 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__c45_display_with_ordered_aggr
<a name="l03206"></a>03206     (
<a name="l03207"></a>03207     tree_table  TEXT,
<a name="l03208"></a>03208     max_depth   INT
<a name="l03209"></a>03209     );
<a name="l03210"></a>03210 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__c45_display_with_ordered_aggr
<a name="l03211"></a>03211     (
<a name="l03212"></a>03212     tree_table  TEXT,
<a name="l03213"></a>03213     max_depth   INT
<a name="l03214"></a>03214     ) 
<a name="l03215"></a>03215 RETURNS TEXT AS $$
<a name="l03216"></a>03216 DECLARE
<a name="l03217"></a>03217     metatable_name  TEXT := null;
<a name="l03218"></a>03218     curr_stmt       TEXT := null;
<a name="l03219"></a>03219     feature_name    TEXT := null;
<a name="l03220"></a>03220     table_name      TEXT := null;
<a name="l03221"></a>03221     result          TEXT := null;
<a name="l03222"></a>03222     result_rec      RECORD;
<a name="l03223"></a>03223 BEGIN
<a name="l03224"></a>03224     PERFORM MADLIB_SCHEMA.__assert
<a name="l03225"></a>03225             (
<a name="l03226"></a>03226                 MADLIB_SCHEMA.__get_schema_name(tree_table),
<a name="l03227"></a>03227                 MADLIB_SCHEMA.__strip_schema_name(tree_table),
<a name="l03228"></a>03228                 &#39;t&#39;
<a name="l03229"></a>03229             );   
<a name="l03230"></a>03230             
<a name="l03231"></a>03231     metatable_name = MADLIB_SCHEMA.__get_metatable_name( tree_table );
<a name="l03232"></a>03232     -- We removed the schema when storing the metatable&#39;s name. 
<a name="l03233"></a>03233     metatable_name = &#39;MADLIB_SCHEMA.&#39;||metatable_name;
<a name="l03234"></a>03234  
<a name="l03235"></a>03235     -- This table is used for tree display.
<a name="l03236"></a>03236     -- It is filled with the original information before
<a name="l03237"></a>03237     -- encoding to facilitate the display procedure.
<a name="l03238"></a>03238     DROP TABLE IF EXISTS auxiliary_tree_display;
<a name="l03239"></a>03239     CREATE TEMP TABLE auxiliary_tree_display
<a name="l03240"></a>03240     (
<a name="l03241"></a>03241         <span class="keywordtype">id</span>                      INT,
<a name="l03242"></a>03242         tree_location           INT[],
<a name="l03243"></a>03243         probability             FLOAT8, 
<a name="l03244"></a>03244         maxclass                TEXT,
<a name="l03245"></a>03245         cat_size                INT,
<a name="l03246"></a>03246         parent_id               INT,
<a name="l03247"></a>03247         curr_value              TEXT,
<a name="l03248"></a>03248         parent_feature_id       INT,
<a name="l03249"></a>03249         is_parent_feature_cont  BOOLEAN,
<a name="l03250"></a>03250         parent_split_value      FLOAT8,
<a name="l03251"></a>03251         parent_feature_name     TEXT
<a name="l03252"></a>03252     ) m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (<span class="keywordtype">id</span>)&#39;);
<a name="l03253"></a>03253     
<a name="l03254"></a>03254     -- We made a self join for the tree table. For each node, we get the 
<a name="l03255"></a>03255     -- feature information at its parent node so as to display this node. 
<a name="l03256"></a>03256     SELECT MADLIB_SCHEMA.__format(
<a name="l03257"></a>03257         &#39;INSERT INTO auxiliary_tree_display SELECT m.*, 
<a name="l03258"></a>03258         n.column_name as parent_feature_name
<a name="l03259"></a>03259         FROM 
<a name="l03260"></a>03260         (SELECT t1.<span class="keywordtype">id</span>, t1.tree_location,t1.probability,t1.maxclass::TEXT,
<a name="l03261"></a>03261             t1.cat_size,t1.parent_id, 
<a name="l03262"></a>03262             t1.tree_location[array_upper(t1.tree_location,1)]::TEXT as curr_value, 
<a name="l03263"></a>03263             t2.feature as parent_feature_id, t2.is_feature_cont as is_parent_feature_cont, 
<a name="l03264"></a>03264             t2.split_value as parent_split_value 
<a name="l03265"></a>03265             FROM % t1 LEFT JOIN % t2 on t1.parent_id = t2.<span class="keywordtype">id</span>) m 
<a name="l03266"></a>03266          LEFT JOIN % n 
<a name="l03267"></a>03267             on m.parent_feature_id = n.<span class="keywordtype">id</span>;&#39;,
<a name="l03268"></a>03268         ARRAY[
<a name="l03269"></a>03269             tree_table,
<a name="l03270"></a>03270             tree_table,
<a name="l03271"></a>03271             metatable_name
<a name="l03272"></a>03272         ]
<a name="l03273"></a>03273         )
<a name="l03274"></a>03274     INTO curr_stmt;     
<a name="l03275"></a>03275     EXECUTE curr_stmt;
<a name="l03276"></a>03276 
<a name="l03277"></a>03277     -- Get the metatable storing the encoding information of class.
<a name="l03278"></a>03278     EXECUTE &#39;SELECT column_name,table_name FROM &#39;||metatable_name||
<a name="l03279"></a>03279             &#39; WHERE column_type=&#39;&#39;c&#39;&#39; LIMIT 1;&#39;
<a name="l03280"></a>03280             INTO result_rec;
<a name="l03281"></a>03281     table_name = &#39;MADLIB_SCHEMA.&#39;||result_rec.table_name;
<a name="l03282"></a>03282     
<a name="l03283"></a>03283     IF (table_name IS NOT NULL) THEN
<a name="l03284"></a>03284         -- Convert back for the class column.
<a name="l03285"></a>03285         SELECT MADLIB_SCHEMA.__format(
<a name="l03286"></a>03286             &#39;UPDATE auxiliary_tree_display n 
<a name="l03287"></a>03287              SET maxclass = MADLIB_SCHEMA.__to_char(m.%) 
<a name="l03288"></a>03288              FROM % m 
<a name="l03289"></a>03289              WHERE m.key = n.maxclass::INT
<a name="l03290"></a>03290             &#39;,
<a name="l03291"></a>03291             ARRAY[
<a name="l03292"></a>03292                 result_rec.column_name,
<a name="l03293"></a>03293                 table_name
<a name="l03294"></a>03294             ]
<a name="l03295"></a>03295             )
<a name="l03296"></a>03296         INTO curr_stmt;  
<a name="l03297"></a>03297         EXECUTE curr_stmt;
<a name="l03298"></a>03298     END IF;
<a name="l03299"></a>03299 
<a name="l03300"></a>03300     -- Get the metatables storing the encoding information for discrete features.
<a name="l03301"></a>03301     SELECT MADLIB_SCHEMA.__format(
<a name="l03302"></a>03302         &#39;SELECT column_name,table_name FROM % 
<a name="l03303"></a>03303          WHERE NOT is_cont AND column_type=&#39;&#39;f&#39;&#39;;&#39;,
<a name="l03304"></a>03304         ARRAY[
<a name="l03305"></a>03305             metatable_name
<a name="l03306"></a>03306         ]
<a name="l03307"></a>03307         )
<a name="l03308"></a>03308     INTO curr_stmt;  
<a name="l03309"></a>03309     
<a name="l03310"></a>03310     -- Convert back for discrete features.
<a name="l03311"></a>03311     FOR result_rec IN EXECUTE (curr_stmt) LOOP
<a name="l03312"></a>03312         feature_name = result_rec.column_name;
<a name="l03313"></a>03313         table_name = result_rec.table_name;
<a name="l03314"></a>03314         table_name = &#39;MADLIB_SCHEMA.&#39;||table_name;
<a name="l03315"></a>03315         SELECT MADLIB_SCHEMA.__format(
<a name="l03316"></a>03316             &#39;UPDATE auxiliary_tree_display n 
<a name="l03317"></a>03317              SET curr_value = MADLIB_SCHEMA.__to_char(m.%) 
<a name="l03318"></a>03318              FROM % m 
<a name="l03319"></a>03319              WHERE m.key = n.curr_value::INT 
<a name="l03320"></a>03320              AND n.parent_feature_name = %
<a name="l03321"></a>03321             &#39;,
<a name="l03322"></a>03322             ARRAY[
<a name="l03323"></a>03323                 feature_name,
<a name="l03324"></a>03324                 table_name,
<a name="l03325"></a>03325                 quote_literal(feature_name)
<a name="l03326"></a>03326             ]
<a name="l03327"></a>03327             )
<a name="l03328"></a>03328         INTO curr_stmt;  
<a name="l03329"></a>03329         EXECUTE curr_stmt;   
<a name="l03330"></a>03330     END LOOP;
<a name="l03331"></a>03331 
<a name="l03332"></a>03332     -- Now we already get all the information. Invoke the
<a name="l03333"></a>03333     -- aggregation to show the tree.
<a name="l03334"></a>03334     -- If we order by tree_location, we can get the sequence 
<a name="l03335"></a>03335     -- of depth first traversal.
<a name="l03336"></a>03336     curr_stmt = &#39;SELECT MADLIB_SCHEMA.__display_tree_aggr(
<a name="l03337"></a>03337                 array_upper(tree_location,1)-1,
<a name="l03338"></a>03338                 is_parent_feature_cont,
<a name="l03339"></a>03339                 parent_feature_name,
<a name="l03340"></a>03340                 curr_value,
<a name="l03341"></a>03341                 parent_split_value,
<a name="l03342"></a>03342                 probability,
<a name="l03343"></a>03343                 maxclass,
<a name="l03344"></a>03344                 cat_size 
<a name="l03345"></a>03345                 order by tree_location)
<a name="l03346"></a>03346          FROM auxiliary_tree_display&#39;;
<a name="l03347"></a>03347 
<a name="l03348"></a>03348     IF (max_depth IS NOT NULL) THEN
<a name="l03349"></a>03349         curr_stmt = curr_stmt                                   ||
<a name="l03350"></a>03350                     &#39; WHERE array_upper(tree_location,1) - 1 &lt;=&#39;  ||
<a name="l03351"></a>03351                     max_depth;
<a name="l03352"></a>03352     END IF;
<a name="l03353"></a>03353 
<a name="l03354"></a>03354     EXECUTE curr_stmt INTO result; 
<a name="l03355"></a>03355     RETURN result;
<a name="l03356"></a>03356 END $$ LANGUAGE PLPGSQL;
<a name="l03357"></a>03357 
<a name="l03358"></a>03358 
<a name="l03359"></a>03359 <span class="comment">/*</span>
<a name="l03360"></a>03360 <span class="comment"> * This is a internal function for displaying the tree in human readable format.</span>
<a name="l03361"></a>03361 <span class="comment"> * It use the depth-first strategy to traverse a tree and print values.</span>
<a name="l03362"></a>03362 <span class="comment"> * Parameters:</span>
<a name="l03363"></a>03363 <span class="comment"> *      tree_table:         The name of the table with information for the </span>
<a name="l03364"></a>03364 <span class="comment"> *                          trained tree.</span>
<a name="l03365"></a>03365 <span class="comment"> *      id:                 The id of current node. This node and all of its  </span>
<a name="l03366"></a>03366 <span class="comment"> *                          children are displayed.</span>
<a name="l03367"></a>03367 <span class="comment"> *      feature_id:         The id of a feature, which was used to split in the </span>
<a name="l03368"></a>03368 <span class="comment"> *                          parent of current node.</span>
<a name="l03369"></a>03369 <span class="comment"> *      depth:              The depth of current node.</span>
<a name="l03370"></a>03370 <span class="comment"> *      is_cont:            It specifies whether the feature denoted by &#39;feature_id&#39;</span>
<a name="l03371"></a>03371 <span class="comment"> *                          is continuous or not.</span>
<a name="l03372"></a>03372 <span class="comment"> *      split_value:        For continuous feature, it specifies the split value. </span>
<a name="l03373"></a>03373 <span class="comment"> *                          Otherwise, it is of no meaning.</span>
<a name="l03374"></a>03374 <span class="comment"> *      metatable_name:     For tabular format, this table contains the meta data</span>
<a name="l03375"></a>03375 <span class="comment"> *                          to encode the input table.</span>
<a name="l03376"></a>03376 <span class="comment"> *      max_depth:          The max depth to be displayed. If it is set to null,</span>
<a name="l03377"></a>03377 <span class="comment"> *                          this function will show all levels. </span>
<a name="l03378"></a>03378 <span class="comment"> * Return:</span>
<a name="l03379"></a>03379 <span class="comment"> *      It returns the text containing the information of human readable tree.</span>
<a name="l03380"></a>03380 <span class="comment"> */</span>
<a name="l03381"></a>03381 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__display_tree_no_ordered_aggr
<a name="l03382"></a>03382     (
<a name="l03383"></a>03383     tree_table      TEXT, 
<a name="l03384"></a>03384     <span class="keywordtype">id</span>              INT, 
<a name="l03385"></a>03385     feature_id      INT, 
<a name="l03386"></a>03386     depth           INT, 
<a name="l03387"></a>03387     is_cont         BOOLEAN, 
<a name="l03388"></a>03388     split_value     FLOAT,
<a name="l03389"></a>03389     metatable_name  TEXT,
<a name="l03390"></a>03390     max_depth       INT
<a name="l03391"></a>03391     );
<a name="l03392"></a>03392 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__display_tree_no_ordered_aggr
<a name="l03393"></a>03393     (
<a name="l03394"></a>03394     tree_table      TEXT, 
<a name="l03395"></a>03395     <span class="keywordtype">id</span>              INT, 
<a name="l03396"></a>03396     feature_id      INT, 
<a name="l03397"></a>03397     depth           INT, 
<a name="l03398"></a>03398     is_cont         BOOLEAN, 
<a name="l03399"></a>03399     split_value     FLOAT,
<a name="l03400"></a>03400     metatable_name  TEXT,
<a name="l03401"></a>03401     max_depth       INT
<a name="l03402"></a>03402     ) 
<a name="l03403"></a>03403 RETURNS TEXT AS $$ 
<a name="l03404"></a>03404 DECLARE
<a name="l03405"></a>03405     ret                     TEXT := &#39;&#39;;
<a name="l03406"></a>03406     tree_location           INT[];
<a name="l03407"></a>03407     feature                 INT;
<a name="l03408"></a>03408     jump                    INT[];
<a name="l03409"></a>03409     maxclass                INT;
<a name="l03410"></a>03410     cat_size                INT;
<a name="l03411"></a>03411     is_feature_cont         BOOLEAN;
<a name="l03412"></a>03412     temp_split_value        FLOAT;
<a name="l03413"></a>03413     index                   INT;
<a name="l03414"></a>03414     curr_value              INT;
<a name="l03415"></a>03415     probability             FLOAT;
<a name="l03416"></a>03416 BEGIN
<a name="l03417"></a>03417     IF (<span class="keywordtype">id</span> IS NULL OR <span class="keywordtype">id</span> &lt;= 0) THEN
<a name="l03418"></a>03418         RETURN ret;
<a name="l03419"></a>03419     END IF;
<a name="l03420"></a>03420     
<a name="l03421"></a>03421     EXECUTE &#39;select tree_location, feature, jump,is_feature_cont, split_value,
<a name="l03422"></a>03422         maxclass,cat_size,probability from &#39;
<a name="l03423"></a>03423         || tree_table || &#39; where <span class="keywordtype">id</span> =&#39; || <span class="keywordtype">id</span> ||&#39;;&#39; INTO tree_location, feature,jump, 
<a name="l03424"></a>03424         is_feature_cont,temp_split_value,maxclass, cat_size, probability; 
<a name="l03425"></a>03425 
<a name="l03426"></a>03426     curr_value = tree_location[array_upper(tree_location,1)];
<a name="l03427"></a>03427 
<a name="l03428"></a>03428     FOR index IN 0..depth LOOP
<a name="l03429"></a>03429         ret = ret || &#39;    &#39;;
<a name="l03430"></a>03430     END LOOP;
<a name="l03431"></a>03431     
<a name="l03432"></a>03432     IF (<span class="keywordtype">id</span> &gt; 1) THEN
<a name="l03433"></a><a class="code" href="decision__tree_8sql__in.html#ac0df8cd7d8eede8f1c204b263eb971a7">03433</a>         ret = ret ||MADLIB_SCHEMA.__get_feature_name(feature_id,metatable_name)||&#39;: &#39;;
<a name="l03434"></a>03434 
<a name="l03435"></a>03435         IF (is_cont) THEN
<a name="l03436"></a>03436             IF (curr_value = 1) THEN
<a name="l03437"></a>03437                 ret = ret || &#39; &lt;= &#39;;
<a name="l03438"></a>03438             ELSE
<a name="l03439"></a>03439                 ret = ret || &#39; &gt; &#39;;
<a name="l03440"></a>03440             END IF;
<a name="l03441"></a>03441             ret = ret || split_value;
<a name="l03442"></a>03442         ELSE
<a name="l03443"></a>03443             ret = ret   || 
<a name="l03444"></a>03444                   &#39; = &#39; || 
<a name="l03445"></a>03445                   MADLIB_SCHEMA.__get_feature_value
<a name="l03446"></a>03446                     (
<a name="l03447"></a>03447                     feature_id, 
<a name="l03448"></a>03448                     curr_value, 
<a name="l03449"></a>03449                     metatable_name
<a name="l03450"></a>03450                     );
<a name="l03451"></a>03451         END IF;
<a name="l03452"></a>03452     ELSE
<a name="l03453"></a>03453         ret = ret||&#39;Root Node &#39;;
<a name="l03454"></a>03454     END IF;
<a name="l03455"></a>03455 
<a name="l03456"></a>03456     ret = ret                                                       || 
<a name="l03457"></a>03457           &#39; : class(&#39;                                               ||  
<a name="l03458"></a>03458           MADLIB_SCHEMA.__get_class_value(maxclass,metatable_name)  || 
<a name="l03459"></a>03459           &#39;)   num_elements(&#39;                                       || 
<a name="l03460"></a>03460           cat_size                                                  || 
<a name="l03461"></a>03461           &#39;)  predict_prob(&#39;                                        ||
<a name="l03462"></a>03462           probability                                               ||
<a name="l03463"></a>03463           &#39;)&#39;;
<a name="l03464"></a>03464 
<a name="l03465"></a>03465     ret = ret || E&#39;\n&#39;;
<a name="l03466"></a>03466     
<a name="l03467"></a>03467     IF (max_depth IS NOT NULL AND 
<a name="l03468"></a>03468         depth &gt;= max_depth) THEN
<a name="l03469"></a>03469         RETURN ret;
<a name="l03470"></a>03470     END IF;
<a name="l03471"></a>03471 
<a name="l03472"></a>03472     index = array_lower(jump,1);
<a name="l03473"></a>03473     WHILE index &lt;= array_upper(jump,1) LOOP
<a name="l03474"></a>03474         ret = ret || MADLIB_SCHEMA.__display_tree_no_ordered_aggr(
<a name="l03475"></a>03475                             tree_table, 
<a name="l03476"></a><a class="code" href="decision__tree_8sql__in.html#accb2a7ab7061cc956fc84bbf2186736b">03476</a>                             jump[index], 
<a name="l03477"></a>03477                             feature, 
<a name="l03478"></a>03478                             depth+1, 
<a name="l03479"></a>03479                             is_feature_cont, 
<a name="l03480"></a>03480                             temp_split_value, 
<a name="l03481"></a>03481                             metatable_name,
<a name="l03482"></a>03482                             max_depth);
<a name="l03483"></a>03483         index = index +1;
<a name="l03484"></a>03484     END LOOP; 
<a name="l03485"></a>03485 
<a name="l03486"></a>03486     RETURN ret;
<a name="l03487"></a>03487 END $$ LANGUAGE PLPGSQL;
<a name="l03488"></a>03488 
<a name="l03489"></a>03489 
<a name="l03490"></a>03490 <span class="comment">/*</span>
<a name="l03491"></a>03491 <span class="comment"> * Display the trained decision tree model with human readable format.</span>
<a name="l03492"></a>03492 <span class="comment"> * It use the recursive algorithm, which is slower than the version with </span>
<a name="l03493"></a>03493 <span class="comment"> * ordered aggregate.</span>
<a name="l03494"></a>03494 <span class="comment"> * Parameters:</span>
<a name="l03495"></a>03495 <span class="comment"> *      tree_table  Name of the table containing the tree&#39;s information</span>
<a name="l03496"></a>03496 <span class="comment"> *      max_depth   The max depth to be displayed. If it is set to null,</span>
<a name="l03497"></a>03497 <span class="comment"> *                  this function will show all levels.</span>
<a name="l03498"></a>03498 <span class="comment"> * Return:</span>
<a name="l03499"></a>03499 <span class="comment"> *      the text representing the tree with human readable format.</span>
<a name="l03500"></a>03500 <span class="comment"> */</span>
<a name="l03501"></a>03501 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__c45_display_no_ordered_aggr    
<a name="l03502"></a>03502     (
<a name="l03503"></a>03503     tree_table  TEXT,
<a name="l03504"></a>03504     max_depth   INT
<a name="l03505"></a>03505     );
<a name="l03506"></a>03506 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__c45_display_no_ordered_aggr
<a name="l03507"></a>03507     (
<a name="l03508"></a>03508     tree_table  TEXT,
<a name="l03509"></a>03509     max_depth   INT
<a name="l03510"></a>03510     ) 
<a name="l03511"></a>03511 RETURNS TEXT AS $$
<a name="l03512"></a>03512 DECLARE
<a name="l03513"></a>03513     metatable_name  TEXT := null;
<a name="l03514"></a>03514     curstmt         TEXT := &#39;&#39;;
<a name="l03515"></a>03515 BEGIN
<a name="l03516"></a>03516     PERFORM MADLIB_SCHEMA.__assert
<a name="l03517"></a>03517             (
<a name="l03518"></a>03518                 MADLIB_SCHEMA.__get_schema_name(tree_table),
<a name="l03519"></a>03519                 MADLIB_SCHEMA.__strip_schema_name(tree_table),
<a name="l03520"></a>03520                 &#39;t&#39;
<a name="l03521"></a>03521             );   
<a name="l03522"></a>03522             
<a name="l03523"></a>03523     metatable_name = MADLIB_SCHEMA.__get_metatable_name( tree_table );
<a name="l03524"></a>03524     
<a name="l03525"></a>03525     RETURN MADLIB_SCHEMA.__display_tree_no_ordered_aggr(tree_table, 1, 0, 0, &#39;f&#39;, 
<a name="l03526"></a>03526         0, metatable_name,max_depth);
<a name="l03527"></a>03527 END $$ LANGUAGE PLPGSQL;
<a name="l03528"></a>03528 <span class="comment"></span>
<a name="l03529"></a>03529 <span class="comment">/**</span>
<a name="l03530"></a>03530 <span class="comment"> * @brief Display the trained decision tree model with human readable format.</span>
<a name="l03531"></a>03531 <span class="comment"> *</span>
<a name="l03532"></a>03532 <span class="comment"> * @param tree_table Name of the table containing the tree&#39;s information</span>
<a name="l03533"></a>03533 <span class="comment"> * @param max_depth  The max depth to be displayed. If null, this function will show all levels.</span>
<a name="l03534"></a>03534 <span class="comment"> *                    </span>
<a name="l03535"></a>03535 <span class="comment"> * @return the text representing the tree with human readable format.</span>
<a name="l03536"></a>03536 <span class="comment"> *</span>
<a name="l03537"></a>03537 <span class="comment"> */</span>
<a name="l03538"></a>03538 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac0df8cd7d8eede8f1c204b263eb971a7" title="Display the trained decision tree model with human readable format.">c45_display</a>
<a name="l03539"></a>03539     (
<a name="l03540"></a>03540     tree_table  TEXT,
<a name="l03541"></a>03541     max_depth   INT
<a name="l03542"></a>03542     );
<a name="l03543"></a>03543 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac0df8cd7d8eede8f1c204b263eb971a7" title="Display the trained decision tree model with human readable format.">c45_display</a>
<a name="l03544"></a>03544     (
<a name="l03545"></a>03545     tree_table  TEXT,
<a name="l03546"></a>03546     max_depth   INT
<a name="l03547"></a>03547     ) 
<a name="l03548"></a>03548 RETURNS TEXT AS $$
<a name="l03549"></a>03549 DECLARE
<a name="l03550"></a>03550 BEGIN
<a name="l03551"></a>03551     -- get rid of the messages whose severity level is lower than &#39;WARNING&#39;
<a name="l03552"></a>03552     SET client_min_messages = WARNING;
<a name="l03553"></a>03553     
<a name="l03554"></a>03554     PERFORM MADLIB_SCHEMA.__assert
<a name="l03555"></a>03555             (
<a name="l03556"></a>03556                 (tree_table IS NOT NULL) AND
<a name="l03557"></a>03557                 (
<a name="l03558"></a>03558                  MADLIB_SCHEMA.__table_exists
<a name="l03559"></a>03559                     (
<a name="l03560"></a>03560                         MADLIB_SCHEMA.__get_schema_name(tree_table),
<a name="l03561"></a>03561                         MADLIB_SCHEMA.__strip_schema_name(tree_table)
<a name="l03562"></a>03562                     )
<a name="l03563"></a>03563                 ),
<a name="l03564"></a>03564                 &#39;the specified tree table&#39; || coalesce(&#39;&lt;&#39; || tree_table || &#39;&gt; does not exists&#39;, &#39; is NULL&#39;)
<a name="l03565"></a>03565             );   
<a name="l03566"></a>03566 
<a name="l03567"></a>03567 m4_changequote(`&gt;&gt;&gt;&#39;, `&lt;&lt;&lt;&#39;)
<a name="l03568"></a>03568 m4_ifdef(&gt;&gt;&gt;__HAS_ORDERED_AGGREGATES__&lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l03569"></a>03569     RETURN MADLIB_SCHEMA.__c45_display_with_ordered_aggr(tree_table,max_depth);
<a name="l03570"></a>03570 &lt;&lt;&lt;, &gt;&gt;&gt;
<a name="l03571"></a>03571     RETURN MADLIB_SCHEMA.__c45_display_no_ordered_aggr(tree_table,max_depth);
<a name="l03572"></a>03572 &lt;&lt;&lt;)
<a name="l03573"></a>03573 m4_changequote(&gt;&gt;&gt;`&lt;&lt;&lt;, &gt;&gt;&gt;&#39;&lt;&lt;&lt;)
<a name="l03574"></a>03574 END $$ LANGUAGE PLPGSQL;
<a name="l03575"></a>03575 <span class="comment"></span>
<a name="l03576"></a>03576 <span class="comment">/**</span>
<a name="l03577"></a>03577 <span class="comment"> * @brief Display the whole trained decision tree model with human readable format.</span>
<a name="l03578"></a>03578 <span class="comment"> *</span>
<a name="l03579"></a>03579 <span class="comment"> * @param tree_table Name of the table containing the tree&#39;s information</span>
<a name="l03580"></a>03580 <span class="comment"> *                    </span>
<a name="l03581"></a>03581 <span class="comment"> * @return the text representing the tree with human readable format.</span>
<a name="l03582"></a>03582 <span class="comment"> *</span>
<a name="l03583"></a>03583 <span class="comment"> */</span>
<a name="l03584"></a>03584 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac0df8cd7d8eede8f1c204b263eb971a7" title="Display the trained decision tree model with human readable format.">c45_display</a>
<a name="l03585"></a>03585     (
<a name="l03586"></a>03586     tree_table  TEXT
<a name="l03587"></a>03587     );
<a name="l03588"></a>03588 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac0df8cd7d8eede8f1c204b263eb971a7" title="Display the trained decision tree model with human readable format.">c45_display</a>
<a name="l03589"></a>03589     (
<a name="l03590"></a>03590     tree_table  TEXT
<a name="l03591"></a>03591     ) 
<a name="l03592"></a>03592 RETURNS TEXT AS $$
<a name="l03593"></a>03593 DECLARE
<a name="l03594"></a>03594 BEGIN
<a name="l03595"></a>03595     RETURN MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac0df8cd7d8eede8f1c204b263eb971a7" title="Display the trained decision tree model with human readable format.">c45_display</a>(tree_table,NULL);
<a name="l03596"></a>03596 END $$ LANGUAGE PLPGSQL;
<a name="l03597"></a>03597 
<a name="l03598"></a>03598 <span class="comment">/*</span>
<a name="l03599"></a>03599 <span class="comment"> *  An internal c45 classification function. It is used to perform</span>
<a name="l03600"></a>03600 <span class="comment"> *  the real classification process.</span>
<a name="l03601"></a>03601 <span class="comment"> *</span>
<a name="l03602"></a>03602 <span class="comment"> *  Parameters:</span>
<a name="l03603"></a>03603 <span class="comment"> *      classification_table_name:  The table containing the classification set.</span>
<a name="l03604"></a>03604 <span class="comment"> *      tree_table_name:            The table containing the final tree.</span>
<a name="l03605"></a>03605 <span class="comment"> *      result_table_name:          The table containing the classification</span>
<a name="l03606"></a>03606 <span class="comment"> *                                  result.</span>
<a name="l03607"></a>03607 <span class="comment"> *      is_result_temp              It specifies whether the result_table should</span>
<a name="l03608"></a>03608 <span class="comment"> *                                  be temporary.</span>
<a name="l03609"></a>03609 <span class="comment"> *      verbosity:                  Whether printing those debug information.</span>
<a name="l03610"></a>03610 <span class="comment"> *  Return:</span>
<a name="l03611"></a>03611 <span class="comment"> *      The caller may need to clean that internal table.</span>
<a name="l03612"></a>03612 <span class="comment"> */</span>
<a name="l03613"></a>03613 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.__c45_classify_internal
<a name="l03614"></a>03614     (
<a name="l03615"></a>03615     classification_table_name   TEXT, 
<a name="l03616"></a>03616     tree_table_name             TEXT, 
<a name="l03617"></a>03617     result_table_name           TEXT, 
<a name="l03618"></a>03618     is_result_temp              BOOLEAN,
<a name="l03619"></a>03619     verbosity                   BOOLEAN
<a name="l03620"></a>03620     );
<a name="l03621"></a>03621     
<a name="l03622"></a>03622 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__c45_classify_internal
<a name="l03623"></a>03623     (
<a name="l03624"></a>03624     classification_table_name   TEXT, 
<a name="l03625"></a>03625     tree_table_name             TEXT, 
<a name="l03626"></a>03626     result_table_name           TEXT, 
<a name="l03627"></a>03627     is_result_temp              BOOLEAN,
<a name="l03628"></a>03628     verbosity                   BOOLEAN
<a name="l03629"></a>03629     ) 
<a name="l03630"></a>03630 RETURNS TEXT AS $$
<a name="l03631"></a>03631 DECLARE
<a name="l03632"></a>03632     table_pick              INT := 1;
<a name="l03633"></a>03633     remains_to_classify     INT;
<a name="l03634"></a>03634     size_finished           INT;
<a name="l03635"></a>03635     time_stamp              TIMESTAMP;
<a name="l03636"></a>03636     metatable_name          TEXT := &#39;&#39;;
<a name="l03637"></a>03637     id_col_name             TEXT := &#39;<span class="keywordtype">id</span>&#39;;
<a name="l03638"></a>03638     curr_level              INT := 1;
<a name="l03639"></a>03639     max_level               INT := 0;
<a name="l03640"></a>03640     create_text             TEXT := &#39;&#39;;
<a name="l03641"></a>03641     h2hmv_routine_id        INT := 0;
<a name="l03642"></a>03642     curstmt                 TEXT := &#39;&#39;;
<a name="l03643"></a>03643     encoded_table_name      TEXT := &#39;c45_classify_internal_edt&#39;;
<a name="l03644"></a>03644     table_names             TEXT[] = &#39;{classified_instance_ping,classified_instance_pong}<span class="stringliteral">&#39;;</span>
<a name="l03645"></a>03645 <span class="stringliteral">BEGIN</span>
<a name="l03646"></a>03646 <span class="stringliteral">    time_stamp = clock_timestamp();</span>
<a name="l03647"></a>03647 <span class="stringliteral"></span>
<a name="l03648"></a>03648 <span class="stringliteral">    PERFORM MADLIB_SCHEMA.__assert</span>
<a name="l03649"></a>03649 <span class="stringliteral">            (</span>
<a name="l03650"></a>03650 <span class="stringliteral">                (classification_table_name IS NOT NULL) AND</span>
<a name="l03651"></a>03651 <span class="stringliteral">                (</span>
<a name="l03652"></a>03652 <span class="stringliteral">                 MADLIB_SCHEMA.__table_exists</span>
<a name="l03653"></a>03653 <span class="stringliteral">                    (</span>
<a name="l03654"></a>03654 <span class="stringliteral">                        MADLIB_SCHEMA.__get_schema_name(classification_table_name),</span>
<a name="l03655"></a>03655 <span class="stringliteral">                        MADLIB_SCHEMA.__strip_schema_name(classification_table_name)</span>
<a name="l03656"></a>03656 <span class="stringliteral">                    )</span>
<a name="l03657"></a>03657 <span class="stringliteral">                ),</span>
<a name="l03658"></a>03658 <span class="stringliteral">                &#39;</span>the specified classification table<span class="stringliteral">&#39; || coalesce(&#39;</span>&lt;<span class="stringliteral">&#39; || classification_table_name || &#39;</span>&gt; does not exists<span class="stringliteral">&#39;, &#39;</span> is NULL<span class="stringliteral">&#39;)</span>
<a name="l03659"></a>03659 <span class="stringliteral">            );   </span>
<a name="l03660"></a>03660 <span class="stringliteral"></span>
<a name="l03661"></a>03661 <span class="stringliteral">    PERFORM MADLIB_SCHEMA.__assert</span>
<a name="l03662"></a>03662 <span class="stringliteral">            (</span>
<a name="l03663"></a>03663 <span class="stringliteral">                (tree_table_name IS NOT NULL) AND</span>
<a name="l03664"></a>03664 <span class="stringliteral">                (</span>
<a name="l03665"></a>03665 <span class="stringliteral">                 MADLIB_SCHEMA.__table_exists</span>
<a name="l03666"></a>03666 <span class="stringliteral">                    (</span>
<a name="l03667"></a>03667 <span class="stringliteral">                        MADLIB_SCHEMA.__get_schema_name(tree_table_name),</span>
<a name="l03668"></a>03668 <span class="stringliteral">                        MADLIB_SCHEMA.__strip_schema_name(tree_table_name)</span>
<a name="l03669"></a>03669 <span class="stringliteral">                    )</span>
<a name="l03670"></a>03670 <span class="stringliteral">                ),</span>
<a name="l03671"></a>03671 <span class="stringliteral">                &#39;</span>the specified tree table<span class="stringliteral">&#39; || coalesce(&#39;</span>&lt;<span class="stringliteral">&#39; || tree_table_name || &#39;</span>&gt; does not exists<span class="stringliteral">&#39;, &#39;</span> is NULL<span class="stringliteral">&#39;)</span>
<a name="l03672"></a>03672 <span class="stringliteral">            ); </span>
<a name="l03673"></a>03673 <span class="stringliteral"></span>
<a name="l03674"></a>03674 <span class="stringliteral">    PERFORM MADLIB_SCHEMA.__assert</span>
<a name="l03675"></a>03675 <span class="stringliteral">            (</span>
<a name="l03676"></a>03676 <span class="stringliteral">                (result_table_name IS NOT NULL) AND</span>
<a name="l03677"></a>03677 <span class="stringliteral">                (</span>
<a name="l03678"></a>03678 <span class="stringliteral">                 NOT MADLIB_SCHEMA.__table_exists</span>
<a name="l03679"></a>03679 <span class="stringliteral">                    (</span>
<a name="l03680"></a>03680 <span class="stringliteral">                        MADLIB_SCHEMA.__get_schema_name(result_table_name),</span>
<a name="l03681"></a>03681 <span class="stringliteral">                        MADLIB_SCHEMA.__strip_schema_name(result_table_name)</span>
<a name="l03682"></a>03682 <span class="stringliteral">                    )</span>
<a name="l03683"></a>03683 <span class="stringliteral">                ),</span>
<a name="l03684"></a>03684 <span class="stringliteral">                &#39;</span>the specified result table<span class="stringliteral">&#39; || coalesce(&#39;</span>&lt;<span class="stringliteral">&#39; || result_table_name || &#39;</span>&gt; exists<span class="stringliteral">&#39;, &#39;</span> is NULL<span class="stringliteral">&#39;)</span>
<a name="l03685"></a>03685 <span class="stringliteral">            ); </span>
<a name="l03686"></a>03686 <span class="stringliteral">                                    </span>
<a name="l03687"></a>03687 <span class="stringliteral">    PERFORM MADLIB_SCHEMA.__assert</span>
<a name="l03688"></a>03688 <span class="stringliteral">            (</span>
<a name="l03689"></a>03689 <span class="stringliteral">                verbosity IS NOT NULL,                </span>
<a name="l03690"></a>03690 <span class="stringliteral">                &#39;</span>verbosity must be non-null<span class="stringliteral">&#39;</span>
<a name="l03691"></a>03691 <span class="stringliteral">            );    </span>
<a name="l03692"></a>03692 <span class="stringliteral">            </span>
<a name="l03693"></a>03693 <span class="stringliteral">    EXECUTE &#39;</span>DROP TABLE IF EXISTS <span class="stringliteral">&#39; || encoded_table_name || &#39;</span> CASCADE<span class="stringliteral">&#39;;</span>
<a name="l03694"></a>03694 <span class="stringliteral">                                 </span>
<a name="l03695"></a>03695 <span class="stringliteral">    SELECT MADLIB_SCHEMA.__get_metatable_name(tree_table_name) INTO metatable_name;</span>
<a name="l03696"></a>03696 <span class="stringliteral"></span>
<a name="l03697"></a>03697 <span class="stringliteral">    SELECT MADLIB_SCHEMA.__get_routine_id(tree_table_name) INTO h2hmv_routine_id;</span>
<a name="l03698"></a>03698 <span class="stringliteral">    </span>
<a name="l03699"></a>03699 <span class="stringliteral">    PERFORM MADLIB_SCHEMA.__encode_tabular_table</span>
<a name="l03700"></a>03700 <span class="stringliteral">        (</span>
<a name="l03701"></a>03701 <span class="stringliteral">            classification_table_name, </span>
<a name="l03702"></a>03702 <span class="stringliteral">            encoded_table_name, </span>
<a name="l03703"></a>03703 <span class="stringliteral">            metatable_name, </span>
<a name="l03704"></a>03704 <span class="stringliteral">            h2hmv_routine_id,</span>
<a name="l03705"></a>03705 <span class="stringliteral">            verbosity</span>
<a name="l03706"></a>03706 <span class="stringliteral">        );</span>
<a name="l03707"></a>03707 <span class="stringliteral">        </span>
<a name="l03708"></a>03708 <span class="stringliteral">    IF ( verbosity ) THEN</span>
<a name="l03709"></a>03709 <span class="stringliteral">        RAISE INFO &#39;</span>tabular format. id_col_name: %<span class="stringliteral">&#39;, id_col_name;</span>
<a name="l03710"></a>03710 <span class="stringliteral">    END IF;        </span>
<a name="l03711"></a>03711 <span class="stringliteral">    </span>
<a name="l03712"></a>03712 <span class="stringliteral">    DROP TABLE IF EXISTS classified_instance_ping;</span>
<a name="l03713"></a>03713 <span class="stringliteral">    CREATE TEMP TABLE classified_instance_ping</span>
<a name="l03714"></a>03714 <span class="stringliteral">    (</span>
<a name="l03715"></a>03715 <span class="stringliteral">        id          INT,</span>
<a name="l03716"></a>03716 <span class="stringliteral">        jump        INT,</span>
<a name="l03717"></a>03717 <span class="stringliteral">        class       INT,</span>
<a name="l03718"></a>03718 <span class="stringliteral">        prob        FLOAT,</span>
<a name="l03719"></a>03719 <span class="stringliteral">        parent_id   INT,</span>
<a name="l03720"></a>03720 <span class="stringliteral">        leaf_id     INT</span>
<a name="l03721"></a>03721 <span class="stringliteral">    ) m4_ifdef(`__GREENPLUM__&#39;</span>, `DISTRIBUTED BY (jump)<span class="stringliteral">&#39;);</span>
<a name="l03722"></a>03722 <span class="stringliteral">    </span>
<a name="l03723"></a>03723 <span class="stringliteral">    DROP TABLE IF EXISTS classified_instance_pong;</span>
<a name="l03724"></a>03724 <span class="stringliteral">    CREATE TEMP TABLE classified_instance_pong</span>
<a name="l03725"></a>03725 <span class="stringliteral">    (</span>
<a name="l03726"></a>03726 <span class="stringliteral">        id          INT,</span>
<a name="l03727"></a>03727 <span class="stringliteral">        jump        INT,</span>
<a name="l03728"></a>03728 <span class="stringliteral">        class       INT,</span>
<a name="l03729"></a>03729 <span class="stringliteral">        prob        FLOAT,</span>
<a name="l03730"></a>03730 <span class="stringliteral">        parent_id   INT,</span>
<a name="l03731"></a>03731 <span class="stringliteral">        leaf_id     INT</span>
<a name="l03732"></a>03732 <span class="stringliteral">    ) m4_ifdef(`__GREENPLUM__&#39;</span>, `DISTRIBUTED BY (jump)<span class="stringliteral">&#39;);</span>
<a name="l03733"></a>03733 <span class="stringliteral">    </span>
<a name="l03734"></a>03734 <span class="stringliteral">    IF (is_result_temp) THEN</span>
<a name="l03735"></a>03735 <span class="stringliteral">        create_text = &#39;</span>CREATE TEMP TABLE <span class="stringliteral">&#39;;</span>
<a name="l03736"></a>03736 <span class="stringliteral">        EXECUTE &#39;</span>DROP TABLE IF EXISTS <span class="stringliteral">&#39;||result_table_name;</span>
<a name="l03737"></a>03737 <span class="stringliteral">    ELSE</span>
<a name="l03738"></a>03738 <span class="stringliteral">        create_text = &#39;</span>CREATE TABLE <span class="stringliteral">&#39;;</span>
<a name="l03739"></a>03739 <span class="stringliteral">    END IF;</span>
<a name="l03740"></a>03740 <span class="stringliteral">    </span>
<a name="l03741"></a>03741 <span class="stringliteral">    EXECUTE create_text || result_table_name || E&#39;</span>
<a name="l03742"></a>03742     (
<a name="l03743"></a>03743         <span class="keywordtype">id</span>          INT,
<a name="l03744"></a>03744         jump        INT,
<a name="l03745"></a>03745         <span class="keyword">class       </span>INT,
<a name="l03746"></a>03746         prob        FLOAT,
<a name="l03747"></a>03747         parent_id   INT,
<a name="l03748"></a>03748         leaf_id     INT
<a name="l03749"></a>03749     )m4_ifdef(`__GREENPLUM__&#39;, `DISTRIBUTED BY (id)&#39;);<span class="stringliteral">&#39;;</span>
<a name="l03750"></a>03750 <span class="stringliteral"></span>
<a name="l03751"></a>03751 <span class="stringliteral"></span>
<a name="l03752"></a><a class="code" href="decision__tree_8sql__in.html#acd4a010fffd70c701afc3de7c2a3d5f8">03752</a> <span class="stringliteral">    EXECUTE &#39;</span>INSERT INTO classified_instance_ping (<span class="keywordtype">id</span>, jump, <span class="keyword">class</span>, prob) SELECT &#39;
<a name="l03753"></a>03753         ||id_col_name||&#39;, 1, 0, 0 FROM &#39; || encoded_table_name || &#39;;&#39;;  
<a name="l03754"></a>03754 
<a name="l03755"></a>03755     
<a name="l03756"></a>03756     EXECUTE &#39;SELECT max(array_upper(tree_location,1)) FROM &#39;||tree_table_name||&#39;;&#39;  INTO max_level;
<a name="l03757"></a>03757 
<a name="l03758"></a>03758     IF( max_level is NULL ) THEN
<a name="l03759"></a>03759         RAISE EXCEPTION &#39;tree should not be empty&#39;;
<a name="l03760"></a>03760     END IF;
<a name="l03761"></a>03761 
<a name="l03762"></a>03762     FOR curr_level IN 1..max_level LOOP
<a name="l03763"></a>03763         IF(verbosity) THEN  
<a name="l03764"></a>03764             RAISE INFO &#39;new_depth: %&#39;, curr_level;
<a name="l03765"></a>03765         END IF;
<a name="l03766"></a>03766 
<a name="l03767"></a>03767         EXECUTE &#39;INSERT INTO &#39; || result_table_name ||&#39; SELECT * FROM &#39;|| 
<a name="l03768"></a>03768             table_names[(table_pick) % 2 + 1] ||&#39; WHERE jump = 0;&#39;;
<a name="l03769"></a>03769         EXECUTE &#39;TRUNCATE &#39;|| table_names[(table_pick) % 2 + 1] ||&#39;;&#39;;
<a name="l03770"></a>03770         EXECUTE &#39;SELECT count(<span class="keywordtype">id</span>) FROM &#39;||result_table_name||&#39;;&#39; INTO size_finished;
<a name="l03771"></a>03771         IF(verbosity) THEN  
<a name="l03772"></a>03772             RAISE INFO &#39;size_finished %&#39;, size_finished;
<a name="l03773"></a>03773         END IF;            
<a name="l03774"></a>03774         table_pick = table_pick % 2 + 1; 
<a name="l03775"></a>03775         
<a name="l03776"></a>03776         EXECUTE &#39;SELECT count(*) FROM &#39;|| table_names[(table_pick) % 2 + 1] ||&#39;;&#39; 
<a name="l03777"></a>03777             INTO remains_to_classify;
<a name="l03778"></a>03778             
<a name="l03779"></a>03779         IF (remains_to_classify = 0) THEN
<a name="l03780"></a>03780             IF(verbosity) THEN  
<a name="l03781"></a>03781                 RAISE INFO &#39;size_finished: % remains_to_classify: %&#39;, 
<a name="l03782"></a>03782                     size_finished, remains_to_classify;
<a name="l03783"></a>03783             END IF;  
<a name="l03784"></a>03784                   
<a name="l03785"></a>03785             EXIT;
<a name="l03786"></a>03786         END IF;
<a name="l03787"></a>03787 
<a name="l03788"></a>03788         SELECT MADLIB_SCHEMA.__format(
<a name="l03789"></a>03789             &#39;INSERT INTO %
<a name="l03790"></a>03790             SELECT pt.<span class="keywordtype">id</span>, 
<a name="l03791"></a>03791             CASE WHEN (is_feature_cont) THEN 
<a name="l03792"></a>03792                     COALESCE(gt.jump[
<a name="l03793"></a>03793                                      CASE WHEN (gt.split_value &lt; farray[gt.feature]) THEN
<a name="l03794"></a>03794                                         3
<a name="l03795"></a>03795                                      ELSE
<a name="l03796"></a>03796                                         2
<a name="l03797"></a>03797                                      END
<a name="l03798"></a>03798                                     ], 0)
<a name="l03799"></a>03799                 ELSE 
<a name="l03800"></a>03800                     COALESCE(gt.jump[farray[gt.feature] + 1],0) 
<a name="l03801"></a>03801                 END as newjump,
<a name="l03802"></a>03802             gt.maxclass, gt.probability, gt.parent_id, gt.<span class="keywordtype">id</span> 
<a name="l03803"></a>03803             FROM (
<a name="l03804"></a>03804                 SELECT t1.<span class="keywordtype">id</span>, t1.jump, % as farray  
<a name="l03805"></a>03805                 FROM % t1 
<a name="l03806"></a>03806                 LEFT JOIN % t2 
<a name="l03807"></a>03807                 ON t1.<span class="keywordtype">id</span> = t2.<span class="keywordtype">id</span>
<a name="l03808"></a>03808             ) AS pt,
<a name="l03809"></a>03809             (
<a name="l03810"></a>03810                 SELECT jump, maxclass,feature, probability, parent_id, <span class="keywordtype">id</span>, is_feature_cont, split_value
<a name="l03811"></a><a class="code" href="decision__tree_8sql__in.html#af5eb174eeecd11233409657221586cf1">03811</a>                 FROM % 
<a name="l03812"></a>03812                 WHERE array_upper(tree_location,1) = %
<a name="l03813"></a>03813             ) AS gt
<a name="l03814"></a>03814             WHERE pt.jump = gt.<span class="keywordtype">id</span>;&#39;,
<a name="l03815"></a>03815             ARRAY[
<a name="l03816"></a>03816                 table_names[table_pick],
<a name="l03817"></a>03817                 MADLIB_SCHEMA.__get_feature_name_list(metatable_name),
<a name="l03818"></a>03818                 table_names[(table_pick) % 2 + 1],
<a name="l03819"></a>03819                 encoded_table_name,
<a name="l03820"></a>03820                 tree_table_name,
<a name="l03821"></a>03821                 MADLIB_SCHEMA.__to_char(curr_level)
<a name="l03822"></a>03822             ]
<a name="l03823"></a>03823             )
<a name="l03824"></a>03824         INTO curstmt;     
<a name="l03825"></a>03825         EXECUTE curstmt;
<a name="l03826"></a>03826          
<a name="l03827"></a>03827     END LOOP;
<a name="l03828"></a>03828 
<a name="l03829"></a>03829     EXECUTE &#39;INSERT INTO &#39;||result_table_name||&#39; SELECT * FROM &#39;|| 
<a name="l03830"></a>03830         table_names[table_pick] ||&#39; WHERE jump = 0;&#39;;
<a name="l03831"></a>03831     EXECUTE &#39;INSERT INTO &#39;||result_table_name||&#39; SELECT * FROM &#39;|| 
<a name="l03832"></a>03832         table_names[table_pick % 2 + 1] ||&#39; WHERE jump = 0;&#39;;
<a name="l03833"></a>03833     
<a name="l03834"></a>03834     IF(verbosity) THEN  
<a name="l03835"></a>03835         RAISE INFO &#39;final classification time:%&#39;, clock_timestamp() - time_stamp;
<a name="l03836"></a>03836     END IF;
<a name="l03837"></a>03837     
<a name="l03838"></a>03838     RETURN encoded_table_name;
<a name="l03839"></a>03839 END
<a name="l03840"></a>03840 $$ LANGUAGE PLPGSQL;
<a name="l03841"></a>03841    
<a name="l03842"></a>03842     <span class="comment"></span>
<a name="l03843"></a>03843 <span class="comment">/**</span>
<a name="l03844"></a>03844 <span class="comment"> * @brief Classify dataset using trained decision tree model.</span>
<a name="l03845"></a>03845 <span class="comment"> *</span>
<a name="l03846"></a>03846 <span class="comment"> * @param tree_table_name               Name of trained tree</span>
<a name="l03847"></a>03847 <span class="comment"> * @param classification_table_name Name of the table/view with the source data</span>
<a name="l03848"></a>03848 <span class="comment"> * @param result_table_name             Name of result table</span>
<a name="l03849"></a>03849 <span class="comment"> * @param verbosity                     If set to &#39;t&#39; will use verbose mode</span>
<a name="l03850"></a>03850 <span class="comment"> *</span>
<a name="l03851"></a><a class="code" href="decision__tree_8sql__in.html#acafaf78df08122c1ab5cb4ad41831ed3">03851</a> <span class="comment"> * @return The columns of classified table:</span>
<a name="l03852"></a>03852 <span class="comment"> * - &lt;tt&gt;id INT&lt;/tt&gt; - Record id.</span>
<a name="l03853"></a>03853 <span class="comment"> * - &lt;tt&gt;class INT&lt;/tt&gt; - Predicted class.</span>
<a name="l03854"></a>03854 <span class="comment"> * - &lt;tt&gt;prob FLOAT&lt;/tt&gt; - Probability of the predicted class.</span>
<a name="l03855"></a>03855 <span class="comment"> */</span>
<a name="l03856"></a>03856 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#acd4a010fffd70c701afc3de7c2a3d5f8" title="Classify dataset using trained decision tree model.">c45_classify</a>
<a name="l03857"></a>03857     (
<a name="l03858"></a>03858     tree_table_name             TEXT, 
<a name="l03859"></a>03859     classification_table_name   TEXT, 
<a name="l03860"></a>03860     result_table_name           TEXT, 
<a name="l03861"></a>03861     verbosity                   BOOLEAN
<a name="l03862"></a>03862     );
<a name="l03863"></a>03863     
<a name="l03864"></a>03864 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#acd4a010fffd70c701afc3de7c2a3d5f8" title="Classify dataset using trained decision tree model.">c45_classify</a>
<a name="l03865"></a>03865     (
<a name="l03866"></a>03866     tree_table_name             TEXT, 
<a name="l03867"></a>03867     classification_table_name   TEXT, 
<a name="l03868"></a>03868     result_table_name           TEXT, 
<a name="l03869"></a>03869     verbosity                   BOOLEAN
<a name="l03870"></a>03870     ) 
<a name="l03871"></a>03871 RETURNS MADLIB_SCHEMA.c45_classify_result AS $$
<a name="l03872"></a>03872 DECLARE
<a name="l03873"></a>03873     encoded_table_name  TEXT := &#39;&#39;;
<a name="l03874"></a>03874     begin_time          TIMESTAMP;
<a name="l03875"></a>03875     ret                 MADLIB_SCHEMA.c45_classify_result;
<a name="l03876"></a>03876 BEGIN
<a name="l03877"></a>03877     IF (NOT verbosity) THEN
<a name="l03878"></a>03878         -- get rid of the messages whose severity level is lower than &#39;WARNING&#39;
<a name="l03879"></a>03879         SET client_min_messages = WARNING;
<a name="l03880"></a>03880     END IF;
<a name="l03881"></a>03881     
<a name="l03882"></a>03882     begin_time = clock_timestamp();
<a name="l03883"></a>03883     
<a name="l03884"></a>03884     SELECT MADLIB_SCHEMA.__c45_classify_internal
<a name="l03885"></a>03885         (
<a name="l03886"></a>03886         classification_table_name, 
<a name="l03887"></a>03887         tree_table_name, 
<a name="l03888"></a>03888         result_table_name, 
<a name="l03889"></a>03889         &#39;f&#39;,
<a name="l03890"></a>03890         verbosity
<a name="l03891"></a>03891         )  INTO encoded_table_name;
<a name="l03892"></a>03892     
<a name="l03893"></a>03893     EXECUTE &#39;ALTER TABLE &#39;||result_table_name||&#39; DROP COLUMN jump;&#39;;
<a name="l03894"></a>03894     EXECUTE &#39;ALTER TABLE &#39;||result_table_name||&#39; DROP COLUMN parent_id;&#39;;
<a name="l03895"></a>03895     EXECUTE &#39;ALTER TABLE &#39;||result_table_name||&#39; DROP COLUMN leaf_id;&#39;;
<a name="l03896"></a>03896     EXECUTE &#39;DROP TABLE IF EXISTS &#39; || encoded_table_name || &#39;;&#39;;
<a name="l03897"></a>03897     EXECUTE &#39;SELECT COUNT(*) FROM &#39; ||classification_table_name||&#39;;&#39; INTO ret.input_set_size;
<a name="l03898"></a>03898     
<a name="l03899"></a>03899     ret.cost_time = clock_timestamp() - begin_time;
<a name="l03900"></a>03900     
<a name="l03901"></a>03901     RETURN ret;
<a name="l03902"></a>03902 END
<a name="l03903"></a>03903 $$ LANGUAGE PLPGSQL;
<a name="l03904"></a>03904 <span class="comment"></span>
<a name="l03905"></a>03905 <span class="comment">/**</span>
<a name="l03906"></a>03906 <span class="comment"> * @brief Classify dataset using trained decision tree model.</span>
<a name="l03907"></a>03907 <span class="comment"> *  </span>
<a name="l03908"></a>03908 <span class="comment"> * @param classification_table_name     Name of the table/view with the source data</span>
<a name="l03909"></a>03909 <span class="comment"> * @param tree_table_name               Name of trained tree</span>
<a name="l03910"></a>03910 <span class="comment"> * @param result_table_name             Name of result table</span>
<a name="l03911"></a>03911 <span class="comment"> *</span>
<a name="l03912"></a>03912 <span class="comment"> * @return The columns of classified table:</span>
<a name="l03913"></a>03913 <span class="comment"> * - &lt;tt&gt;id INT&lt;/tt&gt; - Record id.</span>
<a name="l03914"></a>03914 <span class="comment"> * - &lt;tt&gt;class INT&lt;/tt&gt; - Predicted class.</span>
<a name="l03915"></a>03915 <span class="comment"> * - &lt;tt&gt;prob FLOAT&lt;/tt&gt; - Probability of the predicted class.</span>
<a name="l03916"></a>03916 <span class="comment"> */</span>
<a name="l03917"></a>03917 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#acd4a010fffd70c701afc3de7c2a3d5f8" title="Classify dataset using trained decision tree model.">c45_classify</a>
<a name="l03918"></a>03918     (
<a name="l03919"></a>03919     tree_table_name             TEXT, 
<a name="l03920"></a>03920     classification_table_name   TEXT, 
<a name="l03921"></a>03921     result_table_name           TEXT
<a name="l03922"></a>03922     );
<a name="l03923"></a>03923 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#acd4a010fffd70c701afc3de7c2a3d5f8" title="Classify dataset using trained decision tree model.">c45_classify</a>
<a name="l03924"></a>03924     (
<a name="l03925"></a>03925     tree_table_name             TEXT, 
<a name="l03926"></a>03926     classification_table_name   TEXT, 
<a name="l03927"></a>03927     result_table_name           TEXT
<a name="l03928"></a>03928     ) 
<a name="l03929"></a>03929 RETURNS MADLIB_SCHEMA.c45_classify_result AS $$
<a name="l03930"></a>03930 DECLARE
<a name="l03931"></a>03931     ret MADLIB_SCHEMA.c45_classify_result;
<a name="l03932"></a>03932 BEGIN
<a name="l03933"></a>03933     -- get rid of the messages whose severity level is lower than &#39;WARNING&#39;
<a name="l03934"></a>03934     SET client_min_messages = WARNING;
<a name="l03935"></a>03935     
<a name="l03936"></a>03936     ret = MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#acd4a010fffd70c701afc3de7c2a3d5f8" title="Classify dataset using trained decision tree model.">c45_classify</a>
<a name="l03937"></a>03937            (
<a name="l03938"></a>03938            tree_table_name,
<a name="l03939"></a>03939            classification_table_name, 
<a name="l03940"></a>03940            result_table_name,
<a name="l03941"></a>03941            &#39;f&#39;
<a name="l03942"></a>03942            );
<a name="l03943"></a>03943            
<a name="l03944"></a>03944     RETURN ret;
<a name="l03945"></a>03945 END $$ LANGUAGE PLPGSQL;
<a name="l03946"></a>03946 <span class="comment"></span>
<a name="l03947"></a>03947 <span class="comment">/**</span>
<a name="l03948"></a>03948 <span class="comment"> * @brief Check the accuracy of the decision tree model.</span>
<a name="l03949"></a>03949 <span class="comment"> * </span>
<a name="l03950"></a>03950 <span class="comment"> * @param tree_table_name           Name of trained tree</span>
<a name="l03951"></a>03951 <span class="comment"> * @param scoring_table_name        Name of the table/view with the source data</span>
<a name="l03952"></a>03952 <span class="comment"> * @param verbosity                 If set to &#39;t&#39; will use verbose mode </span>
<a name="l03953"></a>03953 <span class="comment"> *</span>
<a name="l03954"></a>03954 <span class="comment"> * @return The estimated accuracy information.</span>
<a name="l03955"></a>03955 <span class="comment"> */</span>
<a name="l03956"></a>03956 DROP FUNCTION IF EXISTS MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#acafaf78df08122c1ab5cb4ad41831ed3" title="Check the accuracy of the decision tree model.">c45_score</a>
<a name="l03957"></a>03957     (
<a name="l03958"></a>03958     tree_table_name             TEXT, 
<a name="l03959"></a>03959     scoring_table_name          TEXT, 
<a name="l03960"></a>03960     verbosity                   BOOLEAN
<a name="l03961"></a>03961     );
<a name="l03962"></a>03962     
<a name="l03963"></a>03963 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#acafaf78df08122c1ab5cb4ad41831ed3" title="Check the accuracy of the decision tree model.">c45_score</a>
<a name="l03964"></a>03964     (
<a name="l03965"></a><a class="code" href="decision__tree_8sql__in.html#ac25e17ecbc70149aa559018e718fc793">03965</a>     tree_table_name             TEXT, 
<a name="l03966"></a>03966     scoring_table_name          TEXT, 
<a name="l03967"></a>03967     verbosity                   BOOLEAN
<a name="l03968"></a>03968     ) 
<a name="l03969"></a>03969 RETURNS FLOAT AS $$
<a name="l03970"></a>03970 DECLARE
<a name="l03971"></a>03971     result_table_name   TEXT = &#39;c45_score_table_temp&#39;;
<a name="l03972"></a>03972     id_col_name         TEXT := &#39;<span class="keywordtype">id</span>&#39;;
<a name="l03973"></a>03973     class_col_name      TEXT := &#39;class&#39;;
<a name="l03974"></a>03974     curstmt             TEXT := &#39;&#39;;
<a name="l03975"></a>03975     num_of_row          FLOAT := 0.0;
<a name="l03976"></a>03976     mis_of_row          FLOAT := 0.0;
<a name="l03977"></a>03977     encoded_table_name  TEXT := &#39;&#39;;
<a name="l03978"></a>03978 BEGIN
<a name="l03979"></a>03979 
<a name="l03980"></a>03980     IF (NOT verbosity) THEN
<a name="l03981"></a>03981         -- get rid of the messages whose severity level is lower than &#39;WARNING&#39;
<a name="l03982"></a>03982         SET client_min_messages = WARNING;
<a name="l03983"></a>03983     END IF;
<a name="l03984"></a>03984     
<a name="l03985"></a>03985     PERFORM MADLIB_SCHEMA.__assert
<a name="l03986"></a>03986             (
<a name="l03987"></a>03987                 (tree_table_name IS NOT NULL) AND
<a name="l03988"></a>03988                 (
<a name="l03989"></a>03989                  MADLIB_SCHEMA.__table_exists
<a name="l03990"></a>03990                     (
<a name="l03991"></a>03991                         MADLIB_SCHEMA.__get_schema_name(tree_table_name),
<a name="l03992"></a>03992                         MADLIB_SCHEMA.__strip_schema_name(tree_table_name)
<a name="l03993"></a>03993                     )
<a name="l03994"></a>03994                 ),
<a name="l03995"></a>03995                 &#39;the specified tree table&#39; || coalesce(&#39;&lt;&#39; || tree_table_name || &#39;&gt; does not exist&#39;, &#39; is NULL&#39;)
<a name="l03996"></a>03996             ); 
<a name="l03997"></a>03997 
<a name="l03998"></a>03998     PERFORM MADLIB_SCHEMA.__assert
<a name="l03999"></a>03999             (
<a name="l04000"></a>04000                 (scoring_table_name IS NOT NULL) AND
<a name="l04001"></a>04001                 (
<a name="l04002"></a>04002                  MADLIB_SCHEMA.__table_exists
<a name="l04003"></a>04003                     (
<a name="l04004"></a>04004                         MADLIB_SCHEMA.__get_schema_name(scoring_table_name),
<a name="l04005"></a>04005                         MADLIB_SCHEMA.__strip_schema_name(scoring_table_name)
<a name="l04006"></a>04006                     )
<a name="l04007"></a>04007                 ),
<a name="l04008"></a>04008                 &#39;the specified scoring table&#39; || coalesce(&#39;&lt;&#39; || scoring_table_name || &#39;&gt; does not exist&#39;, &#39; is NULL&#39;)
<a name="l04009"></a>04009             ); 
<a name="l04010"></a>04010 
<a name="l04011"></a>04011     PERFORM MADLIB_SCHEMA.__assert
<a name="l04012"></a>04012         (
<a name="l04013"></a>04013             MADLIB_SCHEMA.__column_exists
<a name="l04014"></a>04014                 (
<a name="l04015"></a>04015                     MADLIB_SCHEMA.__get_schema_name(scoring_table_name),
<a name="l04016"></a>04016                     MADLIB_SCHEMA.__strip_schema_name(scoring_table_name),
<a name="l04017"></a>04017                     MADLIB_SCHEMA.__get_class_column_name(MADLIB_SCHEMA.__get_metatable_name(tree_table_name))
<a name="l04018"></a>04018                 ),
<a name="l04019"></a>04019             &#39;the specified scoring table&lt;&#39; || scoring_table_name || &#39;&gt; does not have class column&#39;
<a name="l04020"></a>04020         );
<a name="l04021"></a>04021             
<a name="l04022"></a>04022     result_table_name = MADLIB_SCHEMA.__get_schema_name(tree_table_name) || 
<a name="l04023"></a>04023                         MADLIB_SCHEMA.__strip_schema_name(tree_table_name) || 
<a name="l04024"></a>04024                         result_table_name;
<a name="l04025"></a>04025     
<a name="l04026"></a>04026     SELECT MADLIB_SCHEMA.__c45_classify_internal
<a name="l04027"></a>04027         (
<a name="l04028"></a>04028         scoring_table_name, 
<a name="l04029"></a>04029         tree_table_name, 
<a name="l04030"></a>04030         result_table_name, 
<a name="l04031"></a>04031         &#39;t&#39;,
<a name="l04032"></a>04032         verbosity
<a name="l04033"></a>04033         ) 
<a name="l04034"></a>04034     INTO encoded_table_name;
<a name="l04035"></a>04035     
<a name="l04036"></a>04036 
<a name="l04037"></a>04037     SELECT MADLIB_SCHEMA.__format
<a name="l04038"></a>04038         (
<a name="l04039"></a>04039         &#39;SELECT count(<span class="keywordtype">id</span>) FROM %;&#39;,
<a name="l04040"></a>04040         result_table_name
<a name="l04041"></a>04041         ) 
<a name="l04042"></a>04042     INTO curstmt;
<a name="l04043"></a>04043     
<a name="l04044"></a>04044     EXECUTE curstmt INTO num_of_row;
<a name="l04045"></a>04045     
<a name="l04046"></a>04046     SELECT MADLIB_SCHEMA.__format
<a name="l04047"></a>04047         (
<a name="l04048"></a>04048         &#39;SELECT count(b.<span class="keywordtype">id</span>) FROM % a, % b WHERE a.%=b.<span class="keywordtype">id</span> and a.%&lt;&gt;b.class&#39;,
<a name="l04049"></a>04049         encoded_table_name,
<a name="l04050"></a>04050         result_table_name,
<a name="l04051"></a>04051         id_col_name,
<a name="l04052"></a>04052         class_col_name
<a name="l04053"></a>04053         ) 
<a name="l04054"></a>04054     INTO curstmt;
<a name="l04055"></a>04055      
<a name="l04056"></a>04056     EXECUTE curstmt INTO mis_of_row;
<a name="l04057"></a>04057      
<a name="l04058"></a>04058     EXECUTE &#39;DROP TABLE IF EXISTS &#39; || encoded_table_name || &#39;;&#39;;
<a name="l04059"></a>04059     
<a name="l04060"></a>04060     RETURN (num_of_row - mis_of_row) / num_of_row;
<a name="l04061"></a>04061     
<a name="l04062"></a>04062 END;
<a name="l04063"></a>04063 $$ LANGUAGE PLPGSQL;
<a name="l04064"></a>04064 <span class="comment"></span>
<a name="l04065"></a>04065 <span class="comment">/**</span>
<a name="l04066"></a>04066 <span class="comment"> * @brief Cleanup the trained tree table and any relevant tables.</span>
<a name="l04067"></a>04067 <span class="comment"> *</span>
<a name="l04068"></a>04068 <span class="comment"> * @param result_tree_table_name Name of the table containing the tree&#39;s information</span>
<a name="l04069"></a>04069 <span class="comment"> *</span>
<a name="l04070"></a>04070 <span class="comment"> * @return The status of that cleanup operation.</span>
<a name="l04071"></a>04071 <span class="comment"> *</span>
<a name="l04072"></a>04072 <span class="comment"> */</span>
<a name="l04073"></a>04073 DROP FUNCTION IF EXISTS  MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac25e17ecbc70149aa559018e718fc793" title="Cleanup the trained tree table and any relevant tables.">c45_clean</a>
<a name="l04074"></a>04074     (
<a name="l04075"></a>04075     TEXT
<a name="l04076"></a>04076     );
<a name="l04077"></a>04077 CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.<a class="code" href="decision__tree_8sql__in.html#ac25e17ecbc70149aa559018e718fc793" title="Cleanup the trained tree table and any relevant tables.">c45_clean</a>
<a name="l04078"></a>04078     ( 
<a name="l04079"></a>04079     result_tree_table_name TEXT
<a name="l04080"></a>04080     ) 
<a name="l04081"></a>04081 RETURNS BOOLEAN AS $$
<a name="l04082"></a>04082 DECLARE
<a name="l04083"></a>04083     metatable_name TEXT;
<a name="l04084"></a>04084 BEGIN
<a name="l04085"></a>04085     -- get rid of the messages whose severity level is lower than &#39;WARNING&#39;
<a name="l04086"></a>04086     SET client_min_messages = WARNING;
<a name="l04087"></a>04087         
<a name="l04088"></a>04088     PERFORM MADLIB_SCHEMA.__assert
<a name="l04089"></a>04089             (
<a name="l04090"></a>04090                 (result_tree_table_name IS NOT NULL) AND
<a name="l04091"></a>04091                 (
<a name="l04092"></a>04092                  MADLIB_SCHEMA.__table_exists
<a name="l04093"></a>04093                     (
<a name="l04094"></a>04094                         MADLIB_SCHEMA.__get_schema_name(result_tree_table_name),
<a name="l04095"></a>04095                         MADLIB_SCHEMA.__strip_schema_name(result_tree_table_name)
<a name="l04096"></a>04096                     )
<a name="l04097"></a>04097                 ),
<a name="l04098"></a>04098                 &#39;the specified tree table&#39; || coalesce(&#39;&lt;&#39; || result_tree_table_name || &#39;&gt; does not exists&#39;, &#39; is NULL&#39;)
<a name="l04099"></a>04099             ); 
<a name="l04100"></a>04100                                     
<a name="l04101"></a>04101                 
<a name="l04102"></a>04102     IF (MADLIB_SCHEMA.__table_exists(&#39;MADLIB_SCHEMA&#39;, &#39;training_info&#39;)) THEN
<a name="l04103"></a>04103         metatable_name = MADLIB_SCHEMA.__get_metatable_name(result_tree_table_name);
<a name="l04104"></a>04104         
<a name="l04105"></a>04105         IF( metatable_name IS NOT NULL) THEN
<a name="l04106"></a>04106             PERFORM MADLIB_SCHEMA.__drop_metatable(metatable_name);
<a name="l04107"></a>04107             EXECUTE &#39;DROP TABLE IF EXISTS &#39; || 
<a name="l04108"></a>04108                      MADLIB_SCHEMA.__get_encode_table_name(result_tree_table_name) || &#39;;&#39;;
<a name="l04109"></a>04109         END IF;
<a name="l04110"></a>04110         
<a name="l04111"></a>04111         EXECUTE &#39;DROP TABLE IF EXISTS &#39; || result_tree_table_name;
<a name="l04112"></a>04112         PERFORM MADLIB_SCHEMA.__delete_traininginfo(result_tree_table_name);
<a name="l04113"></a>04113     ELSE
<a name="l04114"></a>04114         EXECUTE &#39;DROP TABLE IF EXISTS &#39; || result_tree_table_name;
<a name="l04115"></a>04115     END IF;
<a name="l04116"></a>04116     
<a name="l04117"></a>04117     RETURN &#39;t&#39;;    
<a name="l04118"></a>04118 END
<a name="l04119"></a>04119 $$ LANGUAGE PLPGSQL;
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="decision__tree_8sql__in.html">decision_tree.sql_in</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Fri May 18 2012 04:29:16 for MADlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
